---
title: ES6 核心向新特性（01）
date: 2018-03-07 14:19:15
tags:
---

## 块级作用域变量声明关键字 let 、 const

### let 、 const 与 var 的对比
* 不存在变量提升；
```js
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```
* 暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）；
```js
typeof x; // ReferenceError
let x;
```

* let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用；
```js
{
  let a = 10;
  var b = 1;
}
a // ReferenceError: a is not defined.
b // 1
```
* 使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改；
```js
const b = 'hello';
b = 'world'; // Uncaught TyperError: Assignment to constant variable.
```
* 使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面；
```js
let a = 1;
var A = 2;

console.log(window.a || global.a); // undefined
console.log(window.A || global.A); // 2
```
* 用 let 、 const 赋值语句的执行速度比使用 var 快约65%；
### 使用场景的区分
模块内不变的引用和常量，使用`const`定义；可变的变量或引用使用`let`声明；`var`仅用于声明函数整个作用域内需要使用的变量。

## 字符串模板
```js
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`
```
* 字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁
* 字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出

## 解构赋值
解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。
### 数组解构
▼ **变量的赋值**
```js
let [a, b, c] = [11, 22];
a // 11
b // 22
c // undefined

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
▼ **指定默认值**
```js
let [foo = true] = [];
foo // true
```
### 对象解构
▼ **变量的赋值**（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）
```js
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```
▼ **指定默认值**
```js
var {x = 3} = {};
x // 3
```

## 数组的新特性
### 扩展运算符(`...`)
```js
const arr =['hello', 'world'];
const newArr = [...arr]; // ['hello', 'world']
```
**注意点**： `...`进行的数组复制是浅拷贝
### 扩展API
* `Array.from`: 用于将数组对象转化为真正的数组
```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```
* `Array.of`: 将传入的一组参数转换为数组
```js
Array.of(3, 11, 8) // [3,11,8]
```
* `Array.prototype.copyWithin`: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用`copyWithin`方法会修改当前数组
```js
let colors = ['red', 'blue', 'green', 'green'];
colors.copyWithin(0, 3); // ['green', 'blue', 'green', 'green']
```
* `Array.prototype.fill`: 使用给定值，填充一个数组，会改变原来的数组
```js
colors.fill('black'); // ['black', black', black', black']
```
* `Arrau.prototype.find`: 用于找出第一个符合条件的数组元素
```js
colors.find(function(color) {
  if(color === 'green') {
    return color;
  }
}) // green
```
* `Array.prototype.findIndex`: 用来返回某个特定数组元素在数组中的位置
```js
colors.findIndex(function(color) {
  if(color === 'green') {
    return color;
  }
}) // 2
```
### 新的数组迭代方式
`entries()`、`keys()`和`values()`，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用`for...of`循环进行遍历，区别是`keys()`是对数组键名进行遍历，`values()`是对数组键值进行遍历，`entries()`是对数组中键值对进行遍历。
```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

学习参考：
[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)
《现代前端技术解析》