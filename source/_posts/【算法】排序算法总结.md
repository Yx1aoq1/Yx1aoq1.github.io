---
title: 【算法】排序算法总结
categories:
  - 算法
tags:
  - 排序算法
date: 2020-05-28 13:58:37
---
## 冒泡排序

* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
* 平均时间复杂度：O(n²)  最好情况：O(n)   最坏情况：O(n²)    内排序稳定

```js
function bubbleSort (arr) {
  const len = arr.length
  for (let i = 0; i < len - 1; i ++) {
    for (let j = 0; j < len - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = temp
      }
    }
  }
  return arr
}
```

## 插入排序

* 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
* 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
* 平均时间复杂度：O(n²)  最好情况：O(n)   最坏情况：O(n²)    内排序稳定

```js
function insertionSort (arr) {
  const len = arr.length
  let preIndex, current
  for (let i = 0; i < len - 1; i ++) {
    preIndex = i - 1
    current = arr[i]
    while (preIndex >= 0 && arr[preIndex] > current) {
      arr[preIndex + 1] = arr[preIndex]
      preIndex --
    }
    arr[preIndex + 1] = current
  }
  return arr
}
```

## 选择排序

* 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
* 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
* 重复第二步，直到所有元素均排序完毕
* 平均时间复杂度：O(n²)  最好情况：O(n²)   最坏情况：O(n²)    内排序不稳定

```js
function selectionSort (arr) {
  const len = arr.length
  let minIndex, temp
  for (let i = 0; i < len - 1; i ++) {
    minIndex = i                         // maxIndex始终作为最大值的位置索引
    for (let j = i + 1; j < len; j ++) { // 当前最大值的后一位开始比较
      if (arr[j] < arr[minIndex]) {    // 寻找最小的数
        minIndex = j                 // 将最小数的索引保存
      }
    }
    temp = arr[i] // 当前轮次中的i与最大值进行交换，以达成最大值在前的的目的
    arr[i] = arr[minIndex]
    arr[minIndex] = temp
  }
  return arr
}
```

## 快速排序

* 从数列中挑出⼀个元素，称为 “基准”（pivot）
* 重新排序数列，所有元素⽐基准值⼩的摆放在基准前⾯，所有元素⽐基准值⼤的摆在基准的后⾯（相同的数可以到任⼀边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
* 递归地（recursive）把⼩于基准值元素的⼦数列和⼤于基准值元素的⼦数列排序

```js
function quickSort (arr) {
  const len = arr.length
  if (len <= 1) {
    return arr
  }
  const pivotIndex = Math.floor(len / 2)
  const pivot = arr.splice(pivotIndex, 1)[0]
  let left = []
  let right = []
  for (let i = 0; i < len - 1; i ++) {
  	if (arr[i] < pivot) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}

// 上一个方法由于会创建大量数组导致空间上的浪费
function quickSort (arr, left, right) {
  const len = arr.length
  const left = typeof left !== 'number' ? 0 : left
  const right = typeof right !== 'number' ? len - 1 : right
  if (left < right) {
  	let partitionIndex = partition(arr, left, right)
    quickSort(arr, left, partitionIndex - 1)
    quickSort(arr, partitionIndex1, right)
  }
  returun arr
}

function partition (arr, left, right) {
  const pivot = arr[left]
  while (left < right) {
  	while (left < right && arr[right] > pivot) {
      right --
    }
    arr[left] = arr[right]
    while (left < right && arr[left] <= pivot) {
      left ++
    }
    arr[right] = arr[left]
  }
  arr[left] = pivot
  return left
}
```

## 归并排序

* 申请空间，使其⼤⼩为两个已经排序序列之和，该空间⽤来存放合并后的序列
* 设定两个指针，最初位置分别为两个已经排序序列的起始位置
* ⽐较两个指针所指向的元素，选择相对⼩的元素放⼊到合并空间，并移动指针到下⼀位置
* 重复步骤 3 直到某⼀指针达到序列尾
* 另⼀序列剩下的所有元素直接复制到合并序列尾
* 平均时间复杂度：O(n log n) 最好情况：O(n log n) 最坏情况：O(n log n) 外排序 稳定

```js
function mergeSort (arr) {
  const len = arr.length
  if (len < 2) {
    return arr
  }
  const middle = Math.floor(len / 2)
  const left = arr.slice(0, middle)
  const right = arr.slice(middle)
  return merge(mergeSort(left), mergeSort(right))
}

function merge (left, right){
  let result = []
  while (left.length > 0 && right.length > 0) {
    if (left[0] < right[0]) {
      result.push(left.shift()) // 把最小的最先取出，放到结果集中
    } else {
      result.push(right.shift())
    }
  }
  return result.concat(left).concat(right)
}
```

## 桶排序

* 桶排序是计数排序的升级版。它利⽤了函数的映射关系，⾼效与否的关键就在于这个映射函数的确定。为了使桶排序更加⾼效，我们需要做到这两点：
* 在额外空间充⾜的情况下，尽量增⼤桶的数量
* 使⽤的映射函数能够将输⼊的 N 个数据均匀的分配到 K 个桶中
* 同时，对于桶中元素的排序，选择何种⽐较排序算法对于性能的影响⾄关重要。

```js
function bubbleSort (arr) {
  const len = arr.length
  for (let i = 0; i < len - 1; i ++) {
    for (let j = 0; j < len - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = temp
      }
    }
  }
  return arr
}
```

## 计数排序

* 计数排序的核⼼在于将输⼊的数据值转化为键存储在额外开辟的数组空间中。作为⼀种线性时间复杂度的排序，计数排序要求输⼊的数据必须是有确定范围的整数

```js
function countingSort (arr, maxValue) {
  let bucket = new Array(maxValue + 1)
  let sortedIndex = 0
  const arrLen = arr.length
  const bucketLen = maxValue + 1
  for (let i = 0; i < arrLen; i ++) {
  	if (!bucket[arr[i]]) {
      bucket[arr[i]] = 0
    }
    bucket[arr[i]] ++
  }
  for (let j = 0; j < bucketLen; j ++) {
  	while (bucket[j] > 0) {
      arr[sortIndex ++] = j
      bucket[j]--
    }
  }
  return arr
}
```

## 希尔排序

* 选择一个增量序列 t1，t2，......，tk，其中 ti > tj, tk = 1
* 按增量序列个数 k，对序列进行 k 趟排序
* 每趟排序，根据对应的增量 ti，将待排序列分割成若干⻓度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表⻓度即为整个序列的⻓度
* 平均时间复杂度：O(n^1.3)  最好情况：O(n²)   最坏情况：O(n)    内排序不稳定

```js
function shellSort (arr) {
  const len = arr.length
  let temp
  let gap = 1
  while (gap < len / 3) {
  	gap = gap * 3 + 1
  }
  for (gap; gap > 0; gap = Math.floor(gap / 3)) {
  	for (let i = gap; i < len; i ++) {
      temp = arr[i]
      for (let j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j]
      }
      arr[j + gap] = temp
    }
  }
  return arr
}
```