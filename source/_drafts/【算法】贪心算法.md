## 贪心算法

贪心算法，是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。它**不从整体最优上加以考虑**，所做出的仅是**某种意义上的局部最优解**。

**贪心算法的基本思路**：

* 建立数学模型来描述问题
* 把求解的问题分成若干个子问题
* 对每一个子问题求解，得到子问题的局部最优解
* 把子问题的局部最优解合成原来问题的解

**贪心算法的基本要素**：

* 具有最优子结构性质，即一个问题的最优解包含其子问题的最优解

## 相关应用

### 活动安排问题

设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求，使用该资源的起始时间si和一个结束时间fi,且si < fi，如果选择了活动i，则它在[半开时间区间]([https://baike.baidu.com/item/%E5%8D%8A%E5%BC%80%E5%8D%8A%E9%97%AD%E5%8C%BA%E9%97%B4](https://baike.baidu.com/item/半开半闭区间))[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si >= fj或sj >= fi时，活动i与活动j相容。

```js
function greedySelector (s, f, a = []) {
  let j = 0
  let count = 1
  a[0] = true
  for (let i = 1; i < s.length; i ++) {
    if (s[i] >= f[j]) {
      a[i] = true
      j = i
      count ++
    } else {
      a[i] = false
    }
  }
  return count
}


const res = greedySelector([1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12], [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) // 4

// a = [ true, false, false, true, false, false, false, true, false, false, true ]
```

由于输入的活动为其完成时间的非减序排列，所以`greedySelector`每次总是选择**具有最早完成时间**的相容活动加入集合a中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是**使剩余的可安排时间段极大化**，以便安排尽可能多的相容活动。

对于活动安排问题，贪心算法总能求得整体的**最优解**。

### 背包问题

给定n种物品和一个背包。物品i的重量是Wi，其价值为Vi，背包的容量为C。应如何选择装入背包的物品， 使得装入背包中物品的总价值最大?

**0-1 背包问题**：在选择装入背包的物品时，**对每种物品i只有两种选择，即装入背包和不装入背包**。不能将物品i装入背包多次，也不能只装入部分的物品i。

**部分背包问题**：与0-1背包问题类似，所不同的是在选择物品i装入背包时，**可以选择物品i的一部分**，而不一定要全部装入背包。

这两类问题都具有**最优子结构**性质，极为相似，但部分背包问题可以用贪心算法求解，而0-1背包问题却不能。

```
objects[] = [
	{weight: 35, value: 10},
	{weight: 30, value: 40},
	{weight: 60, value: 30},
	{weight: 50, value: 50},
	{weight: 40, value: 35},
	{weight: 10, value: 40},
	{weight: 25, value: 30}
]
c = 150
```

部分背包问题求解：

```js
function knapsack (c, objects) {
  let totalValue = 0
  let i = 0
  objects.sort((a, b) => {
    // 将各物品依其单位重量的价值从大到小排序
    return (a.value / a.weight) < (b.value / b.weight)
  })
  for (; i < objects.length; i ++) {
    const obj = objects[i]
    if (obj.weight > c) break
    // 当物品重量小于背包容量时，物品放入一件
    totalValue += obj.value
    c -= obj.weight
  }
  if (i < objects.length) { // 当无法放入一整个物品时，选取物品一部分放入
    const obj = objects[i]
    totalValue += c / obj.weight * obj.value
  }
  return totalValue
}
```

对于0-1背包问题，贪心算法之所以不能得到最优解是因为它无法保证最终能将背包装满，部分背包空间的闲置使每单位重量的背包空间所具有价值降低了。事实上，在考虑0-1背包问题的物品选择时，应比较选择该物品和不选择该物品所导致的最终结果，然后再作出最好的选择。由此就导出许多互相重叠的子问题，而这个问题则需要用**动态规划算法**来解决。

### 最优装载

有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为Wi。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。

```js
function loading (c, w) {
  let res = []
  w.sort((a, b) => b - a)
  for (let i = 0; i < w.length && w[i] <= c; i ++) {
    c -= w[i]
    res.push(w[i])
  }
  return res
}
```

### 哈夫曼编码

哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%～90%之间。哈夫曼编码算法用字符在文件中出现的频率表来建立一个用0，1串表示 各字符的最优表示方式。 

给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。

**前缀码**：对每一个字符规定一个0，1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀。这种编码成为前缀码。

### 单源最短路径（Dijkstra）

给定带权有向图G =(V,E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称为**源**。现在要计算从源到所有其他各顶点的最短路长度。这里路的长度是指路上各边权之和。这个问题通常称为**单源最短路径问题**。

Dijkstra算法的基本思想是，设置顶点集合S并不断地作**贪心选择**来扩充这个集合。一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。

初始时，S中仅含有源。设u是G的某个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度。Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u，将u添加到S中，同时对数组dist作必要的修改。一旦S包含了所有V中的顶点，dist就记录了从源到所有其他顶点之间的最短路径长度。

```js
// 输入的路径矩阵，Infinity表示不通
matrix = [
	[Infinity, 10, Infinity, 30, 100],
	[Infinity, Infinity, 50, Infinity, Infinity],
	[Infinity, Infinity, Infinity, Infinity, 10],
	[Infinity, Infinity, 20, Infinity, 60],
	[Infinity, Infinity, Infinity, Infinity, Infinity]
]
```

Dijkstra算法的迭代过程：

| 迭代 | S               | u    | dist[2] | dist[3] | dist[4] | dist[5] |
| ---- | --------------- | ---- | ------- | ------- | ------- | ------- |
| 初始 | {1}             | -    | 10      | maxint  | 30      | 100     |
| 1    | {1, 2}          | 2    | 10      | 60      | 30      | 100     |
| 2    | {1, 2, 4}       | 4    | 10      | 50      | 30      | 90      |
| 3    | {1, 2, 4, 3}    | 3    | 10      | 50      | 30      | 60      |
| 4    | {1, 2, 4, 3, 5} | 5    | 10      | 50      | 30      | 60      |

```js
function dijkstra (matrix, start) {
  const rows = matrix.length
  const cols = matrix[0].length

  let dist = new Array(rows).fill(Infinity)
  let visited = new Array(rows).fill(false)
  
  dist[start] = 0

  while (visited.some(item => !item)) {
    // 更新节点访问
    visited[start] = true
    // 达到不了的顶点不能作为中转跳点
    if (dist[start] < Infinity) {
      for (let i = 0; i < cols; i ++) {
        // 更新dist[i]
        if (matrix[start][i] + dist[start] < dist[i]) {
          dist[i] = matrix[start][i] + dist[start]
        }
      }
    }
    // 找到当前最短路径顶点作为中转
    let minIndex = -1
    let min = Infinity
    for (let k = 0; k < rows; k ++) {
      if (!visited[k] && dist[k] < min) {
        min = dist[k]
        minIndex = k
      }
    }
    start = minIndex
  }
  return dist
}
```

对于具有n个顶点和e条边的带权有向图，如果用带权邻接矩阵表示这个图，那么Dijkstra算法的主循环体需要O(n)时间。这个循环需要执行n-1次，所以完成循环需要O(n²)时间。算法的其余部分所需要时间不超过O(n²)。

### 最小生成树

### 多机调度问题

