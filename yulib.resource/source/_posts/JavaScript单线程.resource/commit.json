{"compress":true,"commitItems":[["39a6ba2b-def8-4554-a73d-3b23c9f16289",1558698982354,"---\ntitle: JS定时器与单线程\ndate: 2017-09-25 21:28:25\ntags: [JavaScript]\n---\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)",[[1558698981253,["70431@DESKTOP-QB0HG1K",[[1,169,"\n"]],[167,167],[168,168]]],[1558698981530,["70431@DESKTOP-QB0HG1K",[[1,170,"\n"]],[168,168],[169,169]]],[1558698981845,["70431@DESKTOP-QB0HG1K",[[1,169,"<!-- more -->"]],[169,169],[182,182]]]],null,"70431@DESKTOP-QB0HG1K"],["0b481f16-93ec-45f7-a942-972d63121ece",1558699882377,"---\ntitle: JS定时器与单线程\ndate: 2017-09-25 21:28:25\ntags: [JavaScript]\n---\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n<!-- more -->\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)",[[1558699878065,["70431@DESKTOP-QB0HG1K",[[1,184,"\n"]],[182,182],[183,183]]],[1558699878380,["70431@DESKTOP-QB0HG1K",[[1,185,"\n"]],[183,183],[184,184]]],[1558699878697,["70431@DESKTOP-QB0HG1K",[[1,184,"## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n<!-- more -->"]],[184,184],[296,296]]],[1558699880203,["70431@DESKTOP-QB0HG1K",[[-1,283,"<!-- more -->"]],[283,296],[283,283]]],[1558699880541,["70431@DESKTOP-QB0HG1K",[[-1,284,"\n"]],[283,283],[282,282]]],[1558699881709,["70431@DESKTOP-QB0HG1K",[[-1,283,"\n"]],[282,282],[281,281]]]],null,"70431@DESKTOP-QB0HG1K"],["26294c49-43b9-4f84-94ef-b0a10cce5917",1558700146619,"---\ntitle: JS定时器与单线程\ndate: 2017-09-25 21:28:25\ntags: [JavaScript]\n---\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n<!-- more -->\n\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)",[[1558700146020,["70431@DESKTOP-QB0HG1K",[[1,47,"categories: JS相关\n"],[-1,53,"["],[1,54,"\n  - "],[-1,64,"]"]],[47,65],[85,85]]]],null,"70431@DESKTOP-QB0HG1K"]]}