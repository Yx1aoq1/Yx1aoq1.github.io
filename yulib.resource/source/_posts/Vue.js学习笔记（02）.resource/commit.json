{"compress":true,"commitItems":[["6103f78c-c4af-4d34-a2cd-1e4bd0dce0b8",1558698933711,"---\ntitle: Vue.js学习笔记（02）\ndate: 2018-07-25 20:13:45\ntags: [Vue, Vue生命周期]\n---\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n```html\n<template>\n  <div id=\"app\">hello, {{ name }}</div>\n</template>\n```\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    name: 'xiaoming'\n  }\n})\n```\n\n### props\n\n**作用：**用于接受来自父组件的数据，对象允许配置高级选项，如类型检测`type`，自定义校验`require validator`，默认值`default`\n```html\n<blog-post title=\"my Vue\"></blog-post>\n```\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式\n```\n▼ **设置默认和校验**\n```js\nVue.component('bkog-post', {\n  props: {\n    title: {\n      type: String,\n      default: 'title',\n      required: true,\n      validator: function (value) {\n        return value != 'abc'\n      }\n    }\n  }\n})\n```\n\n### propsData\n\n**作用：**创建实例时传递`props`，主要作用是方便测试。基本上，没有用过\n\n### computed\n\n**作用：**用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aDouble () {\n      return this.a * 2\n    }\n  }\n})\n```\n\n### methods\n\n**作用：**用来定义实例的一些处理方法，如绑定的事件等。**注意，在`methods`不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus () {\n      this.a ++\n    }\n  }\n})\n```\n\n### watch\n\n**作用：**用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。**同样，不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1, b: 2， c: 3 },\n  watch: {\n    a (curVal, oldVal) {\n      console.log(`new: %s, old: %s`, curVal, oldVal)\n    },\n    b: 'someMethod', // 这里的someMehod是对应的处理函数的名字\n    c: {\n      handler: function (curVal, oldVal) { /*...*/ },\n      deep: true, //深度 watcher，为了发现对象内部值的变化\n      immediate: true // 立即以表达式的当前值触发回调\n    }\n  }\n})\n```\n\n## Vue的生命周期\n\n每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：\n![](https://cn.vuejs.org/images/lifecycle.png)\n\n## 生命周期钩子函数\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeCreate**</span> 实例创建前，此时无法访问到`el`属性和`data`属性\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **created**</span> 实例创建完成，属性已经绑定，但是DOM还未生成，`el`属性还无法访问\n\n▼ **关于属性**\n不仅仅是`data`属性，还有`props`和`method`都在`created`的时候绑定完成\n\n---\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeMount**</span> 模板编译/挂在之前，**只有绑定了`el`属性，才会执行到这里，否则到`created`就已经停止生命周期**\n\n▼ **关于模板编译的顺序**\n* 当实例对象中有`template`参数的时候，则将其作为模板编译成`render`函数\n* 如果没有`template`参数时，则将外部HTML作为模板编译\n* 在Vue对象中还有一个`render`函数，它是以`createElement`作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于`template`与`outer HTML`\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **mounted**</span> 模板编译/挂在之后，**此时data数据绑定在页面上是以虚拟DOM的形式存在的**\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeUpdate && updated**</span> data数据更新之前 && 更新之后，组件重新渲染\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeDestroy && destroyed**</span> 实例销毁之前 && 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁",[[1558698931394,["70431@DESKTOP-QB0HG1K",[[1,232,"\n"]],[231,231],[232,232]]],[1558698931939,["70431@DESKTOP-QB0HG1K",[[1,233,"\n"]],[232,232],[233,233]]],[1558698932323,["70431@DESKTOP-QB0HG1K",[[1,233,"<!-- more -->"]],[233,233],[246,246]]],[1558698932750,["70431@DESKTOP-QB0HG1K",[[1,247,"\n"]],[246,246],[247,247]]]],null,"70431@DESKTOP-QB0HG1K"],["a3ff4023-ab2f-42e5-9d09-2027132935cb",1558699816527,"---\ntitle: Vue.js学习笔记（02）\ndate: 2018-07-25 20:13:45\ntags: [Vue, Vue生命周期]\n---\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n<!-- more -->\n\n```html\n<template>\n  <div id=\"app\">hello, {{ name }}</div>\n</template>\n```\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    name: 'xiaoming'\n  }\n})\n```\n\n### props\n\n**作用：**用于接受来自父组件的数据，对象允许配置高级选项，如类型检测`type`，自定义校验`require validator`，默认值`default`\n```html\n<blog-post title=\"my Vue\"></blog-post>\n```\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式\n```\n▼ **设置默认和校验**\n```js\nVue.component('bkog-post', {\n  props: {\n    title: {\n      type: String,\n      default: 'title',\n      required: true,\n      validator: function (value) {\n        return value != 'abc'\n      }\n    }\n  }\n})\n```\n\n### propsData\n\n**作用：**创建实例时传递`props`，主要作用是方便测试。基本上，没有用过\n\n### computed\n\n**作用：**用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aDouble () {\n      return this.a * 2\n    }\n  }\n})\n```\n\n### methods\n\n**作用：**用来定义实例的一些处理方法，如绑定的事件等。**注意，在`methods`不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus () {\n      this.a ++\n    }\n  }\n})\n```\n\n### watch\n\n**作用：**用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。**同样，不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1, b: 2， c: 3 },\n  watch: {\n    a (curVal, oldVal) {\n      console.log(`new: %s, old: %s`, curVal, oldVal)\n    },\n    b: 'someMethod', // 这里的someMehod是对应的处理函数的名字\n    c: {\n      handler: function (curVal, oldVal) { /*...*/ },\n      deep: true, //深度 watcher，为了发现对象内部值的变化\n      immediate: true // 立即以表达式的当前值触发回调\n    }\n  }\n})\n```\n\n## Vue的生命周期\n\n每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：\n![](https://cn.vuejs.org/images/lifecycle.png)\n\n## 生命周期钩子函数\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeCreate**</span> 实例创建前，此时无法访问到`el`属性和`data`属性\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **created**</span> 实例创建完成，属性已经绑定，但是DOM还未生成，`el`属性还无法访问\n\n▼ **关于属性**\n不仅仅是`data`属性，还有`props`和`method`都在`created`的时候绑定完成\n\n---\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeMount**</span> 模板编译/挂在之前，**只有绑定了`el`属性，才会执行到这里，否则到`created`就已经停止生命周期**\n\n▼ **关于模板编译的顺序**\n* 当实例对象中有`template`参数的时候，则将其作为模板编译成`render`函数\n* 如果没有`template`参数时，则将外部HTML作为模板编译\n* 在Vue对象中还有一个`render`函数，它是以`createElement`作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于`template`与`outer HTML`\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **mounted**</span> 模板编译/挂在之后，**此时data数据绑定在页面上是以虚拟DOM的形式存在的**\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeUpdate && updated**</span> data数据更新之前 && 更新之后，组件重新渲染\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeDestroy && destroyed**</span> 实例销毁之前 && 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁",[[1558699800547,["70431@DESKTOP-QB0HG1K",[[1,77,"\n"]],[76,76],[77,77]]],[1558699801228,["70431@DESKTOP-QB0HG1K",[[1,77,"## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n<!-- more -->"]],[77,77],[246,246]]],[1558699802217,["70431@DESKTOP-QB0HG1K",[[1,247,"\n"]],[246,246],[247,247]]],[1558699804445,["70431@DESKTOP-QB0HG1K",[[-1,404,"<!-- more -->"]],[404,417],[404,404]]],[1558699804782,["70431@DESKTOP-QB0HG1K",[[-1,405,"\n"]],[404,404],[403,403]]],[1558699811078,["70431@DESKTOP-QB0HG1K",[[-1,77,"## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)"]],[77,134],[77,77]]],[1558699812905,["70431@DESKTOP-QB0HG1K",[[-1,78,"\n"]],[79,79],[78,78]]],[1558699814660,["70431@DESKTOP-QB0HG1K",[[-1,77,"\n"]],[78,78],[77,77]]],[1558699827607,["70431@DESKTOP-QB0HG1K",[[1,77,"\n"]],[77,77],[78,78]]],[1558699828255,["70431@DESKTOP-QB0HG1K",[[1,78,"\n"]],[78,78],[79,79]]],[1558699828662,["70431@DESKTOP-QB0HG1K",[[1,77,"## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)"]],[77,77],[77,134]]]],null,"70431@DESKTOP-QB0HG1K"],["73ba2369-6a6b-4e75-9dd3-718b76dd5f0d",1558700089655,"---\ntitle: Vue.js学习笔记（02）\ndate: 2018-07-25 20:13:45\ntags: [Vue, Vue生命周期]\n---\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n<!-- more -->\n\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n\n```html\n<template>\n  <div id=\"app\">hello, {{ name }}</div>\n</template>\n```\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    name: 'xiaoming'\n  }\n})\n```\n\n### props\n\n**作用：**用于接受来自父组件的数据，对象允许配置高级选项，如类型检测`type`，自定义校验`require validator`，默认值`default`\n```html\n<blog-post title=\"my Vue\"></blog-post>\n```\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式\n```\n▼ **设置默认和校验**\n```js\nVue.component('bkog-post', {\n  props: {\n    title: {\n      type: String,\n      default: 'title',\n      required: true,\n      validator: function (value) {\n        return value != 'abc'\n      }\n    }\n  }\n})\n```\n\n### propsData\n\n**作用：**创建实例时传递`props`，主要作用是方便测试。基本上，没有用过\n\n### computed\n\n**作用：**用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aDouble () {\n      return this.a * 2\n    }\n  }\n})\n```\n\n### methods\n\n**作用：**用来定义实例的一些处理方法，如绑定的事件等。**注意，在`methods`不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus () {\n      this.a ++\n    }\n  }\n})\n```\n\n### watch\n\n**作用：**用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。**同样，不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1, b: 2， c: 3 },\n  watch: {\n    a (curVal, oldVal) {\n      console.log(`new: %s, old: %s`, curVal, oldVal)\n    },\n    b: 'someMethod', // 这里的someMehod是对应的处理函数的名字\n    c: {\n      handler: function (curVal, oldVal) { /*...*/ },\n      deep: true, //深度 watcher，为了发现对象内部值的变化\n      immediate: true // 立即以表达式的当前值触发回调\n    }\n  }\n})\n```\n\n## Vue的生命周期\n\n每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：\n![](https://cn.vuejs.org/images/lifecycle.png)\n\n## 生命周期钩子函数\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeCreate**</span> 实例创建前，此时无法访问到`el`属性和`data`属性\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **created**</span> 实例创建完成，属性已经绑定，但是DOM还未生成，`el`属性还无法访问\n\n▼ **关于属性**\n不仅仅是`data`属性，还有`props`和`method`都在`created`的时候绑定完成\n\n---\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeMount**</span> 模板编译/挂在之前，**只有绑定了`el`属性，才会执行到这里，否则到`created`就已经停止生命周期**\n\n▼ **关于模板编译的顺序**\n* 当实例对象中有`template`参数的时候，则将其作为模板编译成`render`函数\n* 如果没有`template`参数时，则将外部HTML作为模板编译\n* 在Vue对象中还有一个`render`函数，它是以`createElement`作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于`template`与`outer HTML`\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **mounted**</span> 模板编译/挂在之后，**此时data数据绑定在页面上是以虚拟DOM的形式存在的**\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeUpdate && updated**</span> data数据更新之前 && 更新之后，组件重新渲染\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeDestroy && destroyed**</span> 实例销毁之前 && 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁",[[1558700065688,["70431@DESKTOP-QB0HG1K",[[-1,58,"["]],[59,59],[58,58]]],[1558700066097,["70431@DESKTOP-QB0HG1K",[[1,58,"\n"]],[58,58],[59,59]]],[1558700066803,["70431@DESKTOP-QB0HG1K",[[1,59,"- "]],[59,59],[61,61]]],[1558700068214,["70431@DESKTOP-QB0HG1K",[[1,59,"  "]],[59,59],[61,61]]],[1558700071273,["70431@DESKTOP-QB0HG1K",[[-1,66,", "]],[68,68],[66,66]]],[1558700072648,["70431@DESKTOP-QB0HG1K",[[1,66,"\n  - "]],[66,66],[71,71]]],[1558700075099,["70431@DESKTOP-QB0HG1K",[[-1,78,"]"]],[79,79],[78,78]]],[1558700080296,["70431@DESKTOP-QB0HG1K",[[1,52,"\n"]],[51,51],[52,52]]],[1558700082506,["70431@DESKTOP-QB0HG1K",[[1,52,"categories: d"]],[52,52],[65,65]]],[1558700082996,["70431@DESKTOP-QB0HG1K",[[-1,64,"d"]],[65,65],[64,64]]],[1558700086376,["70431@DESKTOP-QB0HG1K",[[1,64,"Vuex"]],[64,64],[68,68]]],[1558700086911,["70431@DESKTOP-QB0HG1K",[[-1,67,"x"]],[68,68],[67,67]]],[1558700089201,["70431@DESKTOP-QB0HG1K",[[1,67,"相关"]],[67,67],[69,69]]]],null,"70431@DESKTOP-QB0HG1K"]]}