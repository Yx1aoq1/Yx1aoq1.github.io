{"compress":true,"commitItems":[["61493b09-268d-4988-aa08-daffbd5e1aac",1558698896816,"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\ntags: [JavaScript]\n---\n这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n",[[1558698895236,["70431@DESKTOP-QB0HG1K",[[1,333,"\n"]],[331,331],[332,332]]],[1558698895827,["70431@DESKTOP-QB0HG1K",[[1,334,"\n"]],[332,332],[333,333]]],[1558698896099,["70431@DESKTOP-QB0HG1K",[[1,333,"<!-- more -->"]],[333,333],[346,346]]]],null,"70431@DESKTOP-QB0HG1K"],["5e2ff921-3c28-458b-a57b-3a3b48013889",1558699299565,"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\ntags: [JavaScript]\n---\n这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n<!-- more -->\n\n### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n",[[1558699280687,["70431@DESKTOP-QB0HG1K",[[-1,64,"["]],[65,65],[64,64]]],[1558699281006,["70431@DESKTOP-QB0HG1K",[[1,64,"\n"]],[64,64],[65,65]]],[1558699282489,["70431@DESKTOP-QB0HG1K",[[1,65,"  - "]],[65,65],[69,69]]],[1558699284043,["70431@DESKTOP-QB0HG1K",[[-1,79,"]"]],[80,80],[79,79]]],[1558699284380,["70431@DESKTOP-QB0HG1K",[[1,80,"  \n"]],[79,79],[82,82]]],[1558699287945,["70431@DESKTOP-QB0HG1K",[[1,82,"- 异步"]],[82,82],[86,86]]],[1558699289938,["70431@DESKTOP-QB0HG1K",[[1,58,"\n"]],[57,57],[58,58]]],[1558699292481,["70431@DESKTOP-QB0HG1K",[[1,58,"categories： "]],[58,58],[70,70]]],[1558699293335,["70431@DESKTOP-QB0HG1K",[[-1,68,"： "]],[70,70],[68,68]]],[1558699295432,["70431@DESKTOP-QB0HG1K",[[1,68,": JS "]],[68,68],[73,73]]],[1558699295878,["70431@DESKTOP-QB0HG1K",[[-1,72," "]],[73,73],[72,72]]],[1558699296473,["70431@DESKTOP-QB0HG1K",[[1,72,"xiang"]],[72,72],[77,77]]],[1558699297317,["70431@DESKTOP-QB0HG1K",[[-1,72,"xiang"]],[77,77],[72,72]]],[1558699298896,["70431@DESKTOP-QB0HG1K",[[1,72,"相关"]],[72,72],[74,74]]]],null,"70431@DESKTOP-QB0HG1K"],["4b6b36b8-f477-4f28-a8ae-2001d86d2a76",1558699730321,"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\ncategories: JS相关\ntags: \n  - JavaScript\n  - 异步\n---\n这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n<!-- more -->\n\n### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n",[[1558699722997,["70431@DESKTOP-QB0HG1K",[[1,373,"这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n<!-- more -->"]],[108,108],[373,373]]],[1558699725419,["70431@DESKTOP-QB0HG1K",[[1,373,"\n"]],[373,373],[374,374]]],[1558699727112,["70431@DESKTOP-QB0HG1K",[[1,374,"\n"]],[374,374],[375,375]]],[1558699728440,["70431@DESKTOP-QB0HG1K",[[-1,627,"<!-- more -->"]],[627,640],[627,627]]],[1558699728755,["70431@DESKTOP-QB0HG1K",[[-1,628,"\n"]],[627,627],[626,626]]],[1558699729185,["70431@DESKTOP-QB0HG1K",[[-1,627,"\n"]],[626,626],[625,625]]]],null,"70431@DESKTOP-QB0HG1K"]]}