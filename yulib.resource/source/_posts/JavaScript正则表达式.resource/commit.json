{"compress":true,"commitItems":[["27a746b4-3678-4d65-9847-e15969a35fef",1558698977980,"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\ntags: [JavaScript]\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串",[[1558698976688,["70431@DESKTOP-QB0HG1K",[[1,373,"\n"]],[371,371],[372,372]]],[1558698977029,["70431@DESKTOP-QB0HG1K",[[1,374,"\n"]],[372,372],[373,373]]],[1558698977323,["70431@DESKTOP-QB0HG1K",[[1,373,"<!-- more -->"]],[373,373],[386,386]]]],null,"70431@DESKTOP-QB0HG1K"],["db6535da-cc0e-4580-b500-779140025f3a",1558699870047,"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\ntags: [JavaScript]\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n<!-- more -->\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串",[[1558699859614,["70431@DESKTOP-QB0HG1K",[[1,388,"\n"]],[386,386],[387,387]]],[1558699859998,["70431@DESKTOP-QB0HG1K",[[1,387,">正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n<!-- more -->"]],[387,387],[697,697]]],[1558699861685,["70431@DESKTOP-QB0HG1K",[[1,387,"\n"]],[386,386],[387,387]]],[1558699864582,["70431@DESKTOP-QB0HG1K",[[-1,685,"<!-- more -->\n"]],[684,698],[684,684]]],[1558699864745,["70431@DESKTOP-QB0HG1K",[[-1,685,"\n"]],[684,684],[683,683]]],[1558699865016,["70431@DESKTOP-QB0HG1K",[[-1,682,"的"]],[683,683],[682,682]]],[1558699866181,["70431@DESKTOP-QB0HG1K",[[1,682,"的"]],[682,682],[683,683]]],[1558699867876,["70431@DESKTOP-QB0HG1K",[[1,685,"\n"]],[683,683],[684,684]]],[1558699869696,["70431@DESKTOP-QB0HG1K",[[-1,685,"\n"]],[684,684],[683,683]]]],null,"70431@DESKTOP-QB0HG1K"],["05b686a2-e52e-4c6b-819b-b996effb7052",1558700139049,"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\ntags: [JavaScript]\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n<!-- more -->\n\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串",[[1558700125319,["70431@DESKTOP-QB0HG1K",[[-1,59,"["]],[60,60],[59,59]]],[1558700125745,["70431@DESKTOP-QB0HG1K",[[1,59,"\n"]],[59,59],[60,60]]],[1558700126900,["70431@DESKTOP-QB0HG1K",[[1,60,"  - "]],[60,60],[64,64]]],[1558700128964,["70431@DESKTOP-QB0HG1K",[[-1,74,"]"]],[75,75],[74,74]]],[1558700134700,["70431@DESKTOP-QB0HG1K",[[1,53,"\n"]],[52,52],[53,53]]],[1558700135175,["70431@DESKTOP-QB0HG1K",[[1,53,"categories: Vue相关"]],[53,53],[70,70]]],[1558700137428,["70431@DESKTOP-QB0HG1K",[[-1,65,"Vue"],[1,68,"J"]],[65,68],[66,66]]],[1558700137540,["70431@DESKTOP-QB0HG1K",[[1,66,"S"]],[66,66],[67,67]]]],null,"70431@DESKTOP-QB0HG1K"]]}