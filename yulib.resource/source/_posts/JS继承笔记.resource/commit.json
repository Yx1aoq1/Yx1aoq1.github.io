{"compress":true,"commitItems":[["cc6c83c9-c0f5-44a5-babf-49464460acc3",1558698994785,"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\ntags: [JavaScript]\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n",[[1558698993675,["70431@DESKTOP-QB0HG1K",[[1,375,"\n"]],[373,373],[374,374]]],[1558698993994,["70431@DESKTOP-QB0HG1K",[[1,376,"\n"]],[374,374],[375,375]]],[1558698994267,["70431@DESKTOP-QB0HG1K",[[1,375,"<!-- more -->"]],[375,375],[388,388]]]],null,"70431@DESKTOP-QB0HG1K"],["4704bda6-8179-4dae-8285-8876c31088fd",1558699902998,"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\ntags: [JavaScript]\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n<!-- more -->\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n",[[1558699897528,["70431@DESKTOP-QB0HG1K",[[1,390,"\n"]],[388,388],[389,389]]],[1558699897730,["70431@DESKTOP-QB0HG1K",[[1,391,"\n"]],[389,389],[390,390]]],[1558699898002,["70431@DESKTOP-QB0HG1K",[[1,390,"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n<!-- more -->"]],[390,390],[711,711]]],[1558699901060,["70431@DESKTOP-QB0HG1K",[[-1,698,"<!-- more -->"]],[711,711],[698,698]]],[1558699901489,["70431@DESKTOP-QB0HG1K",[[-1,699,"\n"]],[698,698],[697,697]]],[1558699901984,["70431@DESKTOP-QB0HG1K",[[-1,698,"\n"]],[697,697],[696,696]]]],null,"70431@DESKTOP-QB0HG1K"],["6206ae7d-c172-45c3-9eb3-eba468728ce7",1558700156246,"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\ntags: [JavaScript]\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n<!-- more -->\n\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n",[[1558700155290,["70431@DESKTOP-QB0HG1K",[[1,44,"categories: JS相关\n"],[-1,50,"["],[1,51,"\n  - "],[-1,61,"]"]],[44,62],[82,82]]]],null,"70431@DESKTOP-QB0HG1K"]]}