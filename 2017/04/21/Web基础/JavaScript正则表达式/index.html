<!DOCTYPE html>
<html lang="en">
  <head>
  <!-- so meta -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <!-- title -->
  <title>JavaScript正则表达式</title>
  <!-- styles -->
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>
  <body style="background-color: #2d2d2d">
    
      <div class="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <div class="toc-wrap">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式的定义"><span class="toc-number">1.</span> <span class="toc-text">正则表达式的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接量字符"><span class="toc-number">2.</span> <span class="toc-text">直接量字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符类"><span class="toc-number">3.</span> <span class="toc-text">字符类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重复"><span class="toc-number">4.</span> <span class="toc-text">重复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非贪婪的重复"><span class="toc-number">5.</span> <span class="toc-text">非贪婪的重复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择、分组和引用"><span class="toc-number">6.</span> <span class="toc-text">选择、分组和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指定匹配边界"><span class="toc-number">7.</span> <span class="toc-text">指定匹配边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修饰符"><span class="toc-number">8.</span> <span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用于模式匹配的String方法"><span class="toc-number">9.</span> <span class="toc-text">用于模式匹配的String方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegExp方法"><span class="toc-number">10.</span> <span class="toc-text">RegExp方法</span></a></li></ol>
  </div>
</div>

    
    <div class="layout-content">
      <header class="layout-header">
  <nav class="header-top">
    <ul class="menu">
       
        <li class="menu-item ">
          <a href="/">Home</a>
        </li>
       
        <li class="menu-item ">
          <a href="/archives">Writing</a>
        </li>
       
        <li class="menu-item ">
          <a href="/categories">Category</a>
        </li>
       
        <li class="menu-item ">
          <a href="/about">About</a>
        </li>
      
    </ul>
  </nav>
  
  
    <div class="content">
      <div class="post-header">
        <div class="pic">
          <img src="/images/avatar.jpg" />
        </div>
        <div class="info">
          <div class="title">JavaScript正则表达式</div>
          <div class="post-meta">
            <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
              <span itemprop="name">Yx1aoq1</span>
            </div>
            
  <div class="meta">
    
      <time datetime="2017-04-21T07:22:18.000Z" itemprop="datePublished">2017-04-21</time>
      
    
  </div>

            
	<div class="article-category">
		<i class="fas fa-archive"></i>
		<a class="category-link" href="/categories/Web%E5%9F%BA%E7%A1%80/">Web基础</a>
	</div>


            
	<div class="article-tag">
		<i class="fas fa-tag"></i>
		<a class="tag-link" href="/tags/JavaScript/" rel="tag">JavaScript</a>
	</div>


          </div>
        </div>
      </div>
    </div>
  
</header>
      <main class="layout-main">
        <article class="content">
  <blockquote>
<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>
</blockquote>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><ul>
<li>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>;</span><br></pre></td></tr></table></figure></li>
<li>另一种是使用<code>RegExp()</code>构造函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'s'</span>);</span><br></pre></td></tr></table></figure>
上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</li>
</ul>
<h2 id="直接量字符"><a href="#直接量字符" class="headerlink" title="直接量字符"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\</code>反斜杠作为前缀转义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\0	匹配null字符(\u0000)</span><br><span class="line">[\b]	匹配退格符(\u0008)，区别\b</span><br><span class="line">\t  	匹配制表符tab(\u0009)</span><br><span class="line">\n  	匹配换行符(\u000A)</span><br><span class="line">\v      匹配垂直制表符(\u000B)</span><br><span class="line">\f	匹配换页符(\u000C)</span><br><span class="line">\r	匹配回车键(\u000D)</span><br><span class="line">\xnn	匹配一个以两位16进制数(\x00-\xFF)表示的字符</span><br><span class="line">\uxxxx	匹配一个以四位16进制数(\u0000-\uFFFF)表示的Unicode字符</span><br><span class="line">\cX	表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</span><br></pre></td></tr></table></figure>

<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[...]   匹配方括号内的任意字符</span><br><span class="line">[^...] 	匹配除方括号内的以外的任意字符</span><br><span class="line">. 	除换行符和其他Unicode行终止符之外的任意字符</span><br><span class="line">-	匹配范围，如[a-z]表示所有的小写字母</span><br><span class="line">\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</span><br><span class="line">\W 	任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</span><br><span class="line">\s 	任何Unicode空白符</span><br><span class="line">\S	任何非Unicode空白符的字符</span><br><span class="line">\d	任何非ASCII数字，等价于[0-9]</span><br><span class="line">\D	除了ASCII数字之外的任何字符，等价于[^0-9]</span><br></pre></td></tr></table></figure>

<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;n,m&#125; 	匹配前一项至少n次，至多m次</span><br><span class="line">&#123;n,&#125; 	匹配前一项至少n次，次数可能比n大</span><br><span class="line">&#123;n&#125; 	匹配前一项n次</span><br><span class="line">?	匹配前一项0次或者1次，等价于&#123;0,1&#125;</span><br><span class="line">+	匹配前一项1次或者更多次，等价于&#123;1,&#125;</span><br><span class="line">*	匹配前一项0次或者更多次，等价于&#123;0,&#125;</span><br></pre></td></tr></table></figure>
<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>
<h2 id="非贪婪的重复"><a href="#非贪婪的重复" class="headerlink" title="非贪婪的重复"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="regexp">/a+/</span>.exec(<span class="string">'aaa'</span>);	<span class="comment">//["aaa"]</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="regexp">/a+?/</span>.exec(<span class="string">'aaa'</span>);	<span class="comment">//["a"]</span></span><br></pre></td></tr></table></figure>

<h2 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|	分隔供选择的字符，如&#x2F;ab|cd|ef&#x2F;表示可以匹配ab或cd或ef</span><br><span class="line">	并且，如果匹配了ab就不会再往后匹配</span><br><span class="line">(...) 	把单独的项组合成子表达式</span><br><span class="line">\n	引用第n个带括号的子表达式</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test() 方法用于检测一个字符串是否匹配某个模式</span></span><br><span class="line"><span class="comment">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="regexp">/(.)b(.)\1b\2/</span>.test(<span class="string">'abcabc'</span>)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码中，<code>\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>
<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\2</code>所表示的是<code>(ss)</code></li>
<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res1 = <span class="regexp">/(a|b)c\1/</span>.test(<span class="string">'aca'</span>);	<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> res2 = <span class="regexp">/(a|b)c\1/</span>.test(<span class="string">'acb'</span>);	<span class="comment">//false</span></span><br><span class="line"><span class="comment">//'(a|b)'匹配了a之后，'\1'也代表a</span></span><br></pre></td></tr></table></figure>

<h2 id="指定匹配边界"><a href="#指定匹配边界" class="headerlink" title="指定匹配边界"></a>指定匹配边界</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^	匹配字符串的开头，在多行检索中，匹配一行的开头</span><br><span class="line">$ 	匹配字符串的结尾，在多行检索中，匹配一行的结尾</span><br><span class="line">\b 	匹配一个单词的边界</span><br><span class="line">\B 	匹配非单词边界的位置</span><br><span class="line">(?&#x3D;p)	零宽正向先行断言，要求接下来的字符都与p匹配</span><br><span class="line">(?!p)	零宽负向先行断言，要求接下来的字符不与p匹配</span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i 	执行不区分大小写的匹配</span><br><span class="line">g 	执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</span><br><span class="line">m 	多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</span><br><span class="line">	整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="regexp">/test/ig</span></span><br></pre></td></tr></table></figure>

<h2 id="用于模式匹配的String方法"><a href="#用于模式匹配的String方法" class="headerlink" title="用于模式匹配的String方法"></a>用于模式匹配的String方法</h2><ul>
<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"javascript"</span>.search(<span class="regexp">/script/i</span>);	<span class="comment">//4</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1 plus 2 equals 3"</span>.match(<span class="regexp">/\d+/g</span>); <span class="comment">//["1","2","3"]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第二个参数：</span><br><span class="line">$&#96;	指代匹配结果前面的文本</span><br><span class="line">$&#39;	指代匹配结果后面的文本</span><br><span class="line">$n 	指代匹配成功后的第n组内容，n从1开始</span><br><span class="line"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.162ex" height="3.343ex" style="vertical-align: -1.171ex;" viewBox="0 -934.9 6097.7 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">$ 	指代美元符号</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMAIN-24" d="M162 187Q162 164 146 149T109 133H103V130Q108 115 115 105Q122 92 131 82T150 64T170 52T190 44T206 40T220 37L227 36V313Q190 320 162 335Q116 358 86 404T55 508Q55 567 85 614T165 685Q186 696 225 704H227V750H273V704L286 703Q369 690 413 631Q441 588 444 531Q444 514 443 509Q439 490 425 479T391 468Q368 468 353 483T337 522Q337 546 353 560T390 575L394 576V578Q386 599 372 614T342 637T314 649T288 656L273 658V408L288 405Q329 394 355 376Q396 348 420 300T444 199Q444 130 408 76T313 1Q286 -9 276 -9H273V-56H227V-10H221Q202 -6 193 -4T155 11T108 41T74 94T55 176V182Q55 227 95 238Q103 240 108 240Q129 240 145 226T162 187ZM225 657Q219 657 204 651T169 632T135 594T121 538Q121 512 131 491T156 457T187 435T213 423T227 420V539Q227 657 225 657ZM378 169Q378 230 339 265T274 301Q273 301 273 169V37Q324 50 351 87T378 169Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMAIN-24" x="0" y="0"></use>
<g transform="translate(500,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">指</text>
</g>
<g transform="translate(1433,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">代</text>
</g>
<g transform="translate(2366,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">美</text>
</g>
<g transform="translate(3299,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">元</text>
</g>
<g transform="translate(4231,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">符</text>
</g>
<g transform="translate(5164,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">号</text>
</g>
</g>
</svg></span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello world"</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>,<span class="string">'<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 500.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMAIN-32" x="0" y="0"></use>
</g>
</svg>1'</span>); <span class="comment">//"world hello"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员<br>​```javascript<br>“123,456,789”.split(‘,’); //[“123”,”456”,”789”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## RegExp对象</span><br><span class="line">构造函数带有两个参数，第二个参数是可选的</span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">var regexp &#x3D; new RegExp(&#39;\\d&#123;5&#125;&#39;,&#39;g&#39;); &#x2F;&#x2F;全局查找5个数字</span><br></pre></td></tr></table></figure>
<p>包含5个属性：</p>
</li>
<li><p>source：只读字符串，包含正则表达式的文本</p>
</li>
<li><p>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</p>
</li>
<li><p>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</p>
</li>
<li><p>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</p>
</li>
<li><p>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</p>
</li>
</ul>
<h2 id="RegExp方法"><a href="#RegExp方法" class="headerlink" title="RegExp方法"></a>RegExp方法</h2><ul>
<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>
<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>
</ul>

</article>
<div class="prev-or-next">
  <div class="post-foot-next">
    
      <a href="/2017/03/26/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/iconfont%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" target="_self">
        <i class="fas fa-angle-left"></i>
        <span>Previous post</span>
      </a>
    
  </div>
  <div class="post-foot-prev">
    
      <a href="/2017/07/07/Web%E5%9F%BA%E7%A1%80/JS%E7%BB%A7%E6%89%BF%E7%AC%94%E8%AE%B0/" target="_self">
        <span>Next post</span>
        <i class="fas fa-angle-right"></i>
      </a>
    
  </div>
</div>
      </main>
      <footer class="layout-footer">
  <div>
    Copyright &copy;
    
    
    2025
    Yx1aoq1
  </div>
</footer>
    </div>
    <!-- styles -->
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/js/accordion-menu.js"></script>

  </body>
</html>
