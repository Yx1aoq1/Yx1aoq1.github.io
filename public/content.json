{"meta":{"title":"Yx1aoq1's Blog","subtitle":null,"description":null,"author":"Yx1aoq1","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-05-24T11:45:24.000Z","updated":"2019-05-24T11:47:53.551Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-24T11:45:13.000Z","updated":"2019-05-24T11:46:46.298Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TypeScript学习笔记（基础）","slug":"TypeScript学习笔记（基础）","date":"2019-05-26T06:35:02.000Z","updated":"2019-06-04T14:40:02.558Z","comments":true,"path":"2019/05/26/TypeScript学习笔记（基础）/","link":"","permalink":"http://yoursite.com/2019/05/26/TypeScript学习笔记（基础）/","excerpt":"TS 是什么 TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。","text":"TS 是什么 TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。 TS 是什么 TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。 ▼ TS与JS相比，有什么优势 TS 与 JS 对比，最主要是增加了静态类型，这样就能在调试的时候做到类型检查，越界检查，在构建的时候就可以发现问题，可以减少潜在的BUG 提供了类、模块和接口，更有利于构建组件 对比TS，其实ES6也已经对JS做了一些类、模块之类的改进，那么为什么还要学习TS呢？其实由TS的名字就可以感受到，它的重点：Type，JS本身与大部分其他语言的不同之处就在于弱类型，声明一个变量，它就可以是任何类型，这就给代码的管理上造成了隐患。强类型的本意就在于用规则约束自己的代码，有了这些规则，自然而然的就能够避免一些低级的BUG。当然，BUG是永远不可能消失滴。 TS能够更好的帮助管理大型工程，也可以减少代码中一堆isxxx的类型判断。并且TS提供了定义对象类型的接口（Interfaces），对于开发，我们只需要在接口处标明类型，其它的内部过程交由 ts 推理就好，这也减少了许多额外的工作。 TS 中的类型基础类型123456789101112131415161718192021let isDone: boolean = false // 布尔值let num: number = 100 // 数值let str: string = 'Hello' // 字符串（支持模板字符串$&#123;&#125;）function alertName(): void &#123; // 空值，表示没有任何返回值的函数 alert('My name is Tom') // 变量声明为void并没有什么用，因为只能是null 或 undefined&#125;let u: undefined = undefined // undefinedlet n: null = null // null// 与 void 区别在与其他类型可以赋值为 undefined 或 null 而不报错，但是不能赋值为 voidlet anyThing: any = 'hello' // 任意值// 在任意值上访问任何属性都是允许的console.log(anyThing.myName)console.log(anyThing.myName.firstName)// 也允许调用任何方法anyThing.setName('Jerry')anyThing.setName('Jerry').sayHello()anyThing.myName.setFirstName('Cat')// 对它的任何操作，返回的内容的类型都是任意值 联合类型12345// 声明一个变量时，可以指定它为多种类型//因为不确定是哪种类型，只能访问联合类型共有的属性和方法let myFavoriteNumber: string | numbermyFavoriteNumber = 'seven'myFavoriteNumber = 7 数组与函数12345678// 定义后数组内只能存在这种类型的值let fibonacci: number[] = [1, 1, 2, 3, 5]// 限定输入类型和输出类型，及参数的个数function sum (x: number, y: number): number &#123; return x + y&#125;sum(1, 2) TS 中的接口12345678910111213141516171819202122232425262728293031// 用于定义对象的类型// 定义好后，指定的变量多一个类型或少一个类型都不可以interface Person = &#123; name: string, age: number&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;// 用可选类型和任意属性来灵活拓展，只读属性来设定不可修改interface Person &#123; readonly id: number name: string age?: number [propName: string]: any&#125;let tom: Person = &#123; id: 89757, // 创建时赋值后便不可修改 name: 'Tom', gender: 'male'&#125;// 定义数组接口和函数接口interface Eg &#123; [index: number]: number, // 数组类型 (x: number, y: number): number// 函数类型&#125; TS 中的类ES6 的类12345678910111213141516171819202122232425262728293031class Human&#123; constructor (name) &#123; this.name = name &#125; sayHi () &#123; return `My name is $&#123;this.name&#125;` &#125; get name () &#123; // 存取器 return 'Jack' &#125; set name (value) &#123; console.log('setter:' + value) &#125; static isHuman (a) &#123; // 静态方法 return a instanceof Human &#125;&#125;let a = new Human('Tom')a.sayHi() // My name is TomeHuman.isHuman(a) // true// 继承class Chinese extend Human &#123; constructor (name) &#123; super(name) // 调用父类的 constructor(name) &#125; sayHi() &#123; return 'China,' + super.sayHi() // 调用父类的 sayHi() &#125;&#125; ES7 的类1234567891011121314151617// 支持在构造函数外定义变量class Human&#123; name: 'Tom' constructor () &#123; // ... &#125;&#125;// 支持定义静态变量class Human&#123; static name = 'Tom' constructor () &#123; // ... &#125;&#125;Human.name // Tom TS 的类 支持ES6、ES7的类定义 增加三种修饰符public、private、protected，对，和当年学 C++ 一模一样 支持抽象类（过于抽象，还不知道如何使用） 支持定义类型（和接口类似） 123456789class Human&#123; public name: string public constructor (name: string) &#123; this.name = name &#125; private sayHi (): string &#123; return `My name is $&#123;this.name&#125;` &#125;&#125;","categories":[{"name":"TS相关","slug":"TS相关","permalink":"http://yoursite.com/categories/TS相关/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"vuex的学习整理","slug":"vuex的学习整理","date":"2019-05-09T12:22:24.000Z","updated":"2019-05-24T12:07:05.019Z","comments":true,"path":"2019/05/09/vuex的学习整理/","link":"","permalink":"http://yoursite.com/2019/05/09/vuex的学习整理/","excerpt":"Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。","text":"Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 上面是copy自官方的解释，在我的理解看来，vuex相当于复杂版的evenBus，管理项目中一些各个地方都需要使用到的数据，各个地方可能触发的事件。 示例先写一个十分简单的vuex123456789101112131415161718192021222324252627282930const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: 'todo one', done: true &#125;, &#123; id: 2, text: 'todo two', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;, mutations: &#123; setTodoDone (state, index) &#123; state.todos[index].done = true &#125; &#125;, actions: &#123; setTodoDoneAfterTime (state, time) &#123; setTimeout(() =&gt; &#123; state.todos.map(todo =&gt; &#123; todo.done = true &#125;) &#125;, time) &#125; &#125;&#125;)store.commit('setTodoDone', 2) // 触发 mutationsstore.dispatch('setTodoDoneAfterTime', 1000) // 触发 actions 核心概念State存储状态数据，每次变化时可以触发vue的computed，并触发更新相关联的DOM1234567export default &#123; computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; 但是如果每次取值都要通过声明一个计算属性，那未免也太过麻烦了，所以vuex提供了一个简便的方法mapState123456789101112131415// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) Getter类似于vue中的computed，获取从store中派生出的一些状态，例如对列表进行过滤并计数，并且与computed一样可以缓存状态的变化同样，在获取getters时也有一个简便的方法mapGetters123456789101112import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式：1234mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount'&#125;) Mutation更改store中状态的唯一方法就是提交mutation，mutation其实就类似与事件的触发注意点： 对象添加新属性时和vue中一样，必须使用set方法才能触发更新，或者使用新对象替换老对象 1state.obj = &#123;...state.obj, newProp: 123&#125; 使用常量替代Mutation事件类型 12// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION' 12345678910111213// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) Mutation 必须是同步函数 辅助函数 mapMutations 12345678910111213141516import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; ActionsAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 mapActions 12345678910111213141516import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; Module对复杂的store对象进行模块的划分12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 注意点： 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。 12345678910111213// 触发绑定命名空间的state mapGetters等函数时computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions('some/nested/module', [ 'foo', // -&gt; this.foo() 'bar' // -&gt; this.bar() ])&#125;","categories":[{"name":"Vue相关","slug":"Vue相关","permalink":"http://yoursite.com/categories/Vue相关/"}],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}]},{"title":"有关一些数组和对象方法的比较和总结","slug":"有关一些数组和对象方法的比较和总结","date":"2018-11-04T14:57:01.000Z","updated":"2019-05-24T12:08:17.719Z","comments":true,"path":"2018/11/04/有关一些数组和对象方法的比较和总结/","link":"","permalink":"http://yoursite.com/2018/11/04/有关一些数组和对象方法的比较和总结/","excerpt":"最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结 Array元素的添加与删除","text":"最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结 Array元素的添加与删除 最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结 Array元素的添加与删除▶ posh &amp; pop 数组的栈方法，在数组的末端增加和删除一个元素123let a = [1, 2, 3]a.posh(4) // [1, 2, 3, 4]a.pop() // [1, 2, 3] ▶ shift &amp; unshift 数组的队列方法，在数组的第一个位置增加和删除一个元素123let a = [1, 2, 3]a.shift(0) // [0, 1, 2, 3]a.unshift() // [1, 2, 3] ▶ splice 用于删除原数组的一部分元素，可以在被删除的位置加入新元素，会改变原数组123let a = [1, 2, 3, 4]a.splice(2, 3, 5) // [3, 4]a // [1, 2, 5] 数组的分割与合并▶ slice 用于提取数组的某个部分，参数是开始位置与结束位置123456let a = [1, 2, 3, 4]a.slice() // 参数为空时相当于复制数组 [1, 2, 3, 4]a.slice(1) // 只有一个参数时默认提取到最后一个 [2, 3, 4]a.slice(1, 3) // 结束位置的那个元素并不包括 [2, 3]a.slice(-2, -1) // 参数为负数时会取倒数第n个元素 [3]// 正数从0开始而倒数从1开始 ▶ concat 用于多个数组的合并，返回新数组，不会改变原数组；同时也可以用于对象的合并。12345let a = [1, [2]]let b = [3, [4]]a.concat(b) // [1, [2], 3, [4]]// 在ES6中等同于[..a,..b] 排序▶ sort 对元素进行排序，会改变原数组12let a = [1, 3, 2, 4]a.sort() // [1, 2, 3, 4] ▶ reverse 颠倒元素的顺序，会改变原数组12let a = [3, 2, 1, 4]a.reverse() // [4, 1, 2, 3] 遍历▶ forEach 遍历，参数分别是当前元素、当前位置和整个数组123456[1, 2, 3].forEach((item, index, array) =&gt; &#123; console.log('[' + index + '] = ' + item)&#125;)// [0] = 1// [1] = 2// [2] = 3 ▶ map 遍历，参数分别是当前元素、当前位置和整个数组1234[1, 2, 3].map((item, index, array) =&gt; &#123; return item * index&#125;)// [0, 2, 6] ▶ filter 过滤数据，遍历数据查找符合输入函数条件的元素，返回一个新的数组1234[1, 2, 3, 4, 5].filter((item) =&gt; &#123; return item &gt; 3&#125;)// [4, 5] ▶ some &amp; every 断言，判断数组的每个元素是否符合某条件，返回布尔值12345678[1, 2, 3, 4].some((item, index, array) =&gt; &#123; return item &gt;= 3&#125;)// true[1, 2, 3, 4].every((item, index, array) =&gt; &#123; return item &gt;= 3&#125;)// false ▶ reduce &amp; reduceRight 接受函数作为累加器，让每个值最终合成一个值12345[1, 2, 3].reduce((acc, cur, idx, src) =&gt; &#123; return acc + cur&#125;)// 6// reduce(callback, initialValue) 可设置acc第一次计算的默认值，不设置的话是数组第一个元素 查找元素▶ indexOf 查找某元素的索引，不存在返回-11[1, 3, 5].indexOf(5) // 2 ▶ find &amp; findIndex 查找满足条件的元素，返回第一个符合条件的元素，未找到返回undefined，findIndex返回的是索引1234[1, 3, 5].find((item, index, array) =&gt; &#123; return item &gt; 2&#125;)// 3 ▶ includes 判断当前数组是否包含某指定的值，返回布尔值1['a', 'b', 'c'].includes('a') // true 字符串相关▶ join 输入指定分隔符将数组拼成一个字符串1['a', 'b', 'c'].join(',') // a,b,c ▶ toString 将数组转换为字符串，间隔符为逗号1['a', 'b', 'c'].toString() // a,b,c 其他▶ from 从一个类似数组或可迭代对象中创建一个新的数组实例（ES6）12345678910Array.from([1, 2, 3], x =&gt; x + x) // [2, 4, 6]// 合并数组并去重function combine () &#123; let arr = [].concat.apply([], arguments) // new Set为ES6的新数据结构，类似于数组，但它的成员是唯一的 return Array.from(new Set(arr))&#125;combine([1, 2, 2], [2, 3, 3]) // [1, 2, 3] ▶ copyWithin 将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变。接收三个参数【从该位置开始替换|从该位置开始读取数据|到该位置停止读取数据】（ES6）1[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] ▶ fill 用给定的值填充一个数组（ES6）1['a', 'b', 'c'].fill(7) // [7, 7, 7] Objcet▶ Object.assign 合并对象，合并时含有相同属性则后者覆盖前者，会改变目标对象12Object.assign(&#123;a: 1, b: 2&#125;, &#123;b: 3, c: 4&#125;)// &#123;a: 1, b: 3, c: 4&#125; ▶ Object.is 用来判断两个值是否是同一个值123456789101112131415Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;); // trueObject.is(window, window); // trueObject.is(&apos;foo&apos;, &apos;bar&apos;); // falseObject.is([], []); // falsevar test = &#123; a: 1 &#125;;Object.is(test, test); // trueObject.is(null, null); // true// 特例Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true ▶ Object.keys 回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in循环遍历该对象时返回的顺序一致12let obj = &#123;a: 1, b: 2&#125;Object.keys(obj) // ['a', 'b'] Lodash由于lodash的方法实在是太多了，只提一下最最最常用的merge，用于两个对象的合并，可以实现深拷贝，但是在合并数组的时候有一个坑12345678910111213141516let a = &#123; name: 'xm', age: 18, tag: ['smart', 'happy']&#125;let b = &#123; form: 'china', tag: ['smart']&#125;lodash.merge(a, b)//&#123;// name: 'xm',// age: 18,// tag: ['smart', 'happy'],// from: 'china'//&#125; 由于是深拷贝，合并时数组会把两个对象的数组合并到一起，区别于Object.assign()，但是有的时候确实必须用深拷贝，又要去后一个数组覆盖目标数组，那么在合并之前就必须先移除掉目标对象中的这个属性1234567lodash.merge(lodash.omit(a, ['tag']), b)//&#123;// name: 'xm',// age: 18,// tag: ['smart'],// from: 'china'//&#125;","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"lodash","slug":"lodash","permalink":"http://yoursite.com/tags/lodash/"}]},{"title":"Vue.js学习笔记（03）","slug":"Vue.js学习笔记（03）","date":"2018-08-19T05:32:38.000Z","updated":"2019-05-24T12:19:30.358Z","comments":true,"path":"2018/08/19/Vue.js学习笔记（03）/","link":"","permalink":"http://yoursite.com/2018/08/19/Vue.js学习笔记（03）/","excerpt":"指令一个.vue文件包含着三个部分，template、script和style，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种： 更新元素内容的指令：v-text、v-html 模板渲染：v-show、v-if、v-else、v-else-if、v-for 事件绑定：v-on 绑定属性或class与style：v-bind 绑定表单控件：v-model 特殊：v-pre、v-cloak、v-once","text":"指令一个.vue文件包含着三个部分，template、script和style，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种： 更新元素内容的指令：v-text、v-html 模板渲染：v-show、v-if、v-else、v-else-if、v-for 事件绑定：v-on 绑定属性或class与style：v-bind 绑定表单控件：v-model 特殊：v-pre、v-cloak、v-once 指令一个.vue文件包含着三个部分，template、script和style，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种： 更新元素内容的指令：v-text、v-html 模板渲染：v-show、v-if、v-else、v-else-if、v-for 事件绑定：v-on 绑定属性或class与style：v-bind 绑定表单控件：v-model 特殊：v-pre、v-cloak、v-once","categories":[{"name":"Vue相关","slug":"Vue相关","permalink":"http://yoursite.com/categories/Vue相关/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vue指令","slug":"Vue指令","permalink":"http://yoursite.com/tags/Vue指令/"},{"name":"Vue事件","slug":"Vue事件","permalink":"http://yoursite.com/tags/Vue事件/"}]},{"title":"Vue.js学习笔记（02）","slug":"Vue.js学习笔记（02）","date":"2018-07-25T12:13:45.000Z","updated":"2019-05-24T12:14:49.643Z","comments":true,"path":"2018/07/25/Vue.js学习笔记（02）/","link":"","permalink":"http://yoursite.com/2018/07/25/Vue.js学习笔记（02）/","excerpt":"Vue实例化输入的选项对象基本介绍当我们new一个Vue实例的时候，包含了如下几个基本的属性： data作用：声明双向绑定的数据，可以是对象或者函数，当定义组件的时候，data只能是函数","text":"Vue实例化输入的选项对象基本介绍当我们new一个Vue实例的时候，包含了如下几个基本的属性： data作用：声明双向绑定的数据，可以是对象或者函数，当定义组件的时候，data只能是函数 Vue实例化输入的选项对象基本介绍当我们new一个Vue实例的时候，包含了如下几个基本的属性： data作用：声明双向绑定的数据，可以是对象或者函数，当定义组件的时候，data只能是函数 123&lt;template&gt; &lt;div id=\"app\"&gt;hello, &#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;/template&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; name: 'xiaoming' &#125;&#125;) props作用：用于接受来自父组件的数据，对象允许配置高级选项，如类型检测type，自定义校验require validator，默认值default1&lt;blog-post title=\"my Vue\"&gt;&lt;/blog-post&gt; 12345Vue.component('blog-post', &#123; props: ['title'], template: '&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'&#125;)// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式 ▼ 设置默认和校验123456789101112Vue.component('bkog-post', &#123; props: &#123; title: &#123; type: String, default: 'title', required: true, validator: function (value) &#123; return value != 'abc' &#125; &#125; &#125;&#125;) propsData作用：创建实例时传递props，主要作用是方便测试。基本上，没有用过 computed作用：用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算12345678var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; aDouble () &#123; return this.a * 2 &#125; &#125;&#125;) methods作用：用来定义实例的一些处理方法，如绑定的事件等。注意，在methods不能使用箭头函数来定义函数12345678var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus () &#123; this.a ++ &#125; &#125;&#125;) watch作用：用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。同样，不能使用箭头函数来定义函数1234567891011121314var vm = new Vue(&#123; data: &#123; a: 1, b: 2， c: 3 &#125;, watch: &#123; a (curVal, oldVal) &#123; console.log(`new: %s, old: %s`, curVal, oldVal) &#125;, b: 'someMethod', // 这里的someMehod是对应的处理函数的名字 c: &#123; handler: function (curVal, oldVal) &#123; /*...*/ &#125;, deep: true, //深度 watcher，为了发现对象内部值的变化 immediate: true // 立即以表达式的当前值触发回调 &#125; &#125;&#125;) Vue的生命周期每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示： 生命周期钩子函数▶ beforeCreate 实例创建前，此时无法访问到el属性和data属性 ▶ created 实例创建完成，属性已经绑定，但是DOM还未生成，el属性还无法访问 ▼ 关于属性不仅仅是data属性，还有props和method都在created的时候绑定完成 ▶ beforeMount 模板编译/挂在之前，只有绑定了el属性，才会执行到这里，否则到created就已经停止生命周期 ▼ 关于模板编译的顺序 当实例对象中有template参数的时候，则将其作为模板编译成render函数 如果没有template参数时，则将外部HTML作为模板编译 在Vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于template与outer HTML ▶ mounted 模板编译/挂在之后，此时data数据绑定在页面上是以虚拟DOM的形式存在的 ▶ beforeUpdate &amp;&amp; updated data数据更新之前 &amp;&amp; 更新之后，组件重新渲染 ▶ beforeDestroy &amp;&amp; destroyed 实例销毁之前 &amp;&amp; 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁","categories":[{"name":"Vue相关","slug":"Vue相关","permalink":"http://yoursite.com/categories/Vue相关/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vue生命周期","slug":"Vue生命周期","permalink":"http://yoursite.com/tags/Vue生命周期/"}]},{"title":"ES6 核心向新特性（03）","slug":"ES6 核心向新特性（03）","date":"2018-03-09T10:11:10.000Z","updated":"2019-05-24T12:16:52.832Z","comments":true,"path":"2018/03/09/ES6 核心向新特性（03）/","link":"","permalink":"http://yoursite.com/2018/03/09/ES6 核心向新特性（03）/","excerpt":"PromisePromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。","text":"PromisePromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。 PromisePromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。 基本用法通常 Promise 的状态有三种：Fulfilled 状态表示执行成功；Rejected 状态表示执行失败；Pending 状态表示正在执行中。123456789101112131415161718192021let status = 1;let promise = new Promise(function(resolve, reject) &#123; if(status === 1) &#123; resolve('Fulfilled'); &#125; else &#123; reject('Rejected'); &#125;&#125;);Promise.then(function(msg) &#123; console.log('success1:' + msg); return msg;&#125;, function(msg) &#123; console.log('fail1:' + msg); return msg;&#125;).then(function(msg) &#123; console.log('success2:' + msg);&#125;, function(msg) &#123; console.log('fail2:' + msg);&#125;);// success1: Fulfilled// success2: Fulfilled promise 的 then 方法接受两个处理函数，当 status 为 1 时执行 Fulfilled 成功调用，否则 Rejected 失败调用。返回的状态给第二个 then 方法处理。then 方法可以将传入参数的返回值一直传递下去，如果是异步的场景，就可以用这种方式来解决多层回调嵌套的问题了。 用 promise 处理异步场景123456789101112131415161718192021222324252627// 希望它依次异步输出 A B C Dlet promise = new Promise(function(resolve) &#123; setTimeout(function() &#123; console.log('A'); resolve(); &#125;, 3000); // 延迟3秒打印A&#125;);// 使用 then 来链式处理流程promise.then(function() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log('B'); resolve(); &#125;, 2000); // 延迟2秒打印B &#125;);&#125;).then(function() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log('C'); resolve(); &#125;, 1000); // 延迟1秒打印C &#125;);&#125;).then(function() &#123; return new Promise(function(resolve, reject) &#123; console.log('D'); // 不延迟打印D &#125;);&#125;); 通过在不同的 then 处理方法中返回一个新的 promise 来解决。返回新的 promise 里面具有resolve()和reject()方法，只有当它的 resolve 或 reject 被调用时，promise 方法才会继续执行，进入下一个 then 方法中操作。设置在异步函数完成的最后调用resolve()就可以有效控制 promise 进入下一个 then 方法执行。 SymbolSymbol 是除布尔值、数值等六种数据类型外的第七种数据类型。属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。12345678910111213let object = &#123;&#125;;let name = Symbol();let family = Symbol();object[name] = 'ouven';object[family] = 'zhang';console.log(object);// &#123;// Symbol(): 'ouven',// Symbol(): 'zhang',// &#125;console.log(typeof name); // symbol ProxyProxy 可以用来拦截某个对象的属性访问方法，然后重载对象的.运算符。123456789101112131415let object = new Proxy(&#123;&#125;, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;`); return Reflect.set(target, key, value, receiver); &#125;&#125;);// 赋值或定义值都会输出// getting value// setting valueobject['value'] = 3; 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。▼ 基本用法1var proxy = new Proxy(target, handler); target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 get(target, propKey, receiver): 拦截对象属性的读取，如proxy.foo和proxy[&#39;foo&#39;] set(target, proKey, value, receiver): 拦截对象属性的设置，如proxy.foo = v和proxy[&#39;foo&#39;] = v …… 统一码es6 字符串支持新的 Unicode 文本形式，同时也增加了新的正则表达式修饰符u来处理统一码。尽管如此，在实际的开发中，这样处理仍会降低程序可读性和处理速度，所以目前不建议使用。 进制数支持es6 增加了对二进制（b）和八进制（o）数字面量的支持。120b111110111 === 503 // true0o767 === 503 // true ReflectReflect 可以理解为原有对象上的一个引用代理，它用于对原有对象进行赋值或取值操作，但不会触发对象属性的 getter 或 setter 调用，而直接使用 = 对对象进行赋值或取值操作会自动触发 getter 或 setter 方法。 tail calls 尾调用tail calls 尾调用保证了函数尾部调用时调用栈有一定的长度限制，这使得递归函数即使在没有限制输入时也能保证安全性而避免发生错误。12345678function factorial(n, start = 1) &#123; if(n &lt; = 1) &#123; return start; &#125; return factorial(n - 1, n * start);&#125;// 默认情况下会发生栈溢出，但是在 es6 中是可以安全执行的factorial(100000); ▼ 基本概念尾调用是指某个函数的最后一步是调用另一个函数。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。▼ 注意点尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 学习参考：ECMAScript 6入门——阮一峰尾调用优化《现代前端技术解析》","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6 核心向新特性（02）","slug":"ES6 核心向新特性（02）","date":"2018-03-08T11:56:33.000Z","updated":"2019-05-24T12:16:58.113Z","comments":true,"path":"2018/03/08/ES6 核心向新特性（02）/","link":"","permalink":"http://yoursite.com/2018/03/08/ES6 核心向新特性（02）/","excerpt":"模块 module12import &#123; sayHi &#125; from './people';export default sayHi; 注意点：使用default导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。","text":"模块 module12import &#123; sayHi &#125; from './people';export default sayHi; 注意点：使用default导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。 类12345678910111213141516171819202122232425// 类声明class Aminal &#123; // 类中只能包含一个名为constructor的特殊方法 constructor() &#123; // ... &#125;&#125;// extends 创建子类class People extends Aminal &#123; constructor(contents = &#123;&#125;) &#123; super(); // 调用父类的构造函数 this.name = contents.name; this.family = contents.family; &#125; sayHi() &#123; console.log(`Hello $&#123;this.name&#125; $&#123;this.family&#125;`); &#125;&#125;let boy = new People(&#123; name: 'ouven', family: 'zhang'&#125;);boy.sayHi(); // Hello ouven zhang 模块 module12import &#123; sayHi &#125; from './people';export default sayHi; 注意点：使用default导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。 循环与迭代器 Iterator在 es6 阶段，除了do...while、for循环，还可以使用for...in来遍历对象。Iterator迭代器的加入让遍历数组、对象和集合的方式更加灵活可控，Iterator可以控制每次单步循环触发的时机，不用一次遍历所有的循环。 ▼ for...of遍历实现12345const numbers = [1, 2, 3, 4, 5];for(let number of numbers) &#123; console.log(number);&#125; ▼ 迭代器遍历数组1234567891011121314151617const numbers = [1, 2, 3, 4, 5];let iterator = numbers[Symbol.iterator]();let result = iterator.next();console.log(result.value); // 1result = iterator.next();console.log(result.value); // 2result = iterator.next();console.log(result.value); // 3result = iterator.next();console.log(result.value); // 4result = iterator.next();console.log(result.value); // 5 ▼ 对比Iterator 可以在循环开始后任意的地方进行数组的单步循环，当循环迭代中每次单步循环操作都不一样时，使用 Iterator 更加的方便。如果使用for...of则需要不断判断执行的次数来执行不同的单步循环。▼ 注意点每次 Iterator 调用next()都会返回一个对象{done: false, value: item}，done的属性是布尔值，表示循环遍历是否完成，value则是每一步next()调用获取到的值。 生成器 Generator12345678910111213141516171819const generator = function* () &#123; const numbers = [1, 2, 3, 4, 5]; for(let number of numbers) &#123; yield console.log(number); &#125;&#125;let result = generator();result.next(); // 1// ...doSomethingresult.next(); // 2// ...doSomethingresult.next(); // 3// ...doSomethingresult.next(); // 4// ...doSomethingresult.next(); // 5// ...doSomething Generator 是针对函数内代码块的执行控制，如果将一个特殊函数的代码使用yield关键字来分割成多个不同的代码段，那么每次 Generator 调用next()都只会执行yield关键字之间的一段代码。Generator 可以认为是一个可中断执行的特殊函数，声明方法是在函数名后面加上*来与普通函数区分。▼ 注意点Generator 遇到yield关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果console.log(number)是一个耗时的工作，那么程序只在 Generator 里面暂停，外面的程序仍会继续执行。12345678910111213141516171819202122const generator = function* () &#123; const numbers = [1, 2, 3, 4, 5]; for(let number of numbers) &#123; yield setTimeout(function() &#123; console.log(number); &#125;, 3000); &#125;&#125;let result = generator();let done = result.next();while(!done.done) &#123; done = result.next();&#125;console.log('finish');// 输出finish12345 集合类型Set &amp; Map▼ 为什么有了数组和对象来进行存储数据还要要使用 Map &amp; Set 对象的键名一般只能是字符串，而不能是一个对象； 对象没有直接获取属性个数等这些方便操作的方法； 对于对象的任何操作都需要进入对象的内部数据中完成，如查找、删除某个值必须循环遍历对象内部的所有键值对来完成。 ▼ Set的基本用法123const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4] Set 不会添加重复的值，并且可以接受一个数组（或者具有 Iterable 接口的其他数据解构）作为参数，用来初始化。▼ Map的基本用法123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以作为键。 WeakSet &amp; WeakMapWeakSet 和 WeakMap 则对应着 Set 和 Map 的优化类型，所以某种程度上，为了让程序开发更加方便，我妈有必要引入集合这类更为高效的类型。WeakSet 和 WeakMap 在生成时有更加严格的限制：WeakSet 只存储对象类型的元素，不能遍历，没有size属性；WeakMap 只接受基本类型的值作为键名，没有keys、values、entries等遍历方法，也没有size属性。▼ WeakSet的基本用法1234567const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet &#123;[1, 2], [3, 4]&#125;const b = [3, 4];const ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…) ▼ WeakMap的基本用法12345678const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object! 数组或对象循环遍历的方法对比for/while 循环语句1234let arr = [1, 2, 3];for(let = 0, len = arr.length; i &lt; len; i++) &#123; console.log(arr[i]);&#125; 所有语言都会涉及的循环。不过单纯的for/while能力有限，而且性能上也堪忧。而且必须借助特定的结构才能遍历数据结构。 forEach 方法123[1, 2, 3].forEach(function(value, index) &#123; console.log(index + ':' + value);&#125;); 优点：可以同时获取index和value，不必再像以前遍历数组那样，还要再在for去获取值。缺点：仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。应用场景：仅在遍历数组的时候使用。 for…in 语句1234let obj = &#123;a: 1, b: 2,c: 3&#125;;for(let key in obj) &#123; console.log(obj[key]);&#125; 优点：它可以支持所有对象类型的数据，包括数组，甚至是函数等，而且语法简单。且不同于forEach方法，它可以与break、continue和return配合使用。缺点：循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。主要是为遍历对象而设计的，不适用于遍历数组。应用场景： 遍历常用对象（如例子） for…of 语句1234567var list = new Map();list.set('a', 1);list.set('b', 2);list.set('c', 3);for(var [key, value] of list) &#123; console.log(key + ':' + value);&#125; for...of是ES6新增的语法，它是基于ES6新增的Iterator和Symbol开发的。优点：在遍历中直接取值。感觉上和for...in形成互补，一个在遍历中取键名，另一个取值。另一个优点是，它可以遍历任何部署了 Iterator 接口的数据结构（如 Set 和 Map），甚至是非 JavaScript 的数据类型，即自己定义的数据结构。缺点：对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。应用场景：推荐应用于Map上的遍历。 map() &amp; filter() &amp; reduce()12345678910111213141516var arr = [1, 2, 3];arr.map(function(element) &#123; return element + 1;&#125;);// [2, 3, 4]arr.filter(function(element) &#123; return element &gt; 1;&#125;)// [2, 3]var result = arr.reduce(function(prev, element) &#123; return prev + element;&#125;, 0);// 5 应用场景：这三个方法都是是 Array 中的方法，常用于数组中的数值的处理。map主要用于对存储的数据进行加工，filter偏向于过滤数据，reduce用于计算总和。 学习参考：ECMAScript 6入门——阮一峰《现代前端技术解析》","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6 核心向新特性（01）","slug":"ES6 核心向新特性（01）","date":"2018-03-07T06:19:15.000Z","updated":"2019-05-24T12:17:01.307Z","comments":true,"path":"2018/03/07/ES6 核心向新特性（01）/","link":"","permalink":"http://yoursite.com/2018/03/07/ES6 核心向新特性（01）/","excerpt":"块级作用域变量声明关键字 let 、 constlet 、 const 与 var 的对比 不存在变量提升；1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;","text":"块级作用域变量声明关键字 let 、 constlet 、 const 与 var 的对比 不存在变量提升；1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 块级作用域变量声明关键字 let 、 constlet 、 const 与 var 的对比 不存在变量提升； 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）； 12typeof x; // ReferenceErrorlet x; let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用； 123456&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改； 12const b = 'hello';b = 'world'; // Uncaught TyperError: Assignment to constant variable. 使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面； 12345let a = 1;var A = 2;console.log(window.a || global.a); // undefinedconsole.log(window.A || global.A); // 2 用 let 、 const 赋值语句的执行速度比使用 var 快约65%； 使用场景的区分模块内不变的引用和常量，使用const定义；可变的变量或引用使用let声明；var仅用于声明函数整个作用域内需要使用的变量。 字符串模板12let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁 字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出 解构赋值解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。 数组解构▼ 变量的赋值12345678910111213let [a, b, c] = [11, 22];a // 11b // 22c // undefinedlet [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 ▼ 指定默认值12let [foo = true] = [];foo // true 对象解构▼ 变量的赋值（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" ▼ 指定默认值12var &#123;x = 3&#125; = &#123;&#125;;x // 3 数组的新特性扩展运算符(...)12const arr =['hello', 'world'];const newArr = [...arr]; // ['hello', 'world'] 注意点： ...进行的数组复制是浅拷贝 扩展API Array.from: 用于将数组对象转化为真正的数组 1234567891011let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] Array.of: 将传入的一组参数转换为数组 1Array.of(3, 11, 8) // [3,11,8] Array.prototype.copyWithin: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用copyWithin方法会修改当前数组 12let colors = ['red', 'blue', 'green', 'green'];colors.copyWithin(0, 3); // ['green', 'blue', 'green', 'green'] Array.prototype.fill: 使用给定值，填充一个数组，会改变原来的数组 1colors.fill('black'); // ['black', black', black', black'] Arrau.prototype.find: 用于找出第一个符合条件的数组元素 12345colors.find(function(color) &#123; if(color === 'green') &#123; return color; &#125;&#125;) // green Array.prototype.findIndex: 用来返回某个特定数组元素在数组中的位置 12345colors.findIndex(function(color) &#123; if(color === 'green') &#123; return color; &#125;&#125;) // 2 新的数组迭代方式entries()、keys()和values()，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用for...of循环进行遍历，区别是keys()是对数组键名进行遍历，values()是对数组键值进行遍历，entries()是对数组中键值对进行遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 增强函数函数参数ES6 对函数参数的改进主要是添加了默认参数、不定参数和拓展参数 ▼ 默认参数1234function sayHi(name = 'ouven') &#123; console.log(`Hello $&#123;name&#125;`);&#125;sayHi(); // Hello ouven ▼ 不定参数1234function sayHi(...name) &#123; console.log(name.reduce((a,b) =&gt; `Hello $&#123;a&#125; $&#123;b&#125;`));&#125;sayHi('oven', 'zhang'); // Hello ouven zhang ▼ 扩展参数12345let name = ['oven', 'zhang'];function sayHello(name1, name2) &#123; console.log(`Hello $&#123;name1&#125; $&#123;name2&#125;`);&#125;sayHello(...name); // Hello ouven zhang 其中不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数将多个参数映射到一个数组。▼ 不定参数与 arguments 的对比不定参数和arguments都可以使用函数的形参来表示所有的参数组成的列表，但是arguments不是真正的数组，所有使用数组的方法必须使用Array.prototype.slice.call先将其转换成数组，所有使用起来不定参数更加的方便。 箭头函数12345var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 注意点：箭头函数没有完整的执行上下文，因为其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链， 没有 this 值。 增强对象es6 中，对象的使用更加方便。在定义对象时通过属性简写、变量作为属性名或省略对象函数属性的书写等方式可以提高编码的效率。123456789101112131415161718const name = 'onven';function getKey(key) &#123; return key;&#125;const people = &#123; // 属性简写 name, // 返回变量或对象作为属性名 [getKey('family')]: 'zhang', // 对象方法属性简写声明 sayHi() &#123; console.log(`Hello $&#123;this.name&#125; $&#123;this.family&#125;`); &#125;&#125;people.sayHi(); // Hello ouven zhang 注意点：为了代码便于维护和理解，建议尽量不将变量或对象作为对象的属性名。 学习参考：ECMAScript 6入门——阮一峰《现代前端技术解析》","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Webpack学习笔记","slug":"Webpack学习笔记","date":"2018-01-15T06:13:32.000Z","updated":"2019-05-24T12:09:24.132Z","comments":true,"path":"2018/01/15/Webpack学习笔记/","link":"","permalink":"http://yoursite.com/2018/01/15/Webpack学习笔记/","excerpt":"Webpack 基本介绍▼ 什么是Webpack：webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。","text":"Webpack 基本介绍▼ 什么是Webpack：webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。 Webpack 基本介绍▼ 什么是Webpack：webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。▼ 为什那么要使用Webpack：现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法： 模块化，让我们可以把复杂的程序细化为小的文件； 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别； Scss，less等CSS预处理器； … 这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为Webpack类的工具的出现提供了需求。 Webpack 的使用安装我们常规直接使用 npm 的形式来安装（全局安装）：1$ npm install webpack -g 如果常规项目还是把依赖写入 package.json 包更人性化（局部安装）：12$ npm init // 生成package.json文件，写入一些如作者、版本等基本信息$ npm install webpack --save-dev 配置每个项目下都必须配置有一个 webpack.config.js，就是一个配置项，告诉 webpack 它需要做什么。1234567891011121314151617181920212223242526272829303132333435var webpack = require('webpack');var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : './src/js/page/index.js' &#125;, //入口文件输出配置 output: &#123; path: 'dist/js/page', filename: '[name].js' &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125;, //其它解决方案配置 resolve: &#123; root: 'E:/github/flux-example/src', //绝对路径 extensions: ['', '.js', '.json', '.scss'], alias: &#123; AppStore : 'js/stores/AppStores.js', ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125;&#125;; ▼ plugins：插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。▼ entry：页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：1234567891011&#123; entry: &#123; page1: \"./page1\", //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出 page2: [\"./entry1\", \"./entry2\"] &#125;, output: &#123; path: \"dist/js/page\", filename: \"[name].bundle.js\" &#125;&#125; 该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。▼ module.loaders：告知 webpack 每一种文件都需要使用什么加载器来处理：12345678910111213module: &#123; //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, //.js 文件使用 jsx-loader 来编译处理 &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ]&#125; 如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。如：url-loader，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：1npm install url-loader -save-dev 配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。▼ resolve：其它解决方案配置123456789101112resolve: &#123; //查找module的话从这里开始查找 root: 'E:/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['', '.js', '.json', '.scss'], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125;&#125; 运行1$ webpack --display-error-details 后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。其他主要的参数有：1234$ webpack --config XXX.js //使用另一份配置文件（比如webpack.config2.js）来打包$ webpack --watch //监听变动并自动打包$ webpack -p //压缩混淆脚本，这个非常非常重要！$ webpack -d //生成map映射文件，告知哪些模块被最终打包到哪里了 实战应用项目文件夹结构如下图： src目录下的文件夹存放源代码，dist目录下存放打包过后的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var path = require('path');var webpack = require('webpack');module.exports = &#123; entry: './src/index.js', // 以index.js为入口 output: &#123; filename: 'js/canvas-filter.bundle.js', // 打包后生成的文件 path: path.resolve(__dirname,'./dist') // 使用绝对路径 &#125;, module: &#123; rules: [ &#123; // 使js中能够require css 文件的loader test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;, &#123; // 使得less文件能够解析成css的loader test: /\\.less$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'less-loader', 'postcss-loader' ] &#125;, &#123; // 使得能够正确引用图片文件路径的loader test: /\\.(png|jpg|gif|svg)$/i, loader: 'file-loader' &#125; ] &#125;, plugins: [ // 再项目中使用jquery时所需要的配置 new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery', 'window.$': 'jquery' &#125;), new webpack.HotModuleReplacementPlugin() ], devServer: &#123; // 使用webpack-dev-server，开启本地服务器 hot: true, inline: true &#125;&#125;","categories":[{"name":"项目自动化","slug":"项目自动化","permalink":"http://yoursite.com/categories/项目自动化/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"Vue.js学习笔记（01）","slug":"Vue.js学习笔记（01）","date":"2017-10-19T13:25:58.000Z","updated":"2019-05-24T12:15:19.524Z","comments":true,"path":"2017/10/19/Vue.js学习笔记（01）/","link":"","permalink":"http://yoursite.com/2017/10/19/Vue.js学习笔记（01）/","excerpt":"Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。 ▼ 什么是MVVM：MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。","text":"Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。 ▼ 什么是MVVM：MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。 Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。 ▼ 什么是MVVM：MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。 Model代表我们整个webapp所需要的数据模型，一个典型的例子就是用户信息Model,它应该含有(姓名，年龄等属性)。Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。 ViewView这个词出现频率最多的地方应该是MVC。在MVC设计中，View是唯一与用户交互的地方，或者说它是Model变化后的直观反映。在MVVM中，View被认为是主动的而非被动的。一个被动的View时只它只能任由“他人”（Controller）摆布，自己却不能改变任何东西，如利用Jquery操作DOM。而MVVM中View是具有主动性的，因为它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自己身的行为（展示），而还会将自身的变化同步到ViewModel中。 ViewModelViewModel可以被看作是MVC中的Controller,它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。 MVC 和 MVVM 的比较刚发现了一篇关于几个模型的博文从Script到Code Blocks、Code Behind到MVC、MVP、MVVM在这里，简单的对这两个比较常见的设计模型进行一些比较： MVC结构图 MVVM结构图 MVC的优点由于前端的发展，出现了多页应用和Web App这种东西，使得前端不仅仅做的是简单的数据展示了。使用MVC，有下列一些优点： 简化代码 减少重复 集中精神编写业务逻辑 易于扩充 数据触发事件 面向数据编程 MVC缺点MVC虽然将需求和UI的相关工作分化成了三份，但是由于它们三者的三角关系使得维护很成问题。在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。 MVVM与MVC最大的区别在于，MVVM切断了View层和Model层的联系，让View层只和ViewModel层交互，而ViewModel再和Model层交互。在MVVM中，View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。 随着HTML5的发展，Web App的应用越来越广泛，甚至能媲美Nativ eApp（大部分安卓或IOS应用），但随之也暴露出了三个痛点问题： 开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 MVVM优点在MVVM中，ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，这就完美的解决了以上的问题。 Vue.js的MVVM应用 Observer：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现； Compile：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数； Watcher：订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数； Dep：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法 搭建开发环境使用git，输入指令123456789# 安装vue-cli$ cnpm install -g vue-cli# 创建一个基于 \"webpack\" 模板的新项目$ vue init webpack my-project# 安装依赖$ cd my-project$ cnmp install# 开启项目$ npm run dev 模板解析index.html：放在项目根目录下，是项目的入口1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;blog-project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- app为一个组件，默认调用src里的main.js --&gt; &lt;/body&gt;&lt;/html&gt; src/main.js：注册组件app123456789101112131415//import表示导入组件，ES6语法import Vue from 'vue' //导入vue框架import App from './App' //同级目录下的App.vueimport router from './router' //同级目录下的router文件夹Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125; //注册一个app&#125;) src/App.vue：组件的主要代码，包括template、script、style123456789101112131415161718192021222324&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;!-- 渲染路径匹配到的视图组件，方便渲染你指定路由对应的组件 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; router/index.js： 创建路由并配置路由映射 ，并通过export输出router到main.js文件中1234567891011121314151617import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld' // 在这里引入另一个名为HelloWorld的组件// 即components目录下的HelloWorld.vueVue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: HelloWorld &#125; ]&#125;)","categories":[{"name":"Vue相关","slug":"Vue相关","permalink":"http://yoursite.com/categories/Vue相关/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"MVVM","slug":"MVVM","permalink":"http://yoursite.com/tags/MVVM/"}]},{"title":"DOM基础知识巩固","slug":"DOM本质","date":"2017-10-02T05:15:36.000Z","updated":"2019-05-24T12:17:32.761Z","comments":true,"path":"2017/10/02/DOM本质/","link":"","permalink":"http://yoursite.com/2017/10/02/DOM本质/","excerpt":"DOM本质DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。 DOM节点操作获取DOM节点 document.getElementById document.getElementsByTagName document.getElementsByClassName document.querySelectorAll","text":"DOM本质DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。 DOM节点操作获取DOM节点 document.getElementById document.getElementsByTagName document.getElementsByClassName document.querySelectorAll DOM本质DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。 DOM节点操作获取DOM节点 document.getElementById document.getElementsByTagName document.getElementsByClassName document.querySelectorAll property与attribute虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。 property是DOM中的属性，是JavaScript里的对象； attribute是HTML标签上的特性，它的值只能够是字符串； 例如在html中有一段这样的代码：1&lt;input id=\"test\" value=\"1\" sth=\"whatever\"&gt; 我们在js中来获取这个DOM对象：12345var test = document.getElementById('test');console.log(test);console.log(test.id); // 'test'console.log(test.value); // 1console.log(test.sth) // undefined 由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：1&lt;input id=\"test-2\" &gt; 12var test_2 = document.getElementById('test-2');console.log(test_2.value); // null 虽然没有在标签中定义value，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论： DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。 如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。 那么标签上的sth定义在哪里呢？ 也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。1console.log(test.attibutes.sth); // 'sth=\"whatever\"' 由此可以得出： HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面； 这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单； 那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：123test.value = 'new value of prop';console.log(test.value); // 'new value of prop'console.log(test.arrtibutes.value); // 'value=\"1\"' 如果反过来，效果又是如何呢？123test.attributes.value = 'new value of attr';console.log(test.value); // 'new value of attr'console.log(test.attributes.value); // 'new value of attr' 此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：1test.attributes.value.nodeValue = 'new value of attr'; 由此，可得出结论： property能够从attribute中得到同步； attribute不会同步property上的值； attribute和property之间的数据绑定是单向的，attribute-&gt;property； 更改property和attribute上的任意值，都会将更新反映到HTML页面中； DOM操作 有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有： 减少DOM访问次数 多次访问同一DOM，应该用局部变量缓存该DOM 尽可能使用querySelector，而不是使用获取HTML集合的API 注意重排（reflow）和重绘（repaint） 使用事件委托，减少绑定事件的数量 重排（重构）&amp;重绘重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有： 添加或删除DOM元素 元素位置、大小、内容改变 浏览器窗口大小改变 滚动条出现 最小化重排、重绘的建议： 不要再修改布局信息的时候，去查询布局信息 修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式 :hover会降低响应速度，在处理很大的列表时，避免使用 BOM操作BOM（Browser Object Model）指的是浏览器对象模型，主要用途： 检测浏览器的类型 拆解url的各部分 navigatornavigator对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。常用方法有： navigator.userAgent //用户代理头的字符串表示 screenscreen对象：用于获取某些关于用户屏幕的信息。常用方法有： screen.width/height //屏幕的宽度与高度，以像素计 screen.availWidth/availHeight //窗口可以使用的屏幕的宽度和高度，以像素计 screen.colorDepth //用户表示颜色的位数，大多数系统采用32位 window.moveTo(0, 0); window.resizeTo(screen.availWidth, screen.availHeight); //填充用户的屏幕 locationlocation对象：表示载入窗口的URL。常用方法有： location.href //当前载入页面的完整URL location.portocol //URL中使用的协议，即双斜杠之前的部分，如http location.host //服务器的名字，如www.wrox.com location.hostname //通常等于host，有时会省略前面的www location.port //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080 location.pathname //URL中主机名后的部分，如/pictures/index.htm location.search //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx location.hash //如果URL包含#，返回该符号之后的内容，如#anchor1 location.assign(&quot;http:www.baidu.com&quot;); //同location.href，新地址都会被加到浏览器的历史栈中 location.replace(&quot;http:www.baidu.com&quot;); //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问 location.reload(true | false); //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false historyhistory对象：浏览器窗口的历史常用方法有： history.go(-1); //访问浏览器窗口的历史，负数为后退，正数为前进 history.back(); //同上 history.forward(); //同上 history.length //可以查看历史中的页面数","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"JS定时器与单线程","slug":"JavaScript单线程","date":"2017-09-25T13:28:25.000Z","updated":"2019-05-24T12:15:46.593Z","comments":true,"path":"2017/09/25/JavaScript单线程/","link":"","permalink":"http://yoursite.com/2017/09/25/JavaScript单线程/","excerpt":"JavaScript单线程众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。","text":"JavaScript单线程众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。 JavaScript单线程众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。 这里有个例子：12345678910111213var date = new Date();//打印才进入时的时间console.log('first time: ' + date.getTime());//一秒后打印setTimeout里匿名函数的时间setTimeout(function()&#123; var date1 = new Date(); console.log('second time: ' + date1.getTime() ); console.log( date1.getTime() - date.getTime() );&#125;,1000);//重复操作for(var i=0; i &lt; 10000 ; i++)&#123; console.log(1);&#125; setTimeout是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。 其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以setTimeout只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。 但是这里仍然有一个疑问，假设setTimeout后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那setTimeout会在紧跟着的第一个函数执行完就插队执行吗？ 1234567var startTime = new Date();setTimeout(function() &#123; console.log(\"hellow world\");&#125;, 1000);while(new Date() - startTime &lt; 1000) &#123;&#125;console.log(\"wait\");while(true) &#123;&#125; 答案是并不会，setTimeout只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出hellow world。 JavaScript运行机制我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 所以当一段代码有异步操作时，执行过程是这样的： 所有同步任务都在主线程上执行，形成一个执行栈。 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。 主线程不断重复上面的第三步。 所以，只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。 任务队列“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。 主线程不断从“任务队列”中读取事件的过程又称为Event Loop。 setTimeout与setIntervalsetTimeout关于setTimeout在上述已经说的蛮清楚了，还有一点是关于setTimeout(func,0)。当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，setTimeout(func,0)相当于插了队。 setIntervalsetInterval是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他代码实例时，才能将定时器代码添加到任务队列中。 假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时setInterval的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。 123456setInterval(function() &#123; var startTime = new Date(); while(Date.now - startTime &lt; 350) &#123;&#125;&#125;, 200);var startTime = new Date();while(Date.now() - startTime &lt; 300) &#123;&#125; 由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图： 在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。 所以在使用setInterval做动画时要注意两个问题： 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间 如果主进程运行时间过长，会出现跳帧的现象 为了避免setInterval的两个缺点，可以使用链式setTimeout()：12setTimeout(function()&#123; //其他处理 setTimeout(arguments.callee, interval); &#125;, interval); 文章参考：Javascript定时器学习笔记阮一峰 —— JavaScript 运行机制详解：再谈Event Loop","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS变量计算","slug":"JS变量计算","date":"2017-08-24T12:53:29.000Z","updated":"2019-05-24T12:16:00.684Z","comments":true,"path":"2017/08/24/JS变量计算/","link":"","permalink":"http://yoursite.com/2017/08/24/JS变量计算/","excerpt":"typeof 运算符12345678typeof undefined // undefinedtypeof 'abc' // stringtypeof 123 // numbertypeof true // booleantypeof &#123;&#125; // objecttypeof [] // objecttypeof null // objecttypeof console.log // function","text":"typeof 运算符12345678typeof undefined // undefinedtypeof 'abc' // stringtypeof 123 // numbertypeof true // booleantypeof &#123;&#125; // objecttypeof [] // objecttypeof null // objecttypeof console.log // function typeof 运算符12345678typeof undefined // undefinedtypeof 'abc' // stringtypeof 123 // numbertypeof true // booleantypeof &#123;&#125; // objecttypeof [] // objecttypeof null // objecttypeof console.log // function 变量运算 - 强制类型转换字符串拼接12var a = 100 + 10 // 110var b = 100 + '10' // '10010' 当使用减运算时：1var c = '100' - 10 // 90 == 运算符123100 == '100' // true0 == '' // truenull == undefined // true ==与===的区别：===是严格等于，只有类型完全相同才会返回true1234null === nullundefined === undefinednull === undefined // falseNaN === NaN // false 什么时候用==什么时候用===：jQuery源码中推荐写法，只有下述情况才用==，其他时候都用===。123if(a == null) &#123; // 这里相当于 a === null || a === undefined&#125; if语句12345678var a = true;if(a) &#123; //... &#125; var b = 100; // trueif(b) &#123; //... &#125;var c = ''; // falseif(c) &#123; //... &#125; if中被判定为false的几个值：0,NaN,&#39;&#39;,null,undefined 逻辑运算1234567console.log(10 &amp;&amp; 0) // 0console.log('' || 'abc') // 'abc'console.log(!window.abc) // true// 判断一个变量会被当做 true 还是 falsevar a = 100;console.log(!!a) //true","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"页面加载——浏览器渲染","slug":"页面加载——浏览器渲染","date":"2017-08-19T10:46:53.000Z","updated":"2019-05-24T12:07:37.575Z","comments":true,"path":"2017/08/19/页面加载——浏览器渲染/","link":"","permalink":"http://yoursite.com/2017/08/19/页面加载——浏览器渲染/","excerpt":"一个网站在浏览器端是如何进行渲染的呢？ 根据HTML结构生成DOM tree 根据CSS生成CSSOM 将DOM和CSSOM整合形成RenderTree 根据RenderTree开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染","text":"一个网站在浏览器端是如何进行渲染的呢？ 根据HTML结构生成DOM tree 根据CSS生成CSSOM 将DOM和CSSOM整合形成RenderTree 根据RenderTree开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 一个网站在浏览器端是如何进行渲染的呢？ 根据HTML结构生成DOM tree 根据CSS生成CSSOM 将DOM和CSSOM整合形成RenderTree 根据RenderTree开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 顺序执行、并发加载因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入&lt;link&gt;或&lt;script&gt;，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。 对于&lt;img&gt;所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。 1234567window.addEventListener('load', function() &#123; // 页面的全部资源加载完才会执行，包括图片、视频&#125;)document.addEventListener('DOMContentLoaded', function() &#123; // DOM 渲染完即可执行，此时图片、视频可能还没加载完&#125;) 阻塞CSS阻塞 css在&lt;head&gt;中阻塞页面的渲染：即这个页面要呈现出效果需要等待这个&lt;link&gt;所对应的css资源加载完成以后才能进行渲染。如果css并不是在&lt;head&gt;中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在&lt;head&gt;标签中就引入。 css阻塞js的执行：即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作DOM元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。 css不阻塞外部脚本的加载：即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在HTMLPreloadScanner类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。 JS阻塞 直接引入的js阻塞页面的渲染：直接引入指的是没有通过defer和async方法直接用&lt;script&gt;引入的js资源。如果在标签中指定了defer方法，这个资源将在页面解析到&lt;script&gt;的时候就开始下载，但不会执行，直到DOM加载完成（触发onload事件前）才会被调用。而async与defer的作用是相同的，它们的区别在于sync的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作DOM元素。 js不阻塞资源的加载：与css的加载同理，由于有扫描器的存在，资源会并行加载。 js顺序执行，阻塞后续js逻辑的运行：即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。 引入方法脚本的位置123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;Source Example&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"script1.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"script2.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"script3.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 当我们在&lt;head&gt;中引入js文件时，由于js的阻塞特性，当浏览器解析到&lt;script&gt;标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。1234567891011121314&lt;html&gt;&lt;head&gt;&lt;title&gt;Source Example&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt; &lt;script type=\"text/javascript\" src=\"script1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"script2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"script3.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 所以建议把&lt;script&gt;放在&lt;body&gt;末尾，因为此时样式和DOM元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。 无阻塞脚本 defer属性：是HTML4为&lt;script&gt;拓展的属性，指明本元素所含的脚本不会修改DOM，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;title&gt;Script Defer Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" defer&gt; console.log(\"defer\"); &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; console.log(\"script\"); &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; console.log(\"load\"); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 该段代码执行后的结果是script、defer、load，表明含有defer属性的脚本是在onload执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。 async属性：是HTML5为&lt;script&gt;拓展的属性，作用和defer一样，能够异步地加载和执行脚本。它比defer有更好的兼容性，但由于async在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。 动态脚本12345var script = document.createElement (\"script\");script.type = \"text/javascript\";script.src = \"script1.js\";document.getElementsByTagName(\"head\")[0].appendChild(script); 该方式可以让&lt;script&gt;无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他DOM元素是并行的，所以可能出现这个文件中绑定操作的DOM元素还没加载，因为找不到而报错。 12345678var script = document.createElement (\"script\");script.type = \"text/javascript\";script.onload = function()&#123; console.log(\"Script loaded!\");&#125;;script.src = \"script1.js\";document.getElementsByTagName(\"head\")[0].appendChild(script); 在Firefox、Opera、Chrom和Safari 3+中提供了script.onload事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即readystatechange事件。 uninitialized：默认状态loading：下载开始loaded：下载完成interactive：下载完成但尚不可用complete：所有数据已经准备好 123456789101112var script = document.createElement(\"script\");script.type = \"text/javascript\";//Internet Explorerscript.onreadystatechange = function()&#123; if (script.readyState == \"loaded\" || script.readyState == \"complete\")&#123; script.onreadystatechange = null; console.log(\"Script loaded.\"); &#125;&#125;;script.src = \"script1.js\";document.getElementsByTagName(\"head\")[0].appendChild(script); 虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。123456789101112131415161718function loadScript(url, callback) &#123; var script = document.creatElement(\"script\"); script.type = \"text/javascript\"; if(script.readyState) &#123; script.onreadystatechange = function() &#123; if(script.readyState == \"loaded\" || script.readyState == \"complete\") &#123; script.onreadystatechange = null; callback(); &#125; &#125; &#125; else &#123; script.onload = function() &#123; callback(); &#125; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125; 如此就可以通过嵌套调用来保证他们的加载顺序：12345loadScript(\"script1.js\",function() &#123; loadScript(\"script2.js\",function() &#123; alert(\"all files are loaded!\"); &#125;)&#125;) XMLHttpRequest(XHR)对象可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[]},{"title":"网络知识补充——浏览器请求过程","slug":"网络知识补充——浏览器请求过程","date":"2017-08-17T12:49:56.000Z","updated":"2019-05-24T12:07:53.662Z","comments":true,"path":"2017/08/17/网络知识补充——浏览器请求过程/","link":"","permalink":"http://yoursite.com/2017/08/17/网络知识补充——浏览器请求过程/","excerpt":"当我们在浏览器中输入一个url，页面是如何呈现出来的呢？","text":"当我们在浏览器中输入一个url，页面是如何呈现出来的呢？ 当我们在浏览器中输入一个url，页面是如何呈现出来的呢？ 首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。以Chrome浏览器为例，其解析过程： 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效） 读取本地的HOST文件（操作系统的DNS缓存也没有找到） 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求 紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作： 查找本地缓存 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求 将迭代查询后的结果返回给操作系统内核同时进行缓存 之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入Controller层，进行相关的逻辑处理，以及请求的分发，然后来调用Model层，Model层主要负责与数据的交互，在交互过程中会它会读取redis和数据库中存储的数据，最终将渲染好的页面通过View层返回给网络。这时，httpResponse就通过层层网络回到浏览器，浏览器根据请求回来的html、css、js进行渲染，最终将页面展现在我们面前。 DNSDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：http://www.baidu.com/，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。Tip：电脑中的HOST文件是通过静态匹配IP和域名 域名空间结构 根域：.，根域名的服务器只有13台 顶级域（一级域）：edu、gov、com、org、mil、cn等，由域名分配组织ISO决定 组织域 123456gov 政府部门com 商业部门edu 教育部门org 民间团体组织net 网络服务机构mil 军事部门 国家或地区域 12345cn 中国jp 日本uk 英国au 澳大利亚hk 中国香港 二级域：个人和企业向域名分配组织申请的，需要购买，如baidu、sina等 主机名（三级域）：申请完二级域名后自己规定的，如www（代表网页服务）、NEWS 一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。 DNS查询过程 客户机向指定的域名服务器发送请求，说我想要访问www.baidu.com.cn这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（cn）的IP地址，紧接着本地域名服务器就向cn服务器发送询问，cn服务器返回com.cn服务器的IP，然后本地服务器接着询问，直到找到www.baidu.com.cn的IP地址，再返回给客户机。这个过程就是DNS迭代查询。 ISO/OSI 七层模型基本概念 ISO：国际标准化组织 OSI：开放系统互联模型 IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统 OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。 每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。注意点：各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。 为什么要进行分层？ 因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。 传输单位： 比特：bit，机器码的传输单位，每个0或1就是一个比特。 帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。 报文：保存的基本信息为IP地址（负责外网通信）。 TPDU：传输协议数据单元。 APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。 七层详解 物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡） 数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。 网络层：提供逻辑地址（IP）、选路。 传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等） 会话层：对应用会话的管理、同步。 表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。 应用层：用户接口（可以理解为各自桌面应用）。 TCP/IP 四层模型基本概念 网络接口层：与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。 网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）。 应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。 比较 共同点： 都采用了层次结构的概念； 都能够提供面向连接和无连接两种通信服务机制； 不同点： 前者七层模型，后者四层结构； 对可靠性的要求不同（后者更高）； OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。 TCP/IP 通信当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？ 首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。 IP协议IP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是IP地址和MAC地址（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。 APR协议：通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。路由选择：在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。 TCP协议TCP协议位于传输层，提供可靠的字节流服务。其中字节流服务是指，将大块的数据分割成以报文为单位的数据包进行管理。可靠的传输服务是指能够把数据准确可靠的传给对方。 三次握手：为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。 发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 「我给你讲个TCP的笑话吧」 “我给你讲一个TCP的笑话吧？”“给我讲一个TCP笑话呗！”“好的，我会给你讲一个TCP的笑话。” TCP与UDP比较：UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"网络知识","slug":"网络知识","permalink":"http://yoursite.com/tags/网络知识/"}]},{"title":"JS面向对象学习笔记","slug":"JS面向对象学习笔记","date":"2017-08-16T13:20:29.000Z","updated":"2019-05-24T12:15:50.761Z","comments":true,"path":"2017/08/16/JS面向对象学习笔记/","link":"","permalink":"http://yoursite.com/2017/08/16/JS面向对象学习笔记/","excerpt":"面向对象（OOP）的概念对于面向对象，有以下几个概念： 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏","text":"面向对象（OOP）的概念对于面向对象，有以下几个概念： 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 面向对象（OOP）的概念对于面向对象，有以下几个概念： 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 对象有哪些特性？ 封装性：通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。 继承：很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。 多态：多态指的不同类的对象对同一消息作出不同的响应。 面向对象的优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。 JavaScript作为一门面向对象的语言，却并不是通过类来实现面向对象的，而是通过原型（prototype）。那么这两者实现面向对象究竟有什么区别呢？ 基于类vs基于原型基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。 类（class）：定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。 实例（instance）：类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。 123456789101112131415//定义类public class Person &#123; String name; int age; void walking() &#123; &#125; void sleeping() &#123; &#125; Person(x,y) &#123; name = x; age = y; &#125;//类的构造函数&#125;//实例化Person xm = new Person('xm',18); 其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。123456function Person(name,age) &#123; this.name = name; this.age = age;&#125;var xm = new Person('xm',18); new操作符在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的两个步骤 将实例的._proto_指向构造函数的prototype属性。 调用构造函数来初始化实例对象。（call、apply） 原型对象对象不仅仅有自己独特的属性，例如Person，每个Person的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。 在Java中，共用的方法会采用静态的方式用static修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。 而在JS中，则引入了原型对象。原型对象就是构造函数的prototype属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个constructor属性来指向该原型实例的构造函数。 原型链由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的_proto_属性，constructor属性和prototype属性，它们相互指来指去，就形成了一条原型链。 以Person这个构造函数为例，我们创建了它的实例xm，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中_proto_其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。 属性查找当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回undefined。 创建对象 基于Object对象创建 123456var person = new Object();person.name = 'xm';person.age = 18;person.getName = function() &#123; return this.name;&#125; 字面量的方式：清晰的查找对象包含的属性和方法 1234567var person = &#123; name: 'xm', age: 18, getName: function() &#123; return this.name; &#125;&#125; 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。 12345678910functioni createPerson(name,age) &#123; var o = new Object(); o.name = name; o.age = age; o.getName = function() &#123; return this.name; &#125; return o;&#125;var person = createPerson('xm',18); 构造函数模式 12345678function Person(name,age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;var person = new Person('xm',18); Object.create(prototype, descriptors)：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数prototype。参数说明：prototype：必需。要用作原型的对象，可以为null。descriptors：可选。包含一个或多个属性描述符的JavaScript对象。 12var var obj = Object.create(&#123;x:1&#125;);obj.hasOwnProperty('x');//false","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS变量、作用域和内存问题","slug":"JS变量、作用域和内存问题","date":"2017-08-15T12:30:52.000Z","updated":"2019-05-24T12:16:04.357Z","comments":true,"path":"2017/08/15/JS变量、作用域和内存问题/","link":"","permalink":"http://yoursite.com/2017/08/15/JS变量、作用域和内存问题/","excerpt":"变量数据类型在JavaScript中，数据类型分为基本类型和引用类型。 基本类型：数字，字符，布尔值，undefined，null 引用类型：数组，对象，函数 区别：基本类型的值是可以修改的，而引用类型的值不可修改","text":"变量数据类型在JavaScript中，数据类型分为基本类型和引用类型。 基本类型：数字，字符，布尔值，undefined，null 引用类型：数组，对象，函数 区别：基本类型的值是可以修改的，而引用类型的值不可修改 变量数据类型在JavaScript中，数据类型分为基本类型和引用类型。 基本类型：数字，字符，布尔值，undefined，null 引用类型：数组，对象，函数 区别：基本类型的值是可以修改的，而引用类型的值不可修改12345678//eg1var num = 4;num = 3; //这里的值操作并不是修改，而是覆盖//eg2var str = 'string';var anotherStr = str.replace('s',''); //字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr 基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是Number，字符的包装对象是String。包装对象包含了这个类型的属性和方法。 堆栈在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。 因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。 变量的比较123456789101112131415//基本类型的比较var xmScore = 4;var xhScore =4;console.log(xmScore === xhScore) //true//引用类型的比较var xm = &#123; age: 18, score: 4&#125;;var xh = &#123; age: 18, score: 4&#125;;console.log(xm === xh); //false 在引用类型中，只有指向同一个引用，变量才是相等的。 123456var xm = &#123; age: 18, score: 4&#125;;var xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用console.log(xm === xh); //true; 那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。1234567891011121314function equalObjs(a,b) &#123; for(var p in a) &#123; if(a[p] !== b[p] return false; &#125; return true;&#125;function equalArrays(a,b) &#123; if(a.length !== b.length) return false; for(var i = 0; i &lt; a.length; i ++) &#123; if(a[i] !== b[i]) return false; &#125; return true;&#125; 变量的复制当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。1234567function copyObj(obj) &#123; var newObj = &#123;&#125;; for(var p in obj) &#123; newObj[p] = obj[p]; &#125; return newObj;&#125; 以上的方法便是浅拷贝，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。 $.extend(deep,target,object1,objectN)参数说明：deep：可选。布尔值。指是否深度合并对象，默认false。target：目标对象，其他对象的成员属性将被附加到该对象上。object1：可选。指第一个被合并的对象。objectN：可选。指第N个被合并的对象。 参数传递1234function fn(a,b) &#123; return a + b;&#125; // 在函数里声明的a与b是形参fn(1,2); //在调用函数时传入的参数是实参 当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。123456789101112131415//eg1 当变量为基本类型时function addTen(num) &#123; return num + 10;&#125;var score = 10;addTen(score);//相当于num = score;//eg2 当变量为引用类型时function setName(obj) &#123; return obj.name = 'xm';&#125;var person = &#123;&#125;;setName(person); 当传递的参数是引用类型时，也相当于obj = person，因为引用类型赋值时是对地址进行复制的，所以obj与person实际上指向的都是同一个引用，所以我们对obj的修改也能反应到person上。 类型检测typeof：返回字符串类型。可以区分基本类型，但是无法区分引用类型（null，对象和数组返回的都是object）。instanceof：用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法[] instanceof Array。 作用域 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量 全局与局部在JS中，变量的作用域分为两种：全局变量和局部变量全局变量的声明方式有两种：1234var n = 999; //直接在外部声明function f1() &#123; i = 888; //在函数内部声明，但是不适用var命令&#125; 全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用{}包含的域。在其他语言，例如C++，if和for中声明的变量在外部也是无法访问到的。但是JS中，在if和for中声明的变量在整个函数内部都可以访问。1234for(var i = 0; i &lt; 10; i ++) &#123; &#125;//等同于var i = 0;for(i &lt; 10; i ++) &#123; &#125; 变量的作用域链123456789var name = 'xm';funuction fn(argument) &#123; var name = 'xh'; var sex = 'male'; function fn2(argument) &#123; var name = 'xhei'; var age = 18; &#125;&#125; 所有全局空间中的属性和方法，都是属于window的（window.name = &#39;xm&#39;;）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（fn.sex与fn.fn2不存在）。作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。作用链： 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。 延长作用域链 1234567891011121314var person = &#123;&#125;;person.name = 'xm';person.sex = 'male';var score = 4;with(person) &#123; name = 'xh'; sex = 'female'; score = 44;&#125;console.log(person.name); //xhconsole.log(person.sex); //femaleconsole.log(score); //44 使用with的时候，当修改name与sex时，此时查找的作用域是person，但是person中并不存在score这个属性，于是with就随着作用域链查找到window下的score，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。 闭包 在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。12345678910function f1() &#123; var n = 999; function f2() &#123; alert(n); //999 &#125; return f2; //将f2作为返回值&#125;var result = f1();result(); //999 以上代码中的f2函数就是闭包，也就是闭包可以理解为“定义在一个函数内部的函数”。 闭包的两个用途： 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。 将某些变量的值始终保持在内存中。（JS的垃圾回收机制） JS解析机制-预解析JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。12345678var name = 'xm';var age = 18;function fn(argument) &#123; console.log(name); var name = 'xh'; var age = 10;&#125;fn(); //undefined 就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的var找出来，并且将所有的变量都赋值为undefined。然后查找该域中的function，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是undefined。123456789101112131415161718192021//window域预解析var name = undefiied;var age = undefined;function fn(argument) &#123; console.log(name); var name = 'xh'; var age = 10;&#125;//fn域预解析var name = undefined;var age = undefined;//逐行解析name = 'xm';age = 18;fn(argument) &#123; console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined name = 'xh'; age = 10;&#125; 在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。12console.log(a);a = 1; //预解析不解析没有var的变量，所以浏览器会报错 内存垃圾回收机制垃圾回收机制：释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。标识无用数据的策略： 标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。环境中的变量指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。 引用计数：引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。 循环引用问题： 1234567891011121314151617function fn(argument) &#123; var xm = &#123;&#125;; //1 var xh = &#123;&#125;; //1&#125;fun();xm = null; //0xh = null; //0functioni fn(argument) &#123; var xm = &#123;&#125;; //1 var xh = &#123;&#125;; //1 xm.wife = xh; //2 xh.husband = xm; //2&#125;fn();xm = null; //1xh = null; //1 由于xm与xh相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。 管理内存为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为null。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"异步编程之promise与trigger","slug":"异步编程之promise与trigger","date":"2017-07-15T08:13:01.000Z","updated":"2019-05-24T12:08:50.309Z","comments":true,"path":"2017/07/15/异步编程之promise与trigger/","link":"","permalink":"http://yoursite.com/2017/07/15/异步编程之promise与trigger/","excerpt":"这周的学习任务：promise与trigger 异步编程 Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。","text":"这周的学习任务：promise与trigger 异步编程 Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 这周的学习任务：promise与trigger 异步编程 Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 实现异步编程的四种方法 回调函数 回调函数可以理解为，被另一个函数调用的函数。可以想成这样一个应用场景：123f1(); //一个十分耗时的函数f2(); //等待f1执行完才能执行的函数f3(); //等待f1执行完才能执行的函数 Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是f1-&gt;f2-&gt;f3，但如果f3是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待f1与f2都执行完才能执行，这就导致了页面加载时间过长，体验很不好。1234567function f1(callback) &#123; //f1执行代码 callback();&#125;f1(f2);f3(); 如果采用回调函数的方法（异步），函数的执行顺序就可以变成f1-&gt;f3-&gt;f2，加载时间就节省了f2执行的时间，也算是一点优化了。优点： 简单、容易理解和部署。缺点： 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听 事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如click、keydown之类的，可以通过on来绑定。1f1.on('click',f2); //在发送点击事件之后，会执行f2函数 而trigger的作用是，可以通过$.Event(&#39;eventName&#39;)来自定义一个事件，然后通过trigger触发这个事件。123456789var $null = $(&#123;&#125;); //绑定空对象var hideEvent = $.Event('hide.tab');function f1() &#123; //f1执行代码 f1.trigger('hide.tab');&#125;$null.on('hide.tab',f2); 当f1执行完后就会触发hide.tab事件，从而开始执行f2。而且这个自定义的事件可以通过trigger绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用trigger来触发事件，然后通过事件绑定调用子函数的方法。优点： 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。缺点： 整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布/订阅 发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。实现步骤如下：12345678jQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号function f1() &#123; //f1执行代码 jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行&#125;jQuery.unsubscribe('done',f2); //取消订阅 优点： 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 deferred对象 deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。12345678f1().then(f2);function f1()&#123; var dfd = $.Deferred(); // f1的任务代码 dfd.resolve(); return dfd.promise;&#125; 优点： 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。 deferred对象详解deferred对象的应用场景 让异步操作代码像同步代码那样书写和阅读，流程更加清晰 优化ajax的嵌套执行 原本我们在执行ajax的时候，如果这个请求中还有ajax请求，就会有以下这种写法：1234567891011$.ajax(&#123; url: \"test.html\", success: function() &#123; $.ajax(&#123; url: ..., success: function() &#123; .... &#125; &#125;); &#125;&#125;); 我们可以将两个ajax分开封装1234567891011121314151617function A() &#123; return $.ajax(&#123; url: \"test.html\", ... &#125;);&#125;function B() &#123; return $.ajax(&#123; url: \"...\", ... &#125;);&#125;$.when(A(),B()).then(function() &#123; dosth();&#125;); 方法总结 $.Deferred()：生成一个deferred对象 deferred.done()：指定操作成功时的回调函数 deferred.fail()：指定操作失败时的回调函数 deferred.promise()：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。 deferred.resolve()：手动改变deferred对象的运行状态为“已完成”，从而立即触发done()方法 deferred.reject()：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法 $.when()：为多个操作指定回调函数。当所有操作都成功时执行done() deferred.then()：有时为了省事，可以把done()和fail()合在一起写，这就是then()方法","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"}]},{"title":"搭建Hexo博客之后","slug":"搭建Hexo博客之后","date":"2017-07-15T06:59:11.000Z","updated":"2019-05-26T06:29:15.635Z","comments":true,"path":"2017/07/15/搭建Hexo博客之后/","link":"","permalink":"http://yoursite.com/2017/07/15/搭建Hexo博客之后/","excerpt":"这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。恩，然后找到了方法，然而感觉讲的太！不！清！楚！折腾了半天，终于弄好了，以下整理了一下步骤：","text":"这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。恩，然后找到了方法，然而感觉讲的太！不！清！楚！折腾了半天，终于弄好了，以下整理了一下步骤： 这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。恩，然后找到了方法，然而感觉讲的太！不！清！楚！折腾了半天，终于弄好了，以下整理了一下步骤： 使用分支方法解决hexo博客无法在两台电脑上更新的问题创建本地仓库首先，创建一个新的文件夹，和github上的仓库同名：username.github.io然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令123456$ touch README.md$ git init $ git add README.md$ git commit -m &quot;first commit&quot;$ git remote add origin 你的项目地址$ git push -u origin master 在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决12$ git pull --rebase origin master$ git push -u origin master 这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~ 创建hexo分支12$ git branch hexo$ git push origin hexo 这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~ 在hexo分支中安装hexo1234$ git checkout hexo$ npm install hexo$ hexo init$ npm install 这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上原文中提供的安装方法好像不管用，重新找了个名字叫hexo-git-backup安装指令：1$ npm install hexo-git-backup --save 配置_config.yml文件打开_config.yml文件，拉到最下，我们需要改动一些东西1234567891011deploy: type: git #部署类型，使用github repository: #你的项目地址 branch: master #部署分支，必须是master message: update #默认类型#我们还需要添加那个插件的功能backup: type: git repository: github: 项目地址,hexo #将这个本地仓库更新到hexo分支 然后我们在执行一下指令123$ hexo g $ hexo d //部署博客$ hexo b //将hexo文件中的更改提交到hexo分支 然后，事情就完美的解决啦~~ 更换电脑后的操作 使用git clone将远程仓库克隆到本地 在本地的仓库执行npm install hexo、npm install、npm install hexo-git-backup --save，就完成了更换电脑更新的操作啦（记得，不需要hexo init这条指令）。","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"JS之this指针笔记","slug":"JS之this指针笔记","date":"2017-07-08T05:48:43.000Z","updated":"2019-05-24T12:16:09.833Z","comments":true,"path":"2017/07/08/JS之this指针笔记/","link":"","permalink":"http://yoursite.com/2017/07/08/JS之this指针笔记/","excerpt":"this指针 this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。","text":"this指针 this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 this指针 this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 定义在全局中的函数 1234function test() &#123; this.x = 1; //此处的this指的是window&#125;x = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的 作为对象方法的调用 12345678function test() &#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); //1 作为构造函数调用 12345var o = &#123; test: function () &#123; this.x = 1; &#125; //这是定义在对象中的函数，而此时this指的是对象o&#125; this指向的改变12345678var o = &#123; test: function () &#123; //在构造函数的时候也会调用其他的函数，所以this的指向就会变 $(this.xx).on(\"click\",function()&#123; //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了 &#125;) &#125; &#125; 在javascript中有几个函数是可以改变this的指向的1234567891011121314var xm = &#123; name: \"小明\", sex: \"男\", age: \"18\", say: function() &#123; alert(this.name + \",\" + this.sex + \",\" + this.age); &#125;&#125;var xh = &#123; name: \"小红\", sex: \"女\", age: \"20\"&#125; apply(thisObj,[argArray])参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）定义：应用某一对象的一个方法，用另一个对象替换当前对象 1xm.say.apply(xh); //小红,女,20 call(thisObj,arg1,arg2...)参数：替换目标对象，需要的参数arg1,arg2…定义：应用某一对象的一个方法，用另一个对象替换当前对象 1xm.say.call(xh); //小红,女,20 bind(thisObj)(arg1,arg2...)参数：替换目标对象，需要的参数arg1,arg2…定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持） 1xm.say.bind(xh)(); //小红,女,20 $.proxy(fn,context)参数：函数，函数所在的对象的名称定义：用于向上下文指向不同对象的元素添加事件。 123456789101112test = function() &#123; this.txt = \"这是一个对象属性\"; $(\"div\").click($.proxy(this.myClick,this)); //本来调用click的话，this会指向div，但是使用$.proxy后this还是test&#125;;test.prototype.myClick = function(event) &#123; alert(this.txt); alert(event.currentTarget.nodeName);&#125;;var x = new test();","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS继承笔记","slug":"JS继承笔记","date":"2017-07-07T14:02:11.000Z","updated":"2019-05-24T12:15:56.227Z","comments":true,"path":"2017/07/07/JS继承笔记/","link":"","permalink":"http://yoursite.com/2017/07/07/JS继承笔记/","excerpt":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。 看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。","text":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。 看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。 在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。 看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。 在以上基础下，得出了几种继承方法：12345678910//现有两个构造函数function Animal() &#123; this.species = \"动物\";&#125;function Cat(name,color) &#123; this.name = name; this.color = color;&#125; 构造函数的继承 构造函数绑定：使用call或apply方法，将父对象的构造函数绑定在子对象上 1234567function Cat(name,color) &#123; Animal.apply(this.arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); //动物 prototype模式：将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了 123456Cat.prototype = new Animal();Cat.prototype.constructor = Cat;//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal//但是constructor是必须指向其构造函数的，所以要修正成Catvar cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); //动物 直接继承prototype：由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 12345funtion Animal() &#123;&#125;Animal.prototype.species = \"动物\";Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat; 此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。 利用空对象作中介：（重点方法） 1234var F = function() &#123;&#125;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; 可以将此方法封装为一个函数 1234567function extend(child,parent) &#123; var temp = function() &#123;&#125;; temp.prototype = parent.prototype; child.prototype = new temp(); child.prototype.constructor = child; child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质&#125;","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript正则表达式","slug":"JavaScript正则表达式","date":"2017-04-21T07:22:18.000Z","updated":"2019-05-24T12:15:39.029Z","comments":true,"path":"2017/04/21/JavaScript正则表达式/","link":"","permalink":"http://yoursite.com/2017/04/21/JavaScript正则表达式/","excerpt":"正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。 正则表达式的定义 一种是使用正则表达式直接量，将其包含在一对斜杠/之间的字符 1var pattern = /s$/; 另一种是使用RegExp()构造函数 1var pattern = new RegExp('s'); 上面两种表达方式是等价的，用来匹配所有以s结尾的字符串正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的","text":"正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。 正则表达式的定义 一种是使用正则表达式直接量，将其包含在一对斜杠/之间的字符 1var pattern = /s$/; 另一种是使用RegExp()构造函数 1var pattern = new RegExp('s'); 上面两种表达方式是等价的，用来匹配所有以s结尾的字符串正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的 正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。 正则表达式的定义 一种是使用正则表达式直接量，将其包含在一对斜杠/之间的字符 1var pattern = /s$/; 另一种是使用RegExp()构造函数 1var pattern = new RegExp('s'); 上面两种表达方式是等价的，用来匹配所有以s结尾的字符串正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的 直接量字符非字母的字符匹配，通过\\反斜杠作为前缀转义12345678910\\0 匹配null字符(\\u0000)[\\b] 匹配退格符(\\u0008)，区别\\b\\t 匹配制表符tab(\\u0009)\\n 匹配换行符(\\u000A)\\v 匹配垂直制表符(\\u000B)\\f 匹配换页符(\\u000C)\\r 匹配回车键(\\u000D)\\xnn 匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\\uxxxx 匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\\cX 表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符 字符类12345678910[...] 匹配方括号内的任意字符[^...] 匹配除方括号内的以外的任意字符. 除换行符和其他Unicode行终止符之外的任意字符- 匹配范围，如[a-z]表示所有的小写字母\\w 任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\\W 任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\\s 任何Unicode空白符\\S 任何非Unicode空白符的字符\\d 任何非ASCII数字，等价于[0-9]\\D 除了ASCII数字之外的任何字符，等价于[^0-9] 重复123456&#123;n,m&#125; 匹配前一项至少n次，至多m次&#123;n,&#125; 匹配前一项至少n次，次数可能比n大&#123;n&#125; 匹配前一项n次? 匹配前一项0次或者1次，等价于&#123;0,1&#125;+ 匹配前一项1次或者更多次，等价于&#123;1,&#125;* 匹配前一项0次或者更多次，等价于&#123;0,&#125; 注意：因为可以匹配0次，所以正在表达式/a/实际上与字符bbb匹配，因为这个字符串含0个a 非贪婪的重复默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为贪婪的匹配而非贪婪的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可123//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组var a = /a+/.exec('aaa'); //[\"aaa\"]var b = /a+?/.exec('aaa'); //[\"a\"] 选择、分组和引用1234| 分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef 并且，如果匹配了ab就不会再往后匹配(...) 把单独的项组合成子表达式\\n 引用第n个带括号的子表达式 123//test() 方法用于检测一个字符串是否匹配某个模式//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 falsevar bool = /(.)b(.)\\1b\\2/.test('abcabc') //true 上面的代码中，\\1表示第一个括号匹配的内容，即第一个(.)，匹配的是&#39;a&#39;；\\2表示第二个括号(.)，匹配的是&#39;c&#39; 因为子表达式可以嵌套，所以(s(ss))的\\2所表示的是(ss) 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用 123var res1 = /(a|b)c\\1/.test('aca'); //truevar res2 = /(a|b)c\\1/.test('acb'); //false//'(a|b)'匹配了a之后，'\\1'也代表a 指定匹配边界123456^ 匹配字符串的开头，在多行检索中，匹配一行的开头$ 匹配字符串的结尾，在多行检索中，匹配一行的结尾\\b 匹配一个单词的边界\\B 匹配非单词边界的位置(?=p) 零宽正向先行断言，要求接下来的字符都与p匹配(?!p) 零宽负向先行断言，要求接下来的字符不与p匹配 修饰符1234i 执行不区分大小写的匹配g 执行一个全局匹配，找到所有的匹配而不是找到一个后就停止m 多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配 整个字符串的开始和结尾之外，还能匹配每行的开始和结尾 1var x = /test/ig 用于模式匹配的String方法 search：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1 1\"javascript\".search(/script/i); //4 match：返回一个数组，成员是所有匹配的子字符串，该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 1\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"] replace：按照给定的正则表达式进行替换，返回替换后的字符串 12345第二个参数：$` 指代匹配结果前面的文本$&apos; 指代匹配结果后面的文本$n 指代匹配成功后的第n组内容，n从1开始$$ 指代美元符号$ 1\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\" split：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员 1\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"] RegExp对象构造函数带有两个参数，第二个参数是可选的1var regexp = new RegExp('\\\\d&#123;5&#125;','g'); //全局查找5个数字 包含5个属性： source：只读字符串，包含正则表达式的文本 global：只读布尔值，用以说明这个正则表达式是否带有修饰符g ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i multiline：只读布尔值，用以说明正则表达式是否带有修饰符m lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置 RegExp方法 exec：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null test：返回一个布尔值，表示当前模式是否能匹配参数字符串","categories":[{"name":"JS相关","slug":"JS相关","permalink":"http://yoursite.com/categories/JS相关/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"iconfont使用方法","slug":"iconfont使用方法","date":"2017-03-26T01:12:56.000Z","updated":"2019-05-24T12:09:40.633Z","comments":true,"path":"2017/03/26/iconfont使用方法/","link":"","permalink":"http://yoursite.com/2017/03/26/iconfont使用方法/","excerpt":"实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程 首先在Iconfont-阿里巴巴矢量图标库上将需要的图标点击购物车按钮加入暂存库。","text":"实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程 首先在Iconfont-阿里巴巴矢量图标库上将需要的图标点击购物车按钮加入暂存库。 实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程 首先在Iconfont-阿里巴巴矢量图标库上将需要的图标点击购物车按钮加入暂存库。 选择所有要用的图标后，存储为项目，给它命名。然后在图标管理-图标应用项目中找到这个项目，获取在线连接，把里面的代码复制到CSS中。 在HTML中需要使用到图标时，使用iconfont类名。1&lt;i class=\"iconfont\"&gt;&amp;#xe600;&lt;/i&gt; 里面写上你想用的图标下面的Unicode： 可以通过控制iconfont类的属性改变图标的样式：123456789.iconfont&#123; font-family:\"iconfont\"; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale; padding-left:20px&#125; 也可以下载到本地使用。图标都加入暂存架后选择下载到本地，会得到以下几个文件：浏览器打开demo.html可以看到每个图标的Unicode，把iconfont.css里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。 作者：班星灿链接：https://www.zhihu.com/question/25952487/answer/71917554来源：知乎","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"iconfont","slug":"iconfont","permalink":"http://yoursite.com/tags/iconfont/"}]},{"title":"JSON学习笔记","slug":"JSON学习笔记","date":"2017-03-21T10:16:43.000Z","updated":"2019-05-24T12:16:31.125Z","comments":true,"path":"2017/03/21/JSON学习笔记/","link":"","permalink":"http://yoursite.com/2017/03/21/JSON学习笔记/","excerpt":"JSON = JavaScript Object Notation （JavaScript对象表示法）JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行","text":"JSON = JavaScript Object Notation （JavaScript对象表示法）JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行 JSON = JavaScript Object Notation （JavaScript对象表示法）JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行 与XML比较 长度比xml短 读写速度更快 json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便 语法规则 JSON数据的书写格式：名称/值对名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如&quot;name&quot;:&quot;jane&quot; 可以使用的数据类型 数字（整数或浮点数） 字符串（双引号） 逻辑值（true or false） 数组（ […] ） 对象（ {…} ） null JSON解析 eval和JSON.parse 尽可能使用JSON.parse()方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。 12345var jsondata = '&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;';var jsonobj = JSON.parse(jsondata);//解析完毕alert(jsonobj.staff[0].name);//直接对对象进行操作 tip： JSON.stringify()方法是将对象解析成JSON 12var a = &#123;a:1,b:2&#125;JSON.stringify(a) //\"&#123;\"a\":1,\"b\":2&#125;\"","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"AJAX学习笔记","slug":"AJAX学习笔记","date":"2017-03-21T08:21:19.000Z","updated":"2019-05-24T12:17:44.540Z","comments":true,"path":"2017/03/21/AJAX学习笔记/","link":"","permalink":"http://yoursite.com/2017/03/21/AJAX学习笔记/","excerpt":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）","text":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行） AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行） 实现 实现页面 运用XMLHttpRequest和web服务器进行数据的异步交换 运用javascript操作DOM，实现动态局部刷新 创建ajax过程 创建XMLHttpRequest对象 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 使用Javascript和DOM实现局部刷新 XHR 发送请求 open(method,url,async)method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false） send(string)GET请求参数可不填写或写none，用POST请求需要填写。123456789var request = new XMLHttpRequest(); //创建XHR对象request.open(\"GET\",\"get.php\",true);request.send();//创建信息request.open(\"POST\",\"post.php\",true);request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");//头信息，提示服务器要发送一个表单request.send(\"name=tom&amp;sex=man\"); 响应请求 responseText：获得字符串形式的响应数据 responseXML：获得XML形式的响应数据（XML交互较少，一般采用json） status&amp;statusText：以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 监听服务器响应readyState属性： 代表服务器响应的变化 0：请求未初始化，open还没有调用 1：服务器连接已经建立，open已经调用 2：请求已接收，也就是接收到头信息了 3：请求处理中，也就是接收到响应主体了 4：请求已完成，且响应已就绪（完成）12345678var request = new XMLHttpRequest();request.open(\"GET\",\"get.php\",true);request.send();request.onreadystatechange = function() &#123; if(request.readyState === 4 &amp;&amp; request.status === 200)&#123; //request.responseText... &#125;&#125; 用jQuery实现AJAX jQuery.ajax([settings]) type：类型，“POST”或“GET”,默认”GET” url：发送请求的地址 data：是一个对象，连同请求发送到服务器的数据 dataType：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用json格式，可以设置为“json” success：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串 error：是一个方法，请求失败时调用此函数。传入XHR对象1234567891011121314151617181920212223242526272829$.ajax(&#123; type:\"GET\", url:\"get.php\", dataType:\"json\", success:function(data)&#123; //成功后的操作 &#125;, error:function(jqXHR)&#123; alert(\"error:\"+jqXHR.status); &#125;&#125;)$.ajax(&#123; type:\"POST\", url:\"get.php\", dataType:\"json\", data:&#123; name:123 number:123 //jquery可以自动将Form Data转换成name:123&amp;number:123这种格式 //并自动设置Content-Type:application/x-www-form-urlencoded &#125;, success:function(data)&#123; //成功后的操作 &#125;, error:function(jqXHR)&#123; alert(\"error:\"+jqXHR.status); &#125;&#125;) 跨域 一个域名地址的组成：http://www.abc.com:8080/scripts/jquery.js 协议：http:// 子域名：www 主域名：abc.com 端口号：8080（默认8080，可以省略） 请求资源地址：scripts/jquery.js 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域 不同域之间相互请求资源，算作“跨域”比如：http://www.abc.com/index.html 请求 http://www.efg.com/service.php JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象 处理跨域的方法 代理通过在同域名的web服务器端创建一个代理：北京服务器：www.beijing.com上海服务器：www.shanghai.com在北京的web服务器的后台www.beijing.com/proxy-shanghaiservice.php来调用www.shanghai.com/service.php的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了 JSONPJSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充） 12345678910在www.aaa.com中 &lt;script&gt; function jsonp(json)&#123; alert(json[\"name\"]); &#125; &lt;/script&gt; &lt;script src=\"http://www.bbb.com/jsonp.js\"&gt;&lt;/script&gt; 在www.bbb.com中 jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;); 12345678910111213//jsonp只支持get请求$.ajax(&#123; type:\"GET\", url:\"http://www.bbb.com/service.php\", dataType:\"jsonp\", jsonp:\"callback\",//取值任意，与后端相连接 success:function(data)&#123; //成功后的操作 &#125;, error:function(jqXHR)&#123; alert(\"error:\"+jqXHR.status); &#125;&#125;) XHR2HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）在服务器端做一些小改造即可：header(&#39;Access-Control-Allow-Origin:*&#39;);header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"关于HTTP请求小记","slug":"关于HTTP请求小记","date":"2017-03-20T07:31:38.000Z","updated":"2019-05-24T12:19:24.061Z","comments":true,"path":"2017/03/20/关于HTTP请求小记/","link":"","permalink":"http://yoursite.com/2017/03/20/关于HTTP请求小记/","excerpt":"HTTP： 是计算机通过网络进行通信的规则 步骤： 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接","text":"HTTP： 是计算机通过网络进行通信的规则 步骤： 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 HTTP： 是计算机通过网络进行通信的规则 步骤： 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 组成： HTTP请求的方法或动作，比如是GET还是POST请求 正在请求的URL 请求头，包含一些客户端环境信息，身份验证信息等 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等123456789101112131415GET /login.php HTTP/1.1 //请求地址//请求头Host:localhostConnection:keep-aliveAccept:text/javascript,application/javascript,application/ecmascript,application/x-ecmascript,*/*;q=0.01X-Requested-With:XMLHttpRequestUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/Accept-Encoding:gzip,deflate,sdchAccept-Language:zh-CN,zh;q=0.8,en;q=0.6//请求体username=admin&amp;password=123456 GET： 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的） POST： 一般用于修改服务器上的资源。对所发送信息的数量无限制。 GET和POST的区别： GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 HTTP响应组成： 一个数字和文字组成的状态码，用来显示请求是成功还是失败的 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等 响应体（响应正文），服务器传来的字符串或html代码等1234567HTTP/1.1 200 OKDate:Sun,23 Nov 2014 10:14:45 GMTServer:ApacheContent-Encoding:gzipContent-Length:7112Connection:Keep-AliveContent-Type:application/javascript HTTP状态码： 由3位数字构成，其中首位数字定义了状态码的类型 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500 HTTP状态码（具体）： 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置 302 Found 临时性重定向 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI 304 Not Modified 自从上次请求后，请求的网页未修改过 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求 401 Unauthorized 请求未授权 403 Forbidden 禁止访问 404 Not Found 找不到如何与 URI 相匹配的资源 500 Internal Server Error 最常见的服务器端错误 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）","categories":[{"name":"知识碎片","slug":"知识碎片","permalink":"http://yoursite.com/categories/知识碎片/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]}]}