<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yx1aoq1&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-19T05:24:20.470Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yx1aoq1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue.js学习笔记（02）</title>
    <link href="http://yoursite.com/2018/07/25/18-07-25-32/"/>
    <id>http://yoursite.com/2018/07/25/18-07-25-32/</id>
    <published>2018-07-25T12:13:45.000Z</published>
    <updated>2018-08-19T05:24:20.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue实例化输入的选项对象基本介绍"><a href="#Vue实例化输入的选项对象基本介绍" class="headerlink" title="Vue实例化输入的选项对象基本介绍"></a>Vue实例化输入的选项对象<a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="external">基本介绍</a></h2><p>当我们<code>new</code>一个Vue实例的时候，包含了如下几个基本的属性：</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p><strong>作用：</strong>声明双向绑定的数据，可以是对象或者函数，<strong>当定义组件的时候，<code>data</code>只能是函数</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>hello, &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'xiaoming'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><strong>作用：</strong>用于接受来自父组件的数据，对象允许配置高级选项，如类型检测<code>type</code>，自定义校验<code>require validator</code>，默认值<code>default</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"my Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: [<span class="string">'title'</span>],</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式</span></div></pre></td></tr></table></figure>
<p>▼ <strong>设置默认和校验</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'bkog-post'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: &#123;</div><div class="line">    <span class="attr">title</span>: &#123;</div><div class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</div><div class="line">      <span class="attr">default</span>: <span class="string">'title'</span>,</div><div class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value != <span class="string">'abc'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h3><p><strong>作用：</strong>创建实例时传递<code>props</code>，主要作用是方便测试。基本上，没有用过</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p><strong>作用：</strong>用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    aDouble () &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p><strong>作用：</strong>用来定义实例的一些处理方法，如绑定的事件等。<strong>注意，在<code>methods</code>不能使用箭头函数来定义函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    plus () &#123;</div><div class="line">      <span class="keyword">this</span>.a ++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><strong>作用：</strong>用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。<strong>同样，不能使用箭头函数来定义函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>， c: <span class="number">3</span> &#125;,</div><div class="line">  <span class="attr">watch</span>: &#123;</div><div class="line">    a (curVal, oldVal) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`new: %s, old: %s`</span>, curVal, oldVal)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">b</span>: <span class="string">'someMethod'</span>, <span class="comment">// 这里的someMehod是对应的处理函数的名字</span></div><div class="line">    c: &#123;</div><div class="line">      <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">curVal, oldVal</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">      <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">//深度 watcher，为了发现对象内部值的变化</span></div><div class="line">      immediate: <span class="literal">true</span> <span class="comment">// 立即以表达式的当前值触发回调</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p>
<h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例创建前，此时无法访问到<code>el</code>属性和<code>data</code>属性</p>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>实例创建完成，属性已经绑定，但是DOM还未生成，<code>el</code>属性还无法访问</p>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>模板编译/挂在之前，<strong>只有绑定了<code>el</code>属性，才会执行到这里，否则到<code>created</code>就已经停止生命周期</strong></p>
<p>▼ <strong>关于模板编译的顺序</strong></p>
<ul>
<li>当实例对象中有<code>template</code>参数的时候，则将其作为模板编译成<code>render</code>函数</li>
<li>如果没有<code>template</code>参数时，则将外部HTML作为模板编译</li>
<li>在Vue对象中还有一个<code>render</code>函数，它是以<code>createElement</code>作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于<code>template</code>与<code>outer HTML</code></li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>模板编译/挂在之后，<strong>此时data数据绑定在页面上是以虚拟DOM的形式存在的</strong></p>
<h3 id="beforeUpdate-amp-amp-updated"><a href="#beforeUpdate-amp-amp-updated" class="headerlink" title="beforeUpdate &amp;&amp; updated"></a>beforeUpdate &amp;&amp; updated</h3><p>data数据更新之前 &amp;&amp; 更新之后，组件重新渲染</p>
<h3 id="beforeDestroy-amp-amp-destroyed"><a href="#beforeDestroy-amp-amp-destroyed" class="headerlink" title="beforeDestroy &amp;&amp; destroyed"></a>beforeDestroy &amp;&amp; destroyed</h3><p>实例销毁之前 &amp;&amp; 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue实例化输入的选项对象基本介绍&quot;&gt;&lt;a href=&quot;#Vue实例化输入的选项对象基本介绍&quot; class=&quot;headerlink&quot; title=&quot;Vue实例化输入的选项对象基本介绍&quot;&gt;&lt;/a&gt;Vue实例化输入的选项对象&lt;a href=&quot;https://cn.vu
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="Vue生命周期" scheme="http://yoursite.com/tags/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>ES6 核心向新特性（03）</title>
    <link href="http://yoursite.com/2018/03/09/18-03-09-31/"/>
    <id>http://yoursite.com/2018/03/09/18-03-09-31/</id>
    <published>2018-03-09T10:11:10.000Z</published>
    <updated>2018-03-10T07:11:34.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>通常 Promise 的状态有三种：Fulfilled 状态表示执行成功；Rejected 状态表示执行失败；Pending 状态表示正在执行中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> status = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(status === <span class="number">1</span>) &#123;</div><div class="line">    resolve(<span class="string">'Fulfilled'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(<span class="string">'Rejected'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">Promise</span>.then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'success1:'</span> + msg);</div><div class="line">  <span class="keyword">return</span> msg;</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fail1:'</span> + msg);</div><div class="line">  <span class="keyword">return</span> msg;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'success2:'</span> + msg);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fail2:'</span> + msg);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// success1: Fulfilled</span></div><div class="line"><span class="comment">// success2: Fulfilled</span></div></pre></td></tr></table></figure></p>
<p>promise 的 then 方法接受两个处理函数，当 status 为 1 时执行 Fulfilled 成功调用，否则 Rejected 失败调用。返回的状态给第二个 then 方法处理。then 方法可以将传入参数的返回值一直传递下去，如果是异步的场景，就可以用这种方式来解决多层回调嵌套的问题了。</p>
<h3 id="用-promise-处理异步场景"><a href="#用-promise-处理异步场景" class="headerlink" title="用 promise 处理异步场景"></a>用 promise 处理异步场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 希望它依次异步输出 A B C D</span></div><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'A'</span>);</div><div class="line">    resolve();</div><div class="line">  &#125;, <span class="number">3000</span>); <span class="comment">// 延迟3秒打印A</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 使用 then 来链式处理流程</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'B'</span>);</div><div class="line">      resolve();</div><div class="line">    &#125;, <span class="number">2000</span>); <span class="comment">// 延迟2秒打印B</span></div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'C'</span>);</div><div class="line">      resolve();</div><div class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 延迟1秒打印C</span></div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'D'</span>);  <span class="comment">// 不延迟打印D</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过在不同的 then 处理方法中返回一个新的 promise 来解决。返回新的 promise 里面具有<code>resolve()</code>和<code>reject()</code>方法，只有当它的 resolve 或 reject 被调用时，promise 方法才会继续执行，进入下一个 then 方法中操作。设置在异步函数完成的最后调用<code>resolve()</code>就可以有效控制 promise 进入下一个 then 方法执行。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是除布尔值、数值等六种数据类型外的第七种数据类型。属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">let</span> family = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line">object[name] = <span class="string">'ouven'</span>;</div><div class="line">object[family] = <span class="string">'zhang'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(object);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   Symbol(): 'ouven',</span></div><div class="line"><span class="comment">//   Symbol(): 'zhang',</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">// symbol</span></div></pre></td></tr></table></figure></p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 可以用来拦截某个对象的属性访问方法，然后重载对象的<code>.</code>运算符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 赋值或定义值都会输出</span></div><div class="line"><span class="comment">// getting value</span></div><div class="line"><span class="comment">// setting value</span></div><div class="line">object[<span class="string">'value'</span>] = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。<br>▼ <strong>基本用法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div></pre></td></tr></table></figure></p>
<p><code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<ul>
<li><code>get(target, propKey, receiver)</code>: 拦截对象属性的读取，如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code></li>
<li><code>set(target, proKey, value, receiver)</code>: 拦截对象属性的设置，如<code>proxy.foo = v</code>和<code>proxy[&#39;foo&#39;] = v</code></li>
<li>……</li>
</ul>
<h2 id="统一码"><a href="#统一码" class="headerlink" title="统一码"></a>统一码</h2><p>es6 字符串支持新的 Unicode 文本形式，同时也增加了新的正则表达式修饰符<code>u</code>来处理统一码。尽管如此，在实际的开发中，这样处理仍会降低程序可读性和处理速度，所以目前不建议使用。</p>
<h2 id="进制数支持"><a href="#进制数支持" class="headerlink" title="进制数支持"></a>进制数支持</h2><p>es6 增加了对二进制（b）和八进制（o）数字面量的支持。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>Reflect 可以理解为原有对象上的一个引用代理，它用于对原有对象进行赋值或取值操作，但不会触发对象属性的 getter 或 setter 调用，而直接使用 = 对对象进行赋值或取值操作会自动触发 getter 或 setter 方法。</p>
<h2 id="tail-calls-尾调用"><a href="#tail-calls-尾调用" class="headerlink" title="tail calls 尾调用"></a>tail calls 尾调用</h2><p>tail calls 尾调用保证了函数尾部调用时调用栈有一定的长度限制，这使得递归函数即使在没有限制输入时也能保证安全性而避免发生错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, start = <span class="number">1</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n &lt; = <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> start;    </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * start);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 默认情况下会发生栈溢出，但是在 es6 中是可以安全执行的</span></div><div class="line">factorial(<span class="number">100000</span>);</div></pre></td></tr></table></figure></p>
<p>▼ <strong>基本概念</strong><br>尾调用是指某个函数的最后一步是调用另一个函数。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<br>▼ <strong>注意点</strong><br>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>
<p>学习参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门——阮一峰</a><br><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="external">尾调用优化</a><br>《现代前端技术解析》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;p&gt;Promise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 核心向新特性（02）</title>
    <link href="http://yoursite.com/2018/03/08/18-03-08-30/"/>
    <id>http://yoursite.com/2018/03/08/18-03-08-30/</id>
    <published>2018-03-08T11:56:33.000Z</published>
    <updated>2018-03-09T10:15:28.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类声明</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aminal</span> </span>&#123;</div><div class="line">  <span class="comment">// 类中只能包含一个名为constructor的特殊方法</span></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// extends 创建子类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">Aminal</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(contents = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">super</span>(); <span class="comment">// 调用父类的构造函数</span></div><div class="line">    <span class="keyword">this</span>.name = contents.name;</div><div class="line">    <span class="keyword">this</span>.family = contents.family;</div><div class="line">  &#125;</div><div class="line">  sayHi() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.family&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> boy = <span class="keyword">new</span> People(&#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'ouven'</span>,</div><div class="line">  <span class="attr">family</span>: <span class="string">'zhang'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">boy.sayHi(); <span class="comment">// Hello ouven zhang</span></div></pre></td></tr></table></figure>
<h2 id="模块-module"><a href="#模块-module" class="headerlink" title="模块 module"></a>模块 module</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; sayHi &#125; <span class="keyword">from</span> <span class="string">'./people'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> sayHi;</div></pre></td></tr></table></figure>
<p><strong>注意点</strong>：使用<code>default</code>导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。</p>
<h2 id="循环与迭代器-Iterator"><a href="#循环与迭代器-Iterator" class="headerlink" title="循环与迭代器 Iterator"></a>循环与迭代器 Iterator</h2><p>在 es6 阶段，除了<code>do...while</code>、<code>for</code>循环，还可以使用<code>for...in</code>来遍历<strong>对象</strong>。Iterator迭代器的加入让遍历数组、对象和集合的方式更加灵活可控，Iterator可以控制每次单步循环触发的时机，不用一次遍历所有的循环。</p>
<p>▼ <strong><code>for...of</code>遍历实现</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> number <span class="keyword">of</span> numbers) &#123;</div><div class="line">  <span class="built_in">console</span>.log(number);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>▼ <strong>迭代器遍历数组</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="keyword">let</span> result = iterator.next();</div><div class="line"><span class="built_in">console</span>.log(result.value); <span class="comment">// 1</span></div><div class="line"></div><div class="line">result = iterator.next();</div><div class="line"><span class="built_in">console</span>.log(result.value); <span class="comment">// 2</span></div><div class="line"></div><div class="line">result = iterator.next();</div><div class="line"><span class="built_in">console</span>.log(result.value); <span class="comment">// 3</span></div><div class="line"></div><div class="line">result = iterator.next();</div><div class="line"><span class="built_in">console</span>.log(result.value); <span class="comment">// 4</span></div><div class="line"></div><div class="line">result = iterator.next();</div><div class="line"><span class="built_in">console</span>.log(result.value); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>对比</strong><br>Iterator 可以在循环开始后任意的地方进行数组的单步循环，当循环迭代中每次单步循环操作都不一样时，使用 Iterator 更加的方便。如果使用<code>for...of</code>则需要不断判断执行的次数来执行不同的单步循环。<br>▼ <strong>注意点</strong><br>每次 Iterator 调用<code>next()</code>都会返回一个对象<code>{done: false, value: item}</code>，<code>done</code>的属性是布尔值，表示循环遍历是否完成，<code>value</code>则是每一步<code>next()</code>调用获取到的值。</p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> number <span class="keyword">of</span> numbers) &#123;</div><div class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(number);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = generator();</div><div class="line"></div><div class="line">result.next(); <span class="comment">// 1</span></div><div class="line"><span class="comment">// ...doSomething</span></div><div class="line">result.next(); <span class="comment">// 2</span></div><div class="line"><span class="comment">// ...doSomething</span></div><div class="line">result.next(); <span class="comment">// 3</span></div><div class="line"><span class="comment">// ...doSomething</span></div><div class="line">result.next(); <span class="comment">// 4</span></div><div class="line"><span class="comment">// ...doSomething</span></div><div class="line">result.next(); <span class="comment">// 5</span></div><div class="line"><span class="comment">// ...doSomething</span></div></pre></td></tr></table></figure>
<p>Generator 是针对函数内代码块的执行控制，如果将一个特殊函数的代码使用<code>yield</code>关键字来分割成多个不同的代码段，那么每次 Generator 调用<code>next()</code>都只会执行<code>yield</code>关键字之间的一段代码。Generator 可以认为是一个可中断执行的特殊函数，声明方法是在函数名后面加上<code>*</code>来与普通函数区分。<br>▼ <strong>注意点</strong><br>Generator 遇到<code>yield</code>关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果<code>console.log(number)</code>是一个耗时的工作，那么程序只在 Generator 里面暂停，外面的程序仍会继续执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> number <span class="keyword">of</span> numbers) &#123;</div><div class="line">    <span class="keyword">yield</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(number);</div><div class="line">    &#125;, <span class="number">3000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = generator();</div><div class="line"><span class="keyword">let</span> done = result.next();</div><div class="line"><span class="keyword">while</span>(!done.done) &#123;</div><div class="line">  done = result.next();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'finish'</span>);</div><div class="line"><span class="comment">// 输出</span></div><div class="line">finish</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="Set-amp-Map"><a href="#Set-amp-Map" class="headerlink" title="Set &amp; Map"></a>Set &amp; Map</h3><p>▼ <strong>为什么有了数组和对象来进行存储数据还要要使用 Map &amp; Set</strong></p>
<ul>
<li>对象的键名一般只能是字符串，而不能是一个对象；</li>
<li>对象没有直接获取属性个数等这些方便操作的方法；</li>
<li>对于对象的任何操作都需要进入对象的内部数据中完成，如查找、删除某个值必须循环遍历对象内部的所有键值对来完成。</li>
</ul>
<p>▼ <strong>Set的基本用法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</div><div class="line">[...set]</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<p>Set 不会添加重复的值，并且可以接受一个数组（或者具有 Iterable 接口的其他数据解构）作为参数，用来初始化。<br>▼ <strong>Map的基本用法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;</div><div class="line"></div><div class="line">m.set(o, <span class="string">'content'</span>)</div><div class="line">m.get(o) <span class="comment">// "content"</span></div><div class="line"></div><div class="line">m.has(o) <span class="comment">// true</span></div><div class="line">m.delete(o) <span class="comment">// true</span></div><div class="line">m.has(o) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以作为键。</p>
<h3 id="WeakSet-amp-WeakMap"><a href="#WeakSet-amp-WeakMap" class="headerlink" title="WeakSet &amp; WeakMap"></a>WeakSet &amp; WeakMap</h3><p>WeakSet 和 WeakMap 则对应着 Set 和 Map 的优化类型，所以某种程度上，为了让程序开发更加方便，我妈有必要引入集合这类更为高效的类型。WeakSet 和 WeakMap 在生成时有更加严格的限制：WeakSet 只存储对象类型的元素，不能遍历，没有<code>size</code>属性；WeakMap 只接受基本类型的值作为键名，没有<code>keys</code>、<code>values</code>、<code>entries</code>等遍历方法，也没有<code>size</code>属性。<br>▼ <strong>WeakSet的基本用法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</div><div class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</div><div class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b);</div><div class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>WeakMap的基本用法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</div><div class="line">wm1.set(key, <span class="number">2</span>);</div><div class="line">wm1.get(key) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="comment">// TypeError: 1 is not an object!</span></div></pre></td></tr></table></figure></p>
<h2 id="数组或对象循环遍历的方法对比"><a href="#数组或对象循环遍历的方法对比" class="headerlink" title="数组或对象循环遍历的方法对比"></a>数组或对象循环遍历的方法对比</h2><h3 id="for-while-循环语句"><a href="#for-while-循环语句" class="headerlink" title="for/while 循环语句"></a>for/while 循环语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有语言都会涉及的循环。不过单纯的for/while能力有限，而且性能上也堪忧。而且必须借助特定的结构才能遍历数据结构。</p>
<h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach 方法"></a>forEach 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(index + <span class="string">':'</span> + value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>优点：</strong>可以同时获取index和value，不必再像以前遍历数组那样，还要再在for去获取值。<br><strong>缺点：</strong>仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。<br><strong>应用场景：</strong>仅在遍历数组的时候使用。</p>
<h3 id="for…in-语句"><a href="#for…in-语句" class="headerlink" title="for…in 语句"></a>for…in 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>,<span class="attr">c</span>: <span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">  <span class="built_in">console</span>.log(obj[key]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优点：</strong>它可以支持所有对象类型的数据，包括数组，甚至是函数等，而且语法简单。且不同于<code>forEach</code>方法，它可以与break、continue和return配合使用。<br><strong>缺点：</strong>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。主要是为遍历对象而设计的，不适用于遍历数组。<br><strong>应用场景：</strong> 遍历常用对象（如例子）</p>
<h3 id="for…of-语句"><a href="#for…of-语句" class="headerlink" title="for…of 语句"></a>for…of 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">list.set(<span class="string">'a'</span>, <span class="number">1</span>);</div><div class="line">list.set(<span class="string">'b'</span>, <span class="number">2</span>);</div><div class="line">list.set(<span class="string">'c'</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [key, value] <span class="keyword">of</span> list) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">':'</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>for...of</code>是ES6新增的语法，它是基于ES6新增的Iterator和Symbol开发的。<br><strong>优点：</strong>在遍历中直接取值。感觉上和<code>for...in</code>形成互补，一个在遍历中取键名，另一个取值。另一个优点是，它可以遍历任何部署了 Iterator 接口的数据结构（如 Set 和 Map），甚至是非 JavaScript 的数据类型，即自己定义的数据结构。<br><strong>缺点：</strong>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。<br><strong>应用场景：</strong>推荐应用于Map上的遍历。</p>
<h3 id="map-amp-filter-amp-reduce"><a href="#map-amp-filter-amp-reduce" class="headerlink" title="map() &amp; filter() &amp; reduce()"></a>map() &amp; filter() &amp; reduce()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> element + <span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line">arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> element &gt; <span class="number">1</span>;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [2, 3]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> result = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, element</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> prev + element;</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p><strong>应用场景：</strong>这三个方法都是是 Array 中的方法，常用于数组中的数值的处理。<code>map</code>主要用于对存储的数据进行加工，<code>filter</code>偏向于过滤数据，<code>reduce</code>用于计算总和。</p>
<p>学习参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门——阮一峰</a><br>《现代前端技术解析》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;l
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 核心向新特性（01）</title>
    <link href="http://yoursite.com/2018/03/07/18-03-07-29/"/>
    <id>http://yoursite.com/2018/03/07/18-03-07-29/</id>
    <published>2018-03-07T06:19:15.000Z</published>
    <updated>2018-03-09T10:14:25.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="块级作用域变量声明关键字-let-、-const"><a href="#块级作用域变量声明关键字-let-、-const" class="headerlink" title="块级作用域变量声明关键字 let 、 const"></a>块级作用域变量声明关键字 let 、 const</h2><h3 id="let-、-const-与-var-的对比"><a href="#let-、-const-与-var-的对比" class="headerlink" title="let 、 const 与 var 的对比"></a>let 、 const 与 var 的对比</h3><ul>
<li><p>不存在变量提升；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var 的情况</span></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// let 的情况</span></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">let</span> x;</div></pre></td></tr></table></figure>
</li>
<li><p>let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">a <span class="comment">// ReferenceError: a is not defined.</span></div><div class="line">b <span class="comment">// 1</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> b = <span class="string">'hello'</span>;</div><div class="line">b = <span class="string">'world'</span>; <span class="comment">// Uncaught TyperError: Assignment to constant variable.</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> A = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a || global.a); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.A || global.A); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
<li><p>用 let 、 const 赋值语句的执行速度比使用 var 快约65%；</p>
</li>
</ul>
<h3 id="使用场景的区分"><a href="#使用场景的区分" class="headerlink" title="使用场景的区分"></a>使用场景的区分</h3><p>模块内不变的引用和常量，使用<code>const</code>定义；可变的变量或引用使用<code>let</code>声明；<code>var</code>仅用于声明函数整个作用域内需要使用的变量。</p>
<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure>
<ul>
<li>字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁</li>
<li>字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。</p>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>▼ <strong>变量的赋值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">11</span>, <span class="number">22</span>];</div><div class="line">a <span class="comment">// 11</span></div><div class="line">b <span class="comment">// 22</span></div><div class="line">c <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>指定默认值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>▼ <strong>变量的赋值</strong>（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>指定默认值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">x <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h2 id="数组的新特性"><a href="#数组的新特性" class="headerlink" title="数组的新特性"></a>数组的新特性</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符(...)"></a>扩展运算符(<code>...</code>)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr =[<span class="string">'hello'</span>, <span class="string">'world'</span>];</div><div class="line"><span class="keyword">const</span> newArr = [...arr]; <span class="comment">// ['hello', 'world']</span></div></pre></td></tr></table></figure>
<p><strong>注意点</strong>： <code>...</code>进行的数组复制是浅拷贝</p>
<h3 id="扩展API"><a href="#扩展API" class="headerlink" title="扩展API"></a>扩展API</h3><ul>
<li><p><code>Array.from</code>: 用于将数组对象转化为真正的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// ES5的写法</span></div><div class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></div><div class="line"></div><div class="line"><span class="comment">// ES6的写法</span></div><div class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Array.of</code>: 将传入的一组参数转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.copyWithin</code>: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用<code>copyWithin</code>方法会修改当前数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'green'</span>];</div><div class="line">colors.copyWithin(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// ['green', 'blue', 'green', 'green']</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.fill</code>: 使用给定值，填充一个数组，会改变原来的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">colors.fill(<span class="string">'black'</span>); <span class="comment">// ['black', black', black', black']</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Arrau.prototype.find</code>: 用于找出第一个符合条件的数组元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">colors.find(<span class="function"><span class="keyword">function</span>(<span class="params">color</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(color === <span class="string">'green'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> color;</div><div class="line">  &#125;</div><div class="line">&#125;) <span class="comment">// green</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.findIndex</code>: 用来返回某个特定数组元素在数组中的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">colors.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">color</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(color === <span class="string">'green'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> color;</div><div class="line">  &#125;</div><div class="line">&#125;) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="新的数组迭代方式"><a href="#新的数组迭代方式" class="headerlink" title="新的数组迭代方式"></a>新的数组迭代方式</h3><p><code>entries()</code>、<code>keys()</code>和<code>values()</code>，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用<code>for...of</code>循环进行遍历，区别是<code>keys()</code>是对数组键名进行遍历，<code>values()</code>是对数组键值进行遍历，<code>entries()</code>是对数组中键值对进行遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure></p>
<h2 id="增强函数"><a href="#增强函数" class="headerlink" title="增强函数"></a>增强函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>ES6 对函数参数的改进主要是添加了默认参数、不定参数和拓展参数</p>
<p>▼ <strong>默认参数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name = <span class="string">'ouven'</span></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line">sayHi(); <span class="comment">// Hello ouven</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>不定参数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">...name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(name.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;b&#125;</span>`</span>));</div><div class="line">&#125;</div><div class="line">sayHi(<span class="string">'oven'</span>, <span class="string">'zhang'</span>); <span class="comment">// Hello ouven zhang</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>扩展参数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = [<span class="string">'oven'</span>, <span class="string">'zhang'</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name1, name2</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name1&#125;</span> <span class="subst">$&#123;name2&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line">sayHello(...name); <span class="comment">// Hello ouven zhang</span></div></pre></td></tr></table></figure></p>
<p>其中不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数将多个参数映射到一个数组。<br>▼ <strong>不定参数与 arguments 的对比</strong><br>不定参数和<code>arguments</code>都可以使用函数的形参来表示所有的参数组成的列表，但是<code>arguments</code>不是真正的数组，所有使用数组的方法必须使用<code>Array.prototype.slice.call</code>先将其转换成数组，所有使用起来不定参数更加的方便。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>注意点</strong>：箭头函数没有完整的执行上下文，因为其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链， 没有 this 值。</p>
<h2 id="增强对象"><a href="#增强对象" class="headerlink" title="增强对象"></a>增强对象</h2><p>es6 中，对象的使用更加方便。在定义对象时通过属性简写、变量作为属性名或省略对象函数属性的书写等方式可以提高编码的效率。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = <span class="string">'onven'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> people = &#123;</div><div class="line">  <span class="comment">// 属性简写</span></div><div class="line">  name,</div><div class="line">  <span class="comment">// 返回变量或对象作为属性名</span></div><div class="line">  [getKey(<span class="string">'family'</span>)]: <span class="string">'zhang'</span>,</div><div class="line">  <span class="comment">// 对象方法属性简写声明</span></div><div class="line">  sayHi() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.family&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">people.sayHi(); <span class="comment">// Hello ouven zhang</span></div></pre></td></tr></table></figure></p>
<p><strong>注意点</strong>：为了代码便于维护和理解，建议尽量不将变量或对象作为对象的属性名。</p>
<p>学习参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门——阮一峰</a><br>《现代前端技术解析》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;块级作用域变量声明关键字-let-、-const&quot;&gt;&lt;a href=&quot;#块级作用域变量声明关键字-let-、-const&quot; class=&quot;headerlink&quot; title=&quot;块级作用域变量声明关键字 let 、 const&quot;&gt;&lt;/a&gt;块级作用域变量声明关键字 l
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Webpack学习笔记</title>
    <link href="http://yoursite.com/2018/01/15/18-01-15-28/"/>
    <id>http://yoursite.com/2018/01/15/18-01-15-28/</id>
    <published>2018-01-15T06:13:32.000Z</published>
    <updated>2018-03-05T05:51:10.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack-基本介绍"><a href="#Webpack-基本介绍" class="headerlink" title="Webpack 基本介绍"></a>Webpack 基本介绍</h2><p>▼ <strong>什么是Webpack：</strong><br>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。</p>
<p>▼ <strong>为什那么要使用Webpack：</strong><br>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：</p>
<ul>
<li><strong>模块化</strong>，让我们可以把复杂的程序细化为小的文件；</li>
<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</li>
<li>Scss，less等CSS预处理器；</li>
<li>…</li>
</ul>
<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为Webpack类的工具的出现提供了需求。</p>
<h2 id="Webpack-的使用"><a href="#Webpack-的使用" class="headerlink" title="Webpack 的使用"></a>Webpack 的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们常规直接使用 npm 的形式来安装（全局安装）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install webpack -g</div></pre></td></tr></table></figure></p>
<p>如果常规项目还是把依赖写入 package.json 包更人性化（局部安装）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm init // 生成package.json文件，写入一些如作者、版本等基本信息</div><div class="line">$ npm install webpack --save-dev</div></pre></td></tr></table></figure></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>每个项目下都必须配置有一个 webpack.config.js，就是一个配置项，告诉 webpack 它需要做什么。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> commonsPlugin = <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">//插件项</span></div><div class="line">  plugins: [commonsPlugin],</div><div class="line">  <span class="comment">//页面入口文件配置</span></div><div class="line">  entry: &#123;</div><div class="line">    <span class="attr">index</span> : <span class="string">'./src/js/page/index.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">//入口文件输出配置</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'dist/js/page'</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="comment">//加载器配置</span></div><div class="line">    loaders: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">loader</span>: <span class="string">'jsx-loader?harmony'</span> &#125;,</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">loader</span>: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">//其它解决方案配置</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">root</span>: <span class="string">'E:/github/flux-example/src'</span>, <span class="comment">//绝对路径</span></div><div class="line">    extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="attr">AppStore</span> : <span class="string">'js/stores/AppStores.js'</span>,</div><div class="line">      <span class="attr">ActionType</span> : <span class="string">'js/actions/ActionType.js'</span>,</div><div class="line">      <span class="attr">AppAction</span> : <span class="string">'js/actions/AppAction.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>▼ <strong>plugins：</strong><br>插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。<br>▼ <strong>entry：</strong><br>页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="attr">page1</span>: <span class="string">"./page1"</span>,</div><div class="line">    <span class="comment">//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span></div><div class="line">    page2: [<span class="string">"./entry1"</span>, <span class="string">"./entry2"</span>]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">   <span class="attr">path</span>: <span class="string">"dist/js/page"</span>,</div><div class="line">   <span class="attr">filename</span>: <span class="string">"[name].bundle.js"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。<br>▼ <strong>module.loaders：</strong><br>告知 webpack 每一种文件都需要使用什么加载器来处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  <span class="comment">//加载器配置</span></div><div class="line">  loaders: [</div><div class="line">    <span class="comment">//.css 文件使用 style-loader 和 css-loader 来处理</span></div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">    <span class="comment">//.js 文件使用 jsx-loader 来编译处理</span></div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">loader</span>: <span class="string">'jsx-loader?harmony'</span> &#125;,</div><div class="line">    <span class="comment">//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span></div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">loader</span>: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</div><div class="line">    <span class="comment">//图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span></div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。<br><strong>所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。</strong><br>如：url-loader，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install url-loader -save-dev</div></pre></td></tr></table></figure></p>
<p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。<br>▼ <strong>resolve：</strong><br>其它解决方案配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">  <span class="comment">//查找module的话从这里开始查找</span></div><div class="line">  root: <span class="string">'E:/github/flux-example/src'</span>, <span class="comment">//绝对路径</span></div><div class="line">  <span class="comment">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></div><div class="line">  extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</div><div class="line">  <span class="comment">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></div><div class="line">  alias: &#123;</div><div class="line">    <span class="attr">AppStore</span> : <span class="string">'js/stores/AppStores.js'</span>,<span class="comment">//后续直接 require('AppStore') 即可</span></div><div class="line">    ActionType : <span class="string">'js/actions/ActionType.js'</span>,</div><div class="line">    <span class="attr">AppAction</span> : <span class="string">'js/actions/AppAction.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ webpack --display-error-details</div></pre></td></tr></table></figure>
<p>后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。<br>其他主要的参数有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</div><div class="line">$ webpack --watch   //监听变动并自动打包</div><div class="line">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</div><div class="line">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</div></pre></td></tr></table></figure></p>
<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>项目文件夹结构如下图：<br><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/webpack-1.png" alt=""></p>
<ul>
<li>src目录下的文件夹存放源代码，dist目录下存放打包过后的代码<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./src/index.js'</span>, <span class="comment">// 以index.js为入口</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'js/canvas-filter.bundle.js'</span>, <span class="comment">// 打包后生成的文件</span></div><div class="line">    path: path.resolve(__dirname,<span class="string">'./dist'</span>) <span class="comment">// 使用绝对路径</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">rules</span>: [</div><div class="line">      &#123; <span class="comment">// 使js中能够require css 文件的loader</span></div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">use</span>: [</div><div class="line">          <span class="string">'style-loader'</span>,</div><div class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, <span class="attr">options</span>: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; &#125;,</div><div class="line">          <span class="string">'postcss-loader'</span></div><div class="line">        ]</div><div class="line">      &#125;,</div><div class="line">      &#123; <span class="comment">// 使得less文件能够解析成css的loader</span></div><div class="line">        test: <span class="regexp">/\.less$/</span>,</div><div class="line">        <span class="attr">use</span>: [</div><div class="line">          <span class="string">'style-loader'</span>,</div><div class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, <span class="attr">options</span>: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; &#125;,</div><div class="line">          <span class="string">'less-loader'</span>,</div><div class="line">          <span class="string">'postcss-loader'</span></div><div class="line">        ]</div><div class="line">      &#125;,</div><div class="line">      &#123; <span class="comment">// 使得能够正确引用图片文件路径的loader</span></div><div class="line">        test: <span class="regexp">/\.(png|jpg|gif|svg)$/i</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'file-loader'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="comment">// 再项目中使用jquery时所需要的配置</span></div><div class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">      <span class="attr">$</span>: <span class="string">'jquery'</span>,</div><div class="line">      <span class="attr">jQuery</span>: <span class="string">'jquery'</span>,</div><div class="line">      <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span>,</div><div class="line">      <span class="string">'window.$'</span>: <span class="string">'jquery'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</div><div class="line">  ],</div><div class="line">  <span class="attr">devServer</span>: &#123;</div><div class="line">    <span class="comment">// 使用webpack-dev-server，开启本地服务器</span></div><div class="line">    hot: <span class="literal">true</span>,</div><div class="line">    <span class="attr">inline</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Webpack-基本介绍&quot;&gt;&lt;a href=&quot;#Webpack-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;Webpack 基本介绍&quot;&gt;&lt;/a&gt;Webpack 基本介绍&lt;/h2&gt;&lt;p&gt;▼ &lt;strong&gt;什么是Webpack：&lt;/strong&gt;
    
    </summary>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记（01）</title>
    <link href="http://yoursite.com/2017/10/19/17-10-19-27/"/>
    <id>http://yoursite.com/2017/10/19/17-10-19-27/</id>
    <published>2017-10-19T13:25:58.000Z</published>
    <updated>2017-10-21T08:27:51.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。</p>
</blockquote>
<p>▼ <strong>什么是MVVM：</strong><br>MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。</p>
<ul>
<li><strong>Model</strong><br>代表我们整个webapp所需要的数据模型，一个典型的例子就是用户信息Model,它应该含有(姓名，年龄等属性)。Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。</li>
<li><strong>View</strong><br>View这个词出现频率最多的地方应该是MVC。在MVC设计中，View是唯一与用户交互的地方，或者说它是Model变化后的直观反映。在MVVM中，View被认为是主动的而非被动的。一个被动的View时只它只能任由“他人”（Controller）摆布，自己却不能改变任何东西，如利用Jquery操作DOM。而MVVM中View是具有主动性的，因为它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自己身的行为（展示），而还会将自身的变化同步到ViewModel中。</li>
<li><strong>ViewModel</strong><br>ViewModel可以被看作是MVC中的Controller,它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。</li>
</ul>
<h2 id="MVC-和-MVVM-的比较"><a href="#MVC-和-MVVM-的比较" class="headerlink" title="MVC 和 MVVM 的比较"></a>MVC 和 MVVM 的比较</h2><p>刚发现了一篇关于几个模型的博文<a href="http://www.cnblogs.com/indream/p/3602348.html" target="_blank" rel="external">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a><br>在这里，简单的对这两个比较常见的设计模型进行一些比较：</p>
<h3 id="MVC结构图"><a href="#MVC结构图" class="headerlink" title="MVC结构图"></a>MVC结构图</h3><p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvc.png" alt=""></p>
<h3 id="MVVM结构图"><a href="#MVVM结构图" class="headerlink" title="MVVM结构图"></a>MVVM结构图</h3><p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvvm.png" alt=""></p>
<h3 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h3><p>由于前端的发展，出现了多页应用和Web App这种东西，使得前端不仅仅做的是简单的数据展示了。使用MVC，有下列一些优点：</p>
<ul>
<li>简化代码</li>
<li>减少重复</li>
<li>集中精神编写业务逻辑</li>
<li>易于扩充</li>
<li>数据触发事件</li>
<li>面向数据编程</li>
</ul>
<h3 id="MVC缺点"><a href="#MVC缺点" class="headerlink" title="MVC缺点"></a>MVC缺点</h3><p>MVC虽然将需求和UI的相关工作分化成了三份，但是由于它们三者的三角关系使得维护很成问题。<strong>在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。</strong></p>
<p>MVVM与MVC最大的区别在于，MVVM切断了View层和Model层的联系，让View层只和ViewModel层交互，而ViewModel再和Model层交互。在MVVM中，<strong>View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。</strong></p>
<p>随着HTML5的发展，Web App的应用越来越广泛，甚至能媲美Nativ eApp（大部分安卓或IOS应用），但随之也暴露出了三个痛点问题：</p>
<ul>
<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>
<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>
</ul>
<h3 id="MVVM优点"><a href="#MVVM优点" class="headerlink" title="MVVM优点"></a>MVVM优点</h3><p>在MVVM中，ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，这就完美的解决了以上的问题。</p>
<h2 id="Vue-js的MVVM应用"><a href="#Vue-js的MVVM应用" class="headerlink" title="Vue.js的MVVM应用"></a>Vue.js的MVVM应用</h2><p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/vuejs.png" alt=""></p>
<ul>
<li><strong>Observer</strong>：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现；</li>
<li><strong>Compile</strong>：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数；</li>
<li><strong>Watcher</strong>：订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数；</li>
<li><strong>Dep</strong>：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li>
</ul>
<h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装vue-cli</span></div><div class="line">$ cnpm install -g vue-cli</div><div class="line"><span class="comment"># 创建一个基于 "webpack" 模板的新项目</span></div><div class="line">$ vue init webpack my-project</div><div class="line"><span class="comment"># 安装依赖</span></div><div class="line">$ cd my-project</div><div class="line">$ cnmp install</div><div class="line"><span class="comment"># 开启项目</span></div><div class="line">$ npm run dev</div></pre></td></tr></table></figure></p>
<h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><p><code>index.html</code>：放在项目根目录下，是项目的入口<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>blog-project<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- app为一个组件，默认调用src里的main.js --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>src/main.js</code>：注册组件app<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//import表示导入组件，ES6语法</span></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>   <span class="comment">//导入vue框架</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>   <span class="comment">//同级目录下的App.vue</span></div><div class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>   <span class="comment">//同级目录下的router文件夹</span></div><div class="line"></div><div class="line"></div><div class="line">Vue.config.productionTip = <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">/* eslint-disable no-new */</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  router,</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; App &#125;  <span class="comment">//注册一个app</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>src/App.vue</code>：组件的主要代码，包括<code>template</code>、<code>script</code>、<code>style</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 渲染路径匹配到的视图组件，方便渲染你指定路由对应的组件 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'app'</span></div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#app</span> &#123;</div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Avenir'</span>, Helvetica, Arial, sans-serif;</div><div class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</div><div class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>router/index.js</code>： 创建路由并配置路由映射 ，并通过export输出router到main.js文件中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span> </div><div class="line"><span class="comment">// 在这里引入另一个名为HelloWorld的组件</span></div><div class="line"><span class="comment">// 即components目录下的HelloWorld.vue</span></div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">  <span class="attr">routes</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">      <span class="attr">name</span>: <span class="string">'Hello'</span>,</div><div class="line">      <span class="attr">component</span>: HelloWorld</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;▼ &lt;strong&gt;什么是MVVM：&lt;/strong&gt;&lt;br&gt;MVVM(M
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>前端自动化工具</title>
    <link href="http://yoursite.com/2017/10/17/17-10-14-26/"/>
    <id>http://yoursite.com/2017/10/17/17-10-14-26/</id>
    <published>2017-10-17T15:00:33.000Z</published>
    <updated>2017-10-19T06:12:50.919Z</updated>
    
    <content type="html"><![CDATA[<p>在这段时间工作的时候，遇到了很多以前没有接触过的名词，比如fekit，Webpack之类的，也用小黑框输入了很多指令，但是对于它们都做了些什么还不太清楚。</p>
<h2 id="前端自动化工具都做了什么"><a href="#前端自动化工具都做了什么" class="headerlink" title="前端自动化工具都做了什么"></a>前端自动化工具都做了什么</h2><p>前端自动化工具有很多，其中如Grunt，Gulp，Webpack什么的各种常见，当然还有很多其他的各种不明意义的词。它们到底做了些什么呢？</p>
<p>作为开发工具，其实它们本质上做的事可以分为：</p>
<ul>
<li>帮你安装东西</li>
<li>帮你做事</li>
</ul>
<p>再将两个事拓展一下，可以大致为：</p>
<ul>
<li>拷贝安装CSS库、JS库</li>
<li>为你的开发环境安装服务器</li>
<li>安装测试库、其他的开发工具等</li>
<li>在一个文件中替换文本字符串</li>
<li>创建文件夹，并且将文件转移到这些文件夹中</li>
<li>用一条单命令运行单元测试</li>
<li>在我保存文件的时候刷新浏览器</li>
<li>所有JavaScript文件整合为一个文件，将所有CSS文件整合为一个文件</li>
<li>对所有JavaScript和CSS进行简化处理（去除注释换行符等）</li>
<li>在html页面中修改<code>&lt;script&gt;</code>标签的位置</li>
</ul>
<h2 id="开发环节中遇到的事情"><a href="#开发环节中遇到的事情" class="headerlink" title="开发环节中遇到的事情"></a>开发环节中遇到的事情</h2><h3 id="调试服务器"><a href="#调试服务器" class="headerlink" title="调试服务器"></a>调试服务器</h3><p>页面操作离不开各种请求，要处理请求就必须要开启一个web服务器。web服务器处理的工作有：</p>
<ul>
<li>建立TCP链接</li>
<li>处理客户端发送的HTTP请求</li>
<li>向客户端发送处理过后的结果</li>
<li>关闭链接</li>
</ul>
<p>常用web服务器有：tomcat、Apache、Nginx等。但这部分搭建在我理解里应该是属于后端处理的内容。在<strong>前后端不分离</strong>的情况下，开发模式应该会这样：前端实现页面，但遇到ajax请求的时候，调试只能等待后端完成这部分模块完成后才能看到效果，这就十分的影响工作效率了。</p>
<p>在大公司中都在强调前后端分离的思想，前后端分离是怎样工作的呢？</p>
<ul>
<li>前端的工作：实现整一个前端页面以及交互逻辑，以及利用ajax与Nodejs服务器（中间层）交互</li>
<li>后端的工作：提供API接口，利用redis来管理session,与数据库交互</li>
</ul>
<p><strong>Nodejs前端服务器的职责：</strong></p>
<ul>
<li>作为静态文件服务器，当用户访问网站的时候，将index.html以及其引入的js、css、fonts以及图片返回给用户</li>
<li>负责将客户端发来的ajax请求转发给后台服务器</li>
</ul>
<p>这种分离的方式可以大致体现在：</p>
<ul>
<li>前端依赖指定格式的mock数据来进行UI开发</li>
<li>前端的开发和测试都基于这些mock数据</li>
<li>后端产生指定格式的mock数据</li>
<li>后端需要测试来确保生成的mock数据正是前端需要的</li>
</ul>
<h3 id="调试自动更新"><a href="#调试自动更新" class="headerlink" title="调试自动更新"></a>调试自动更新</h3><p>在调试网页的时候，如果修改一点代码，想要在浏览器查看效果，就得按f5刷新，如此反复势必造成许多的时间浪费。所以自动化工具会带有帮你检测本地文件的修改然后实时刷新页面的功能。</p>
<h3 id="解决浏览器缓存"><a href="#解决浏览器缓存" class="headerlink" title="解决浏览器缓存"></a>解决浏览器缓存</h3><p>由于浏览器会缓存已经加载过的文件，来提高网页响应的速度，但是在开发中，我们想看到的是我们保存的最新的文件的效果，所以要让浏览器不缓存我们的代码文件（通过文件名末尾增加哈希值来保证文件是最新的）。</p>
<h3 id="其他代码格式"><a href="#其他代码格式" class="headerlink" title="其他代码格式"></a>其他代码格式</h3><p>最常见的是css预处理器，如LESS、SASS和Stylus之类的。它们需要通过编译成CSS文件在浏览器中展现出效果，而这些编译的工作自然也是交给前端自动化工具实现。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在工作中有许多复杂的交互，可能需要你组织非常复杂的代码功能。前端自动化工具的使用也有利于我们模块的划分。</p>
<h3 id="资源合并优化"><a href="#资源合并优化" class="headerlink" title="资源合并优化"></a>资源合并优化</h3><p>当完成开发阶段的时候，我们需要提交自己开发的代码到线上服务器，在提交之前我们需要考虑将开发的资源进行最优化。为了减少http请求的次数，我们需要将分开写的js根据依赖关系去合并成较少的文件数目，并且进行压缩。类似的还有CSS文件和图片文件的压缩等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这段时间工作的时候，遇到了很多以前没有接触过的名词，比如fekit，Webpack之类的，也用小黑框输入了很多指令，但是对于它们都做了些什么还不太清楚。&lt;/p&gt;
&lt;h2 id=&quot;前端自动化工具都做了什么&quot;&gt;&lt;a href=&quot;#前端自动化工具都做了什么&quot; class=&quot;he
    
    </summary>
    
    
      <category term="知识碎片" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习笔记(03)</title>
    <link href="http://yoursite.com/2017/10/14/17-10-14-25/"/>
    <id>http://yoursite.com/2017/10/14/17-10-14-25/</id>
    <published>2017-10-14T03:41:59.000Z</published>
    <updated>2017-10-19T06:12:43.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>群组选择器：逗号“,”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div, p                //选择所有&lt;div&gt;元素和所有&lt;p&gt;元素</div></pre></td></tr></table></figure>
</li>
<li><p>简单选择器：ID、标签、类、属性、通配符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#test                 //选择id=&quot;test&quot;的所有元素</div><div class="line">p                     //选择所有&lt;p&gt;元素</div><div class="line">.intro                //选择class=&quot;intro&quot;的所有元素</div><div class="line">[target]              //选择带有target属性的所有元素</div><div class="line">[target=_blank]       //选择target=&quot;_blank&quot;的所有元素</div><div class="line">[title~=flower]       //选择titl属性包含单词&quot;flower&quot;的所有元素</div><div class="line">[lang|=en]            //选择属性值以&quot;en&quot;开头的所有元素</div><div class="line">a[src^=&quot;https&quot;]       //选择src属性值以&quot;https&quot;开头的所有&lt;a&gt;元素</div><div class="line">a[src$=&quot;.pdf&quot;]        //选择src属性值以&quot;.pdf&quot;结尾的所有&lt;a&gt;元素</div><div class="line">a[src*=&quot;abc&quot;]         //选择src属性值中包含&quot;abc&quot;子串的所有&lt;a&gt;元素</div><div class="line">*                     //选择所有元素</div></pre></td></tr></table></figure>
</li>
<li><p>关系选择器：孩子、后代、相邻兄弟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div &gt; p               //选择父元素为&lt;div&gt;元素的所有&lt;p&gt;元素</div><div class="line">div p                 //选择&lt;div&gt;元素内部的所有&lt;p&gt;元素</div><div class="line">div + p               //选择紧接在&lt;div&gt;元素之后的所有&lt;p&gt;元素</div><div class="line">p ~ ul                //选择前面有&lt;p&gt;元素的每个&lt;ul&gt;元素</div></pre></td></tr></table></figure>
</li>
<li><p>伪类选择器：动作伪类、目标伪类、语言伪类、状态伪类、结构伪类、取反伪类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">a:link                //选择所有未被访问的链接</div><div class="line">a:visited             //选择所有已被访问链接</div><div class="line">a:active              //选择活动链接</div><div class="line">a:hover               //选择鼠标指针位于其上的链接</div><div class="line">input:focus           //选择获得焦点的input元素</div><div class="line">:before               //在每个&lt;p&gt;元素的内容之前插入内容</div><div class="line">:after                //在每个&lt;p&gt;元素的内容之后插入内容</div><div class="line">p:lang(it)            //选择带有以&quot;it&quot;开头的lang属性值的所有&lt;p&gt;元素</div><div class="line">#news:target          //选择当前活动的#news元素</div><div class="line">input:enabled         //选择所有启用的&lt;input&gt;元素</div><div class="line">input:disabled        //选择所有禁用的&lt;input&gt;元素</div><div class="line">input:checked         //选择所有被选中的&lt;input&gt;元素</div><div class="line">::selection           //选择被用户选取的元素部分</div><div class="line">p:first-of-type       //选择属于其父元素的首个&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class="line">p:last-of-type        //选择属于其父元素的最后&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class="line">p:only-of-type        //选择属于其父元素唯一的&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class="line">p:nth-of-type(2)      //选择属于其父元素第二个&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class="line">p:only-child          //选择属于其父元素的唯一子元素的所有&lt;p&gt;元素</div><div class="line">p:nth-child(2)        //选择属于其父元素的第二个子元素的所有&lt;p&gt;元素</div><div class="line">p:last-child          //选择属于其父元素最后一个子元素的所有&lt;p&gt;元素</div><div class="line">p:nth-last-child(2)   //同上，从最后一个子元素开始计数</div><div class="line">:root                 //选择文档的根元素</div><div class="line">:empty                //选择没有子元素的所有&lt;p&gt;元素</div><div class="line">:not(p)               //选择非&lt;p&gt;元素的所有元素</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CSS的解析原理"><a href="#CSS的解析原理" class="headerlink" title="CSS的解析原理"></a>CSS的解析原理</h3><p>HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。</p>
<p>在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>
<p>因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。</p>
<p>如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。</p>
<p>逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。</p>
<p>但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。</p>
<h3 id="getElementBy系列-与-querySelectorAll"><a href="#getElementBy系列-与-querySelectorAll" class="headerlink" title="getElementBy系列 与 querySelectorAll"></a>getElementBy系列 与 querySelectorAll</h3><p>getElementById（或者其他）获取的是动态集合，querySelector获取的是静态集合</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// demo1</span></div><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>],</div><div class="line">    lis = ul.getElementsByTagName(<span class="string">'li'</span>);</div><div class="line"><span class="comment">//动态插入标签</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i ++) &#123;</div><div class="line">  ul.appendChild(<span class="built_in">document</span>.creatElement(<span class="string">'li'</span>));</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(lis.length); <span class="comment">//6</span></div><div class="line"></div><div class="line"><span class="comment">// demo2</span></div><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySeletorAll(<span class="string">'ul'</span>),</div><div class="line">    lis = ul.querySelectorAll(<span class="string">'li'</span>);</div><div class="line"><span class="comment">//插入动态标签</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i ++) &#123;</div><div class="line">  ul.appendChild(<span class="built_in">document</span>.creatElement(<span class="string">'li'</span>));</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(lis.length); <span class="comment">//3</span></div></pre></td></tr></table></figure>
<p>demo1中的lis是一个动态的NodeList，每一次调用lis都会重新对文档进行查询，导致无限循环的问题。</p>
<p>demo2中的lis是一个静态的NodeList，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。</p>
<p>而在chrome浏览器中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>).toString();    <span class="comment">// return "[object NodeList]"</span></div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>).toString();    <span class="comment">// return "[object HTMLCollection]"</span></div></pre></td></tr></table></figure></p>
<p>在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象。</p>
<p>▼ <strong>什么是NodeList：</strong><br>NodeList本质上是一个动态的Node集合，只是规范中对querySelectorAll有明确要求，规定其必须返回一个静态的NodeList对象。</p>
<p>▼ <strong>什么是HTMLCollection：</strong><br>HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。</p>
<p>▼ <strong>getElementBy系列的速度比querySelectorAll快：</strong><br>由于getElementBy系列的是一个实时的集合，这种集合是不需要在一开始就获取到所有的信息的；而通过querySelectorAll方法获取的集合是静态的集合，这个集合相当于一个快照，就是在这个方法运行的这个时间里，它所要获取的集合元素的一个快照，所以这个集合要保存大量的信息。</p>
<p><strong>使用getElementsByTagName方法我们得到的结果就像是一个对象的索引，而通过querySelectorAll方法我们得到的是一个对象的克隆；所以当这个对象数据量非常大的时候，显然克隆这个对象所需要花费的时间是很长的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS选择器&quot;&gt;&lt;a href=&quot;#CSS选择器&quot; class=&quot;headerlink&quot; title=&quot;CSS选择器&quot;&gt;&lt;/a&gt;CSS选择器&lt;/h2&gt;&lt;h3 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习笔记(02)</title>
    <link href="http://yoursite.com/2017/10/10/17-10-10-24/"/>
    <id>http://yoursite.com/2017/10/10/17-10-10-24/</id>
    <published>2017-10-10T12:44:41.000Z</published>
    <updated>2017-10-19T06:12:37.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQuery-fn-init"><a href="#jQuery-fn-init" class="headerlink" title="jQuery.fn.init"></a>jQuery.fn.init</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A simple way to check for HTML strings</span></div><div class="line"><span class="comment">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span></div><div class="line"><span class="comment">// Strict HTML recognition (#11290: must start with &lt;)</span></div><div class="line">rquickExpr = <span class="regexp">/^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/</span></div></pre></td></tr></table></figure>
<p>这是一个简单的检测HTML字符串的表达式，它可以分成两部分：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\s*(&lt;[\w\W]+&gt;)[^&gt;]*</div><div class="line">// 用来匹配"  &lt;xxx&gt;&lt;xxx&gt;xxxx"形式的字符串</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#([\w-]*)</div><div class="line">// 用来匹配"#xx-xx-xx.."形式的字符串</div></pre></td></tr></table></figure>
<ul>
<li>tip：关于<code>(?:pattern)</code>，作用是匹配pattern但不获取匹配结果（非获取匹配）。即当使用match或exec的时候，该括号中的pattern匹配结果不会保存在数组中。</li>
</ul>
<h3 id="jQuery选择器API"><a href="#jQuery选择器API" class="headerlink" title="jQuery选择器API"></a>jQuery选择器API</h3><p>选择器支持9种方式的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1.$(document)</div><div class="line">2.$(‘&lt;div&gt;’)</div><div class="line">3.$(‘div’)</div><div class="line">4.$(‘#test’)</div><div class="line">5.$(function()&#123;&#125;)</div><div class="line">6.$(&quot;input:radio&quot;, document.forms[0]);</div><div class="line">7.$(‘input’, $(‘div’))</div><div class="line">8.$()</div><div class="line">9.$(&quot;&lt;div&gt;&quot;, &#123;</div><div class="line">         &quot;class&quot;: &quot;test&quot;,</div><div class="line">         text: &quot;Click me!&quot;,</div><div class="line">         click: function()&#123; $(this).toggleClass(&quot;test&quot;); &#125;</div><div class="line">      &#125;).appendTo(&quot;body&quot;);</div><div class="line">10$($(‘.test’))</div></pre></td></tr></table></figure></p>
<p>源码缩进后的结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context, rootjQuery </span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> match, elem;</div><div class="line"></div><div class="line">  <span class="comment">// HANDLE: $(""), $(null), $(undefined), $(false)</span></div><div class="line">  <span class="keyword">if</span> ( !selector ) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Handle HTML strings</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> selector === <span class="string">"string"</span> ) &#123;</div><div class="line">    <span class="comment">// HANDLE: $(DOMElement)</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( selector.nodeType ) &#123;</div><div class="line">    <span class="comment">// HANDLE: $(function)</span></div><div class="line">    <span class="comment">// Shortcut for document ready</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class="line">    <span class="keyword">return</span> rootjQuery.ready( selector );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ( selector.selector !== <span class="literal">undefined</span> ) &#123;</div><div class="line">    <span class="keyword">this</span>.selector = selector.selector;</div><div class="line">    <span class="keyword">this</span>.context = selector.context;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> jQuery.makeArray( selector, <span class="keyword">this</span> );</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="匹配传入的字符串"><a href="#匹配传入的字符串" class="headerlink" title="匹配传入的字符串"></a>匹配传入的字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( selector.charAt(<span class="number">0</span>) === <span class="string">"&lt;"</span> &amp;&amp; selector.charAt( selector.length - <span class="number">1</span> ) === <span class="string">"&gt;"</span> &amp;&amp; selector.length &gt;= <span class="number">3</span> ) &#123;</div><div class="line">  <span class="comment">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span></div><div class="line">  match = [ <span class="literal">null</span>, selector, <span class="literal">null</span> ];</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  match = rquickExpr.exec( selector );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过分析rquickExpr正则表达式，我们可以得出selector分别为以下几种值时返回值match的结构：</p>
<ul>
<li><p><code>selector = &quot;&lt;div&gt;&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match = [<span class="literal">null</span>, <span class="string">"&lt;div&gt;"</span>, <span class="literal">null</span>]</div></pre></td></tr></table></figure>
</li>
<li><p><code>selector = &quot;&lt;div&gt;content&lt;/div&gt;&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match = [<span class="literal">null</span>, <span class="string">"&lt;div&gt;content&lt;/div&gt;"</span>, <span class="literal">null</span>]</div></pre></td></tr></table></figure>
</li>
<li><p><code>selector = &quot;&lt;div&gt;&lt;/div&gt;content&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match = [<span class="string">"&lt;div&gt;&lt;/div&gt;content"</span>, <span class="string">"&lt;div&gt;&lt;/div&gt;"</span>, <span class="literal">null</span>]</div></pre></td></tr></table></figure>
</li>
<li><p><code>selector = #id</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match = [#id, null, id]</div></pre></td></tr></table></figure>
</li>
<li><p><code>selector = .className</code>等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match = <span class="literal">null</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以判断是第三种或第四种情况，当为#id时，不需要指定上下文context，当为<code>&lt;htmltag&gt;</code>时，需要指定上下文<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( match &amp;&amp; (match[<span class="number">1</span>] || !context) ) &#123;</div></pre></td></tr></table></figure></p>
<h4 id="匹配模式一：-“-id”"><a href="#匹配模式一：-“-id”" class="headerlink" title="匹配模式一：$(“#id”)"></a>匹配模式一：$(“#id”)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">elem = <span class="built_in">document</span>.getElementById( match[<span class="number">2</span>] );</div><div class="line"></div><div class="line"><span class="comment">// Check parentNode to catch when Blackberry 4.6 returns</span></div><div class="line"><span class="comment">// nodes that are no longer in the document #6963</span></div><div class="line"><span class="keyword">if</span> ( elem &amp;&amp; elem.parentNode ) &#123;</div><div class="line">  <span class="comment">// Inject the element directly into the jQuery object</span></div><div class="line">  <span class="keyword">this</span>.length = <span class="number">1</span>;</div><div class="line">  <span class="keyword">this</span>[<span class="number">0</span>] = elem;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.context = <span class="built_in">document</span>;</div><div class="line"><span class="keyword">this</span>.selector = selector;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div></pre></td></tr></table></figure>
<h4 id="匹配模式二：-htmltag"><a href="#匹配模式二：-htmltag" class="headerlink" title="匹配模式二：$(htmltag)"></a>匹配模式二：$(htmltag)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HANDLE: $(html) -&gt; $(array)</span></div><div class="line"><span class="keyword">if</span> ( match[<span class="number">1</span>] ) &#123;</div><div class="line">  context = context <span class="keyword">instanceof</span> jQuery ? context[<span class="number">0</span>] : context;</div><div class="line">  <span class="comment">// 当context为jQuery对象时，把context转换成Js的原生DOM对象</span></div><div class="line">  <span class="comment">// 从上面可知context[0]即document.getElementById获取的elem</span></div><div class="line">  <span class="comment">// scripts is true for back-compat</span></div><div class="line">  jQuery.merge( <span class="keyword">this</span>, jQuery.parseHTML(</div><div class="line">    match[<span class="number">1</span>],</div><div class="line">    context &amp;&amp; context.nodeType ? context.ownerDocument || context : <span class="built_in">document</span>,</div><div class="line">    <span class="literal">true</span></div><div class="line">  ) );</div><div class="line"></div><div class="line">  <span class="comment">// HANDLE: $(html, props)</span></div><div class="line">  <span class="comment">// 对应：$(html标签, 对象)</span></div><div class="line">  <span class="keyword">if</span> ( rsingleTag.test( match[<span class="number">1</span>] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123;</div><div class="line">    <span class="keyword">for</span> ( match <span class="keyword">in</span> context ) &#123;</div><div class="line">      <span class="comment">// Properties of context are called as methods if possible</span></div><div class="line">      <span class="keyword">if</span> ( jQuery.isFunction( <span class="keyword">this</span>[ match ] ) ) &#123;</div><div class="line">        <span class="keyword">this</span>[ match ]( context[ match ] );</div><div class="line"></div><div class="line">      <span class="comment">// ...and otherwise set as attributes</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.attr( match, context[ match ] );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="comment">// HANDLE: $(#id)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>▼ <strong>关于<code>nodeType</code>：</strong><br>nodeType是DOM对象中Node类型的一个属性，返回数字值代表指定节点的节点类型。如果节点是元素节点，则返回1；如果节点是属性节点，则返回2。通过nodeType属性来判断context是不是一个节点。<br>▼ <strong>关于<code>ownerDocument</code>：</strong><br>ownerDocument也是DOM对象中Node类型的一个属性，它返回的创建这个节点的文档对象。由于可能存在iframe或者通过ajax加载的xml文档，所以要区分这些文档与默认文档window.document。<br>▼ <strong>关于<code>$.merge</code>：</strong><br>用于合并两个数组，但是不仅限于数组，还可以是key为数字的对象（类数组元素）<br>▼ <strong>关于<code>$.parseHTML</code>：</strong><br>将字符串转换为存储DOM节点的数组。第一个参数为传入的字符串，第二个为指定的根节点，第三个是boolean值，默认为false，不转换。</p>
<h4 id="匹配模式三：-className"><a href="#匹配模式三：-className" class="headerlink" title="匹配模式三：$(.className)"></a>匹配模式三：$(.className)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !context || context.jquery )</div></pre></td></tr></table></figure>
<p>context为空或是context是一个jQuery对象时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> ( context || rootjQuery ).find( selector );</div><div class="line"><span class="comment">// rootjQuery即为jQuery(document)</span></div><div class="line"><span class="comment">// 相当于 return jQuery( ducument ).find( selector );</span></div></pre></td></tr></table></figure></p>
<h4 id="匹配模式四：-className-context"><a href="#匹配模式四：-className-context" class="headerlink" title="匹配模式四：$(.className, context)"></a>匹配模式四：$(.className, context)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.constructor( context ).find( selector );</div><div class="line"><span class="comment">// this.constructor 即为jQuery对象</span></div><div class="line"><span class="comment">// 相当于 return jQuery( context ).find( selector );</span></div></pre></td></tr></table></figure>
<p>▼ <strong>关于<code>$.find</code>：</strong><br>jQuery的遍历方法，在DOM树中搜索匹配的元素，并构造成一个新的jQuery对象。</p>
<h4 id="匹配模式五：-DOMElement"><a href="#匹配模式五：-DOMElement" class="headerlink" title="匹配模式五：$(DOMElement)"></a>匹配模式五：$(DOMElement)</h4><p>将DOM节点转换成jQuery对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( selector.nodeType ) &#123;</div><div class="line">  <span class="keyword">this</span>.context = <span class="keyword">this</span>[<span class="number">0</span>] = selector;</div><div class="line">  <span class="keyword">this</span>.length = <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="匹配模式七：-function"><a href="#匹配模式七：-function" class="headerlink" title="匹配模式七：$(function)"></a>匹配模式七：$(function)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class="line">  <span class="keyword">return</span> rootjQuery.ready( selector );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>▼ <strong>关于<code>$.ready</code>：</strong><br>当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。也即当加载完成时执行selector函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从本质上来说，构建的jQuery对象，其实不仅仅只是dom，还有很多附加的元素，用数组的方式存储，当然各种组合有不一样，但是存储的方式是一样的。</p>
<p>总的来说分2大类：</p>
<ul>
<li>单个DOM元素，如$(ID),直接把DOM元素作数组传递给this对象</li>
<li>多个DOM元素，集合形式，可以通过CSS选择器匹配是有的DOM元素，过滤操作,构建数据结构</li>
</ul>
<p>学习参考：<br><a href="http://www.cnblogs.com/aaronjs/p/3279314.html" target="_blank" rel="external">jQuery源码分析系列</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jQuery-fn-init&quot;&gt;&lt;a href=&quot;#jQuery-fn-init&quot; class=&quot;headerlink&quot; title=&quot;jQuery.fn.init&quot;&gt;&lt;/a&gt;jQuery.fn.init&lt;/h2&gt;&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习笔记(01)</title>
    <link href="http://yoursite.com/2017/10/02/17-10-02-23/"/>
    <id>http://yoursite.com/2017/10/02/17-10-02-23/</id>
    <published>2017-10-02T05:36:40.000Z</published>
    <updated>2017-10-19T06:12:28.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><h3 id="自调用匿名函数"><a href="#自调用匿名函数" class="headerlink" title="自调用匿名函数"></a>自调用匿名函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined</span>) </span>&#123;</div><div class="line">  <span class="comment">// jquery code</span></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<p>▼ <strong>使用自调用匿名函数的原因：</strong></p>
<p>通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，保证jQuery创建的变量不能和导入他的程序所使用的变量发生冲突。</p>
<p>▼ <strong>自调用匿名函数的写法：</strong></p>
<p><strong>写法1</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// code</span></div><div class="line">&#125;(<span class="built_in">window</span>));</div><div class="line"><span class="comment">//括号包括了函数参数</span></div></pre></td></tr></table></figure></p>
<p><strong>写法2</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// code</span></div><div class="line">&#125;)(<span class="built_in">window</span>);</div><div class="line"><span class="comment">//括号只包括了函数定义</span></div></pre></td></tr></table></figure></p>
<p>▼ <strong>为什么要传入<code>window</code>：</strong></p>
<p>通过传入window变量，使得window由全局变量变为局部变量，在访问的时候就不需要将作用域链回退到顶层作用域，可以更快的访问。更重要的是，将window作为参数传入，可以在压缩代码时进行优化。</p>
<p>▼ <strong>为什么要在参数列表中增加<code>undefined</code>：</strong></p>
<p>要在自调用匿名函数的作用域内，确保<code>undefined</code>是真的未定义，因为<code>undefined</code>能够被重写。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line">  <span class="comment">// 构造jQuery对象</span></div><div class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class="line">      &#125;</div><div class="line">  <span class="comment">// 工具函数 Utilities</span></div><div class="line">  <span class="comment">// 异步队列 Deferred</span></div><div class="line">  <span class="comment">// 浏览器测试 Support</span></div><div class="line">  <span class="comment">// 数据缓存 Data</span></div><div class="line">  <span class="comment">// 队列 queue</span></div><div class="line">  <span class="comment">// 属性操作 Attribute</span></div><div class="line">  <span class="comment">// 事件处理 Event</span></div><div class="line">  <span class="comment">// 选择器 Sizzle</span></div><div class="line">  <span class="comment">// DOM遍历</span></div><div class="line">  <span class="comment">// DOM操作</span></div><div class="line">  <span class="comment">// CSS操作</span></div><div class="line">  <span class="comment">// 异步请求 Ajax</span></div><div class="line">  <span class="comment">// 动画 FX</span></div><div class="line">  <span class="comment">// 坐标和大小</span></div><div class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<h3 id="jQuery对象的构建方法"><a href="#jQuery对象的构建方法" class="headerlink" title="jQuery对象的构建方法"></a>jQuery对象的构建方法</h3><p>在平时我们构造函数的时候一般是这样实现的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// 构造函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">aQuery.prototype = &#123;</div><div class="line">  <span class="comment">// 原型</span></div><div class="line">  name: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  &#125;,</div><div class="line">  <span class="attr">age</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> aQuery(); <span class="comment">// 实例化</span></div><div class="line"></div><div class="line">a.name(); <span class="comment">// 调用</span></div></pre></td></tr></table></figure></p>
<p>而在使用jQuery的时候，并不需要<code>new</code>，而是可以直接调用函数方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$().find().css();</div></pre></td></tr></table></figure></p>
<p>所以可以看到，调用jQuery的时候返回的就是一个函数的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> aQuery();</div><div class="line">&#125; <span class="comment">// 虽然返回了实例，但是会造成死循环</span></div><div class="line"></div><div class="line">aQuery.prototype = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  &#125;,</div><div class="line">  <span class="attr">age</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们用上面的方法来执行<code>aQuery()</code>，会报错。那么应该如何返回一个正确的实例呢？我们可以利用工厂模式来创建对象，并把这个方法放到原型中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> aQuery.prototype.init();</div><div class="line">&#125;</div><div class="line"></div><div class="line">aQuery.prototype = &#123;</div><div class="line">  <span class="attr">init</span>: functionn() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">name</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">age</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时执行<code>aQuery()</code>就会返回一个正确的实例，而在init函数中的this,指向的是aQuery这个对象。如果我们要把init函数也当作一个构造器，那如何让内部的this指向init呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</div><div class="line">  <span class="comment">// The jQuery object is actually just the init constructor 'enhanced'</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>通过实例init函数，每次都构建新的init实例对象，来分隔this，这样在init内部使用的this的指向就会变成了init函数本身。但是这样一来，执行<code>aQuery()</code>后返回的就是init()函数的实例对象，绑定在aQuery原型对象上的方法就无法通过<code>aQuery().name()</code>这种方式去调用了。</p>
<p>如何做到既能隔离作用域还能使用jQuery原型对象的作用域，能在返回的实例中访问jQuery的原型对象呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Give the init function the jQuery prototype for later instantiation</span></div><div class="line">jQuery.fn.init.prototype = jQuery.fn;</div></pre></td></tr></table></figure></p>
<p>通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说，jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> aQuery.prototype.init();</div><div class="line">&#125;</div><div class="line"></div><div class="line">aQuery.prototype = &#123;</div><div class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">name</span>: <span class="string">'xm'</span>,</div><div class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">aQuery.prototype.init.prototype = aQuery.prototype;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(aQuery().getName()); <span class="comment">//xm</span></div></pre></td></tr></table></figure></p>
<h3 id="jQuery方法的调用方式"><a href="#jQuery方法的调用方式" class="headerlink" title="jQuery方法的调用方式"></a>jQuery方法的调用方式</h3><p>▼ <strong>链式调用：</strong></p>
<p><strong>链式调用的原理：</strong>通过简单拓展原型方法并通过<code>return this</code>的形式来实现跨浏览器的链式调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">aQuery.prototype = &#123;</div><div class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">name</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>优点：</strong>节省代码量，提高代码的效率，代码看起来更优雅。<br><strong>缺点：</strong>由于返回的都是对象本身，所以没有返回值，不一定在任何环境下都适用</p>
<p>▼ <strong>插件接口：</strong></p>
<p>从封装的角度讲，为了给jQuery添加属性方法，或是给开发者拓展方法，jQuery提供了<code>jQuery.fn.extend()</code>这个接口，来对对象增加方法。</p>
<h3 id="extend"><a href="#extend" class="headerlink" title="$.extend()"></a>$.extend()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</div><div class="line">      target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;, <span class="comment">// 默认第一个参数为目标对象，对应用法：$.extend(obj1, obj2);</span></div><div class="line">      i = <span class="number">1</span>, <span class="comment">// 标记被合并对象的起始位置</span></div><div class="line">      length = <span class="built_in">arguments</span>.length,</div><div class="line">      deep = <span class="literal">false</span>; <span class="comment">// 判断是否要深拷贝，对应用法：$.extend(true, obj1, obj2);</span></div><div class="line"></div><div class="line">  <span class="comment">// Handle a deep copy situation</span></div><div class="line">  <span class="comment">// 判断target的类型，如果是布尔值，则target和被标记对象的位置都将被改变</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">"boolean"</span> ) &#123;</div><div class="line">    deep = target;</div><div class="line">    target = <span class="built_in">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</div><div class="line">    <span class="comment">// skip the boolean and the target</span></div><div class="line">    i = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></div><div class="line">  <span class="comment">// 在target类型不是对象或函数，则将target看成空对象</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">"object"</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</div><div class="line">    target = &#123;&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// extend jQuery itself if only one argument is passed</span></div><div class="line">  <span class="comment">// 当只传一个参数的时候，目标对象变为jQuery，传入的参数合并到jQuery对象中</span></div><div class="line">  <span class="keyword">if</span> ( length === i ) &#123;</div><div class="line">    target = <span class="keyword">this</span>;</div><div class="line">    --i;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line">    <span class="comment">// Only deal with non-null/undefined values</span></div><div class="line">    <span class="keyword">if</span> ( (options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span> ) &#123;</div><div class="line">      <span class="comment">// Extend the base object</span></div><div class="line">      <span class="keyword">for</span> ( name <span class="keyword">in</span> options ) &#123;</div><div class="line">        src = target[ name ]; <span class="comment">// 目标对象的属性</span></div><div class="line">        copy = options[ name ]; <span class="comment">// 被合并对象的属性</span></div><div class="line"></div><div class="line">        <span class="comment">// Prevent never-ending loop</span></div><div class="line">        <span class="comment">// 当对象属性一致的时候，跳过此属性进行下一个属性的判断</span></div><div class="line">        <span class="keyword">if</span> ( target === copy ) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Recurse if we're merging plain objects or arrays</span></div><div class="line">        <span class="comment">// 深拷贝&amp;&amp;copy不是null或者undefined&amp;&amp;copy是“纯粹的”对象或数组</span></div><div class="line">        <span class="keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123;</div><div class="line">          <span class="comment">// 如果copy是一个数组</span></div><div class="line">          <span class="keyword">if</span> ( copyIsArray ) &#123;</div><div class="line">            copyIsArray = <span class="literal">false</span>;</div><div class="line">            clone = src &amp;&amp; jQuery.isArray(src) ? src : [];<span class="comment">// 该字段用于保存合并目标的属性</span></div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Never move original objects, clone them</span></div><div class="line">          <span class="comment">// 使用了递归</span></div><div class="line">          target[ name ] = jQuery.extend( deep, clone, copy );</div><div class="line"></div><div class="line">        <span class="comment">// Don't bring in undefined values</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</div><div class="line">          target[ name ] = copy;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the modified object</span></div><div class="line">  <span class="keyword">return</span> target;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="细节知识"><a href="#细节知识" class="headerlink" title="细节知识"></a>细节知识</h3><p><code>jQuery.isPlainObject()</code>：用于判断指定参数是否是一个纯粹的对象。纯粹的对象指的是该对象是通过<code>{}</code>或<code>new Object</code>创建的。</p>
<p><strong>示例：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">在当前页面内追加换行标签和指定的HTML内容</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">w</span>(<span class="params"> html </span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.body.innerHTML += <span class="string">"&lt;br/&gt;"</span> + html;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">w( $.isPlainObject( &#123; &#125; ) ); <span class="comment">// true</span></div><div class="line">w( $.isPlainObject( <span class="keyword">new</span> <span class="built_in">Object</span>() ) ); <span class="comment">// true</span></div><div class="line">w( $.isPlainObject( &#123; <span class="attr">name</span>: <span class="string">"CodePlayer"</span>&#125; ) ); <span class="comment">// true</span></div><div class="line">w( $.isPlainObject( &#123; <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; ) ); <span class="comment">// true</span></div><div class="line"></div><div class="line"></div><div class="line">w( $.isPlainObject( <span class="string">"CodePlayer"</span> ) ); <span class="comment">// false</span></div><div class="line">w( $.isPlainObject( <span class="literal">true</span> ) ); <span class="comment">// false</span></div><div class="line">w( $.isPlainObject( <span class="number">12</span> ) ); <span class="comment">// false</span></div><div class="line">w( $.isPlainObject( [ ] ) ); <span class="comment">// false</span></div><div class="line">w( $.isPlainObject( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125; ) ); <span class="comment">// false</span></div><div class="line">w( $.isPlainObject( <span class="built_in">document</span>.location ) ); <span class="comment">// false(在IE中返回true)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"张三"</span>;</div><div class="line">&#125;</div><div class="line">w( $.isPlainObject( <span class="keyword">new</span> Person() ) ); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>学习参考：<br><a href="http://www.cnblogs.com/nuysoft/archive/2011/11/14/2248023.html" target="_blank" rel="external">[原创] jQuery1.6.1源码分析系列（停止更新）</a><br><a href="http://www.cnblogs.com/aaronjs/p/3279314.html" target="_blank" rel="external">jQuery源码分析系列</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h2&gt;&lt;h3 id=&quot;自调用匿名函数&quot;&gt;&lt;a href=&quot;#自调用匿名函数&quot; class=&quot;headerlink&quot; title=&quot;自调用
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>DOM基础知识巩固</title>
    <link href="http://yoursite.com/2017/10/02/17-10-02-22/"/>
    <id>http://yoursite.com/2017/10/02/17-10-02-22/</id>
    <published>2017-10-02T05:15:36.000Z</published>
    <updated>2017-10-19T06:12:22.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM本质"><a href="#DOM本质" class="headerlink" title="DOM本质"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>
<h2 id="DOM节点操作"><a href="#DOM节点操作" class="headerlink" title="DOM节点操作"></a>DOM节点操作</h2><h3 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h3><ul>
<li><code>document.getElementById</code></li>
<li><code>document.getElementsByTagName</code></li>
<li><code>document.getElementsByClassName</code></li>
<li><code>document.querySelectorAll</code></li>
</ul>
<h3 id="property与attribute"><a href="#property与attribute" class="headerlink" title="property与attribute"></a>property与attribute</h3><p>虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。</p>
<ul>
<li>property是DOM中的属性，是JavaScript里的对象；</li>
<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>
</ul>
<p>例如在html中有一段这样的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">sth</span>=<span class="string">"whatever"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们在js中来获取这个DOM对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</div><div class="line"><span class="built_in">console</span>.log(test);</div><div class="line"><span class="built_in">console</span>.log(test.id); <span class="comment">// 'test'</span></div><div class="line"><span class="built_in">console</span>.log(test.value); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(test.sth) <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test-2"</span> &gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test_2 = <span class="built_in">document</span>.getElementById(<span class="string">'test-2'</span>);</div><div class="line"><span class="built_in">console</span>.log(test_2.value); <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>虽然没有在标签中定义<code>value</code>，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：</p>
<ul>
<li>DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。</li>
<li>如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。</li>
</ul>
<p>那么标签上的sth定义在哪里呢？</p>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png" alt=""></p>
<p>也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(test.attibutes.sth); <span class="comment">// 'sth="whatever"'</span></div></pre></td></tr></table></figure></p>
<p>由此可以得出：</p>
<ul>
<li>HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；</li>
<li>这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；</li>
</ul>
<p>那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test.value = <span class="string">'new value of prop'</span>;</div><div class="line"><span class="built_in">console</span>.log(test.value); <span class="comment">// 'new value of prop'</span></div><div class="line"><span class="built_in">console</span>.log(test.arrtibutes.value); <span class="comment">// 'value="1"'</span></div></pre></td></tr></table></figure></p>
<p>如果反过来，效果又是如何呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test.attributes.value = <span class="string">'new value of attr'</span>;</div><div class="line"><span class="built_in">console</span>.log(test.value); <span class="comment">// 'new value of attr'</span></div><div class="line"><span class="built_in">console</span>.log(test.attributes.value); <span class="comment">// 'new value of attr'</span></div></pre></td></tr></table></figure></p>
<p>此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test.attributes.value.nodeValue = <span class="string">'new value of attr'</span>;</div></pre></td></tr></table></figure></p>
<p>由此，可得出结论：</p>
<ul>
<li>property能够从attribute中得到同步；</li>
<li>attribute不会同步property上的值；</li>
<li>attribute和property之间的数据绑定是单向的，attribute-&gt;property；</li>
<li>更改property和attribute上的任意值，都会将更新反映到HTML页面中；</li>
</ul>
<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png" alt=""></p>
<p>有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：</p>
<ul>
<li>减少DOM访问次数</li>
<li>多次访问同一DOM，应该用局部变量缓存该DOM</li>
<li>尽可能使用querySelector，而不是使用获取HTML集合的API</li>
<li>注意重排（reflow）和重绘（repaint）</li>
<li>使用事件委托，减少绑定事件的数量</li>
</ul>
<h3 id="重排（重构）-amp-重绘"><a href="#重排（重构）-amp-重绘" class="headerlink" title="重排（重构）&amp;重绘"></a>重排（重构）&amp;重绘</h3><p>重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：</p>
<ul>
<li>添加或删除DOM元素</li>
<li>元素位置、大小、内容改变</li>
<li>浏览器窗口大小改变</li>
<li>滚动条出现</li>
</ul>
<p><strong>最小化重排、重绘的建议：</strong></p>
<ul>
<li>不要再修改布局信息的时候，去查询布局信息</li>
<li>修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式</li>
<li>:hover会降低响应速度，在处理很大的列表时，避免使用</li>
</ul>
<h2 id="BOM操作"><a href="#BOM操作" class="headerlink" title="BOM操作"></a>BOM操作</h2><p>BOM（Browser Object Model）指的是浏览器对象模型，主要用途：</p>
<ul>
<li>检测浏览器的类型</li>
<li>拆解url的各部分</li>
</ul>
<h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code>对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。<br>常用方法有：</p>
<ul>
<li><code>navigator.userAgent</code> //用户代理头的字符串表示</li>
</ul>
<h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><code>screen</code>对象：用于获取某些关于用户屏幕的信息。<br>常用方法有：</p>
<ul>
<li><code>screen.width/height</code> //屏幕的宽度与高度，以像素计 </li>
<li><code>screen.availWidth/availHeight</code> //窗口可以使用的屏幕的宽度和高度，以像素计 </li>
<li><code>screen.colorDepth</code> //用户表示颜色的位数，大多数系统采用32位 </li>
<li><code>window.moveTo(0, 0);</code></li>
<li><code>window.resizeTo(screen.availWidth, screen.availHeight);</code> //填充用户的屏幕</li>
</ul>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><code>location</code>对象：表示载入窗口的URL。<br>常用方法有：</p>
<ul>
<li><code>location.href</code> //当前载入页面的完整URL</li>
<li><code>location.portocol</code> //URL中使用的协议，即双斜杠之前的部分，如http</li>
<li><code>location.host</code> //服务器的名字，如www.wrox.com</li>
<li><code>location.hostname</code> //通常等于host，有时会省略前面的www</li>
<li><code>location.port</code> //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080</li>
<li><code>location.pathname</code> //URL中主机名后的部分，如/pictures/index.htm</li>
<li><code>location.search</code> //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx</li>
<li><code>location.hash</code> //如果URL包含#，返回该符号之后的内容，如#anchor1</li>
<li><code>location.assign(&quot;http:www.baidu.com&quot;);</code> //同location.href，新地址都会被加到浏览器的历史栈中</li>
<li><code>location.replace(&quot;http:www.baidu.com&quot;);</code> //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问</li>
<li><code>location.reload(true | false);</code> //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false</li>
</ul>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p><code>history</code>对象：浏览器窗口的历史<br>常用方法有：</p>
<ul>
<li><code>history.go(-1);</code> //访问浏览器窗口的历史，负数为后退，正数为前进</li>
<li><code>history.back();</code> //同上</li>
<li><code>history.forward();</code> //同上</li>
<li><code>history.length</code> //可以查看历史中的页面数</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DOM本质&quot;&gt;&lt;a href=&quot;#DOM本质&quot; class=&quot;headerlink&quot; title=&quot;DOM本质&quot;&gt;&lt;/a&gt;DOM本质&lt;/h2&gt;&lt;p&gt;DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
      <category term="BOM" scheme="http://yoursite.com/tags/BOM/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>JS定时器与单线程</title>
    <link href="http://yoursite.com/2017/09/25/17-09-25-21/"/>
    <id>http://yoursite.com/2017/09/25/17-09-25-21/</id>
    <published>2017-09-25T13:28:25.000Z</published>
    <updated>2017-10-19T06:12:17.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript单线程"><a href="#JavaScript单线程" class="headerlink" title="JavaScript单线程"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>
<p>这里有个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="comment">//打印才进入时的时间</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'first time: '</span> + date.getTime());</div><div class="line"><span class="comment">//一秒后打印setTimeout里匿名函数的时间</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'second time: '</span> + date1.getTime() );</div><div class="line">  <span class="built_in">console</span>.log( date1.getTime() - date.getTime() );</div><div class="line">&#125;,<span class="number">1000</span>);</div><div class="line"><span class="comment">//重复操作</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10000</span> ; i++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>setTimeout</code>是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。</p>
<p>其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以<code>setTimeout</code>只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。</p>
<p>但是这里仍然有一个疑问，假设<code>setTimeout</code>后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那<code>setTimeout</code>会在紧跟着的第一个函数执行完就插队执行吗？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"hellow world"</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime &lt; <span class="number">1000</span>) &#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"wait"</span>);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<p>答案是并不会，<code>setTimeout</code>只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出<code>hellow world</code>。</p>
<h2 id="JavaScript运行机制"><a href="#JavaScript运行机制" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h2><p>我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>所以当一段代码有异步操作时，执行过程是这样的：</p>
<ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>
<li>主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。</li>
<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ul>
<p>所以，<strong>只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。</strong></p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p>
<p>主线程不断从“任务队列”中读取事件的过程又称为<strong>Event Loop</strong>。</p>
<h2 id="setTimeout与setInterval"><a href="#setTimeout与setInterval" class="headerlink" title="setTimeout与setInterval"></a>setTimeout与setInterval</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>关于<code>setTimeout</code>在上述已经说的蛮清楚了，还有一点是关于<code>setTimeout(func,0)</code>。<br>当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，<code>setTimeout(func,0)</code>相当于插了队。</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p><code>setInterval</code>是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他<strong>代码实例</strong>时，才能将定时器代码添加到任务队列中。</p>
<p>假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时<code>setInterval</code>的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">Date</span>.now - startTime &lt; <span class="number">350</span>) &#123;&#125;</div><div class="line">&#125;, <span class="number">200</span>);</div><div class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="keyword">while</span>(<span class="built_in">Date</span>.now() - startTime &lt; <span class="number">300</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<p>由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：</p>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png" alt=""></p>
<p>在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。</p>
<p>所以在使用setInterval做动画时要注意两个问题：</p>
<ul>
<li>不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间</li>
<li>如果主进程运行时间过长，会出现跳帧的现象</li>
</ul>
<p>为了避免setInterval的两个缺点，可以使用链式<code>setTimeout()</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;     //其他处理</div><div class="line">  setTimeout(arguments.callee, interval); &#125;, interval);</div></pre></td></tr></table></figure></p>
<p>文章参考：<br><a href="https://yq.aliyun.com/wenji/1646" target="_blank" rel="external">Javascript定时器学习笔记</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">阮一峰 —— JavaScript 运行机制详解：再谈Event Loop</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript单线程&quot;&gt;&lt;a href=&quot;#JavaScript单线程&quot; class=&quot;headerlink&quot; title=&quot;JavaScript单线程&quot;&gt;&lt;/a&gt;JavaScript单线程&lt;/h2&gt;&lt;p&gt;众所周知，JavaScript语言是单线程的，简而言
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS变量计算</title>
    <link href="http://yoursite.com/2017/08/24/17-08-24-20/"/>
    <id>http://yoursite.com/2017/08/24/17-08-24-20/</id>
    <published>2017-08-24T12:53:29.000Z</published>
    <updated>2017-10-19T06:12:12.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></div><div class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">// string</span></div><div class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// number</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></div><div class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// function</span></div></pre></td></tr></table></figure>
<h2 id="变量运算-强制类型转换"><a href="#变量运算-强制类型转换" class="headerlink" title="变量运算 - 强制类型转换"></a>变量运算 - 强制类型转换</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">100</span> + <span class="number">10</span> <span class="comment">// 110</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">100</span> + <span class="string">'10'</span> <span class="comment">// '10010'</span></div></pre></td></tr></table></figure>
<p>当使用减运算时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c = <span class="string">'100'</span> - <span class="number">10</span> <span class="comment">// 90</span></div></pre></td></tr></table></figure></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">100</span> == <span class="string">'100'</span> <span class="comment">// true</span></div><div class="line"><span class="number">0</span> == <span class="string">''</span> <span class="comment">// true</span></div><div class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>==</code>与<code>===</code>的区别：<code>===</code>是严格等于，只有类型完全相同才会返回<code>true</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="literal">null</span> === <span class="literal">null</span></div><div class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span></div><div class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></div><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>什么时候用<code>==</code>什么时候用<code>===</code>：jQuery源码中推荐写法，只有下述情况才用<code>==</code>，其他时候都用<code>===</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(a == <span class="literal">null</span>) &#123;</div><div class="line">  <span class="comment">// 这里相当于 a === null || a === undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span>(a) &#123; <span class="comment">//... &#125; </span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">100</span>; <span class="comment">// true</span></div><div class="line"><span class="keyword">if</span>(b) &#123; <span class="comment">//... &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="string">''</span>; <span class="comment">// false</span></div><div class="line"><span class="keyword">if</span>(c) &#123; <span class="comment">//... &#125;</span></div></pre></td></tr></table></figure>
<p><code>if</code>中被判定为<code>false</code>的几个值：<code>0</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>null</code>,<code>undefined</code></p>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">10</span> &amp;&amp; <span class="number">0</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">''</span> || <span class="string">'abc'</span>) <span class="comment">// 'abc'</span></div><div class="line"><span class="built_in">console</span>.log(!<span class="built_in">window</span>.abc) <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 判断一个变量会被当做 true 还是 false</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(!!a) <span class="comment">//true</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;typeof-运算符&quot;&gt;&lt;a href=&quot;#typeof-运算符&quot; class=&quot;headerlink&quot; title=&quot;typeof 运算符&quot;&gt;&lt;/a&gt;typeof 运算符&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;tab
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>页面加载——浏览器渲染</title>
    <link href="http://yoursite.com/2017/08/19/17-08-19-19/"/>
    <id>http://yoursite.com/2017/08/19/17-08-19-19/</id>
    <published>2017-08-19T10:46:53.000Z</published>
    <updated>2017-10-19T08:39:15.740Z</updated>
    
    <content type="html"><![CDATA[<p>一个网站在浏览器端是如何进行渲染的呢？</p>
<ul>
<li>根据HTML结构生成<code>DOM tree</code></li>
<li>根据CSS生成<code>CSSOM</code></li>
<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>
<li>根据<code>RenderTree</code>开始渲染和展示</li>
<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>
</ul>
<h2 id="顺序执行、并发加载"><a href="#顺序执行、并发加载" class="headerlink" title="顺序执行、并发加载"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>
<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 页面的全部资源加载完才会执行，包括图片、视频</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><h3 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h3><ul>
<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>
<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>
<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>
</ul>
<h3 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h3><ul>
<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>
<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>
<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>
</ul>
<h2 id="引入方法"><a href="#引入方法" class="headerlink" title="引入方法"></a>引入方法</h2><h3 id="脚本的位置"><a href="#脚本的位置" class="headerlink" title="脚本的位置"></a>脚本的位置</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>
<h3 id="无阻塞脚本"><a href="#无阻塞脚本" class="headerlink" title="无阻塞脚本"></a>无阻塞脚本</h3><ul>
<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Defer Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"defer"</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"script"</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"load"</span>);</div><div class="line">        &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>
<ul>
<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>
</ul>
<h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</div><div class="line"></div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.src = <span class="string">"script1.js"</span>;</div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</div></pre></td></tr></table></figure>
<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</div><div class="line"></div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Script loaded!"</span>);</div><div class="line">&#125;;</div><div class="line">script.src = <span class="string">"script1.js"</span>;</div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</div></pre></td></tr></table></figure>
<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>
<blockquote>
<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line"></div><div class="line"><span class="comment">//Internet Explorer</span></div><div class="line">script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>)&#123;</div><div class="line">    script.onreadystatechange = <span class="literal">null</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Script loaded."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">script.src = <span class="string">"script1.js"</span>;</div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</div></pre></td></tr></table></figure>
<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.creatElement(<span class="string">"script"</span>);</div><div class="line">  script.type = <span class="string">"text/javascript"</span>;</div><div class="line">  <span class="keyword">if</span>(script.readyState) &#123;</div><div class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>) &#123;</div><div class="line">        script.onreadystatechange = <span class="literal">null</span>;</div><div class="line">        callback();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      callback();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  script.src = url;</div><div class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loadScript(<span class="string">"script1.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  loadScript(<span class="string">"script2.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="string">"all files are loaded!"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="XMLHttpRequest-XHR-对象"><a href="#XMLHttpRequest-XHR-对象" class="headerlink" title="XMLHttpRequest(XHR)对象"></a>XMLHttpRequest(XHR)对象</h3><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个网站在浏览器端是如何进行渲染的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据HTML结构生成&lt;code&gt;DOM tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据CSS生成&lt;code&gt;CSSOM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;CSSO
    
    </summary>
    
    
      <category term="知识碎片" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>网络知识补充——浏览器请求过程</title>
    <link href="http://yoursite.com/2017/08/17/17-08-17-18/"/>
    <id>http://yoursite.com/2017/08/17/17-08-17-18/</id>
    <published>2017-08-17T12:49:56.000Z</published>
    <updated>2017-10-19T08:39:08.041Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？</p>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png" alt=""></p>
<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>
<ul>
<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>
<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>
<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>
<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>
</ul>
<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>
<ul>
<li>查找本地缓存</li>
<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>
<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>
</ul>
<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>
<h3 id="域名空间结构"><a href="#域名空间结构" class="headerlink" title="域名空间结构"></a>域名空间结构</h3><ul>
<li>根域：<code>.</code>，根域名的服务器只有13台</li>
<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>
<ul>
<li><p>组织域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gov         政府部门</div><div class="line">com         商业部门</div><div class="line">edu         教育部门</div><div class="line">org         民间团体组织</div><div class="line">net         网络服务机构</div><div class="line">mil         军事部门</div></pre></td></tr></table></figure>
</li>
<li><p>国家或地区域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cn          中国</div><div class="line">jp          日本</div><div class="line">uk          英国</div><div class="line">au          澳大利亚</div><div class="line">hk          中国香港</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>
</li>
<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>
</ul>
<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>
<h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png" alt=""></p>
<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>
<h2 id="ISO-OSI-七层模型"><a href="#ISO-OSI-七层模型" class="headerlink" title="ISO/OSI 七层模型"></a>ISO/OSI 七层模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>ISO：国际标准化组织</li>
<li>OSI：开放系统互联模型</li>
<li>IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统</li>
<li>OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。</li>
</ul>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png" alt=""></p>
<p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。<br><strong>注意点：</strong>各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。</p>
<p><strong>为什么要进行分层？</strong></p>
<p>因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。</p>
<p><strong>传输单位：</strong></p>
<ul>
<li>比特：bit，机器码的传输单位，每个0或1就是一个比特。</li>
<li>帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。</li>
<li>报文：保存的基本信息为IP地址（负责外网通信）。</li>
<li>TPDU：传输协议数据单元。</li>
<li>APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。</li>
</ul>
<h3 id="七层详解"><a href="#七层详解" class="headerlink" title="七层详解"></a>七层详解</h3><ul>
<li>物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）</li>
<li>数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。</li>
<li>网络层：提供逻辑地址（IP）、选路。</li>
<li>传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）</li>
<li>会话层：对应用会话的管理、同步。</li>
<li>表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。</li>
<li>应用层：用户接口（可以理解为各自桌面应用）。</li>
</ul>
<h2 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>网络接口层：与OSI参考模型中的<strong>物理层</strong>和<strong>数据链路层</strong>相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。<strong>地址解析协议（ARP）</strong>工作在此层，即OSI参考模型的数据链路层。</li>
<li>网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：<strong>网际协议（IP）</strong>、<strong>互联网组管理协议（IGMP）</strong>和<strong>互联网控制报文协议（ICMP）</strong>。</li>
<li>传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：<strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议（UDP）</strong>。</li>
<li>应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png" alt=""></p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>共同点：<ul>
<li>都采用了层次结构的概念；</li>
<li>都能够提供面向连接和无连接两种通信服务机制；</li>
</ul>
</li>
<li>不同点：<ul>
<li>前者七层模型，后者四层结构；</li>
<li>对可靠性的要求不同（后者更高）；</li>
<li>OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。</li>
<li>实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。</li>
</ul>
</li>
</ul>
<h2 id="TCP-IP-通信"><a href="#TCP-IP-通信" class="headerlink" title="TCP/IP 通信"></a>TCP/IP 通信</h2><p><strong>当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？</strong></p>
<p>首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是<strong>IP地址</strong>和<strong>MAC地址</strong>（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p>
<p><strong>APR协议：</strong>通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。<br><strong>路由选择：</strong>在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP协议位于传输层，提供可靠的字节流服务。其中<strong>字节流服务</strong>是指，将大块的数据分割成以报文为单位的数据包进行管理。<strong>可靠的传输服务</strong>是指能够把数据准确可靠的传给对方。</p>
<p><strong>三次握手：</strong>为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。</p>
<p>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>
<blockquote>
<p><strong>「我给你讲个TCP的笑话吧」</strong></p>
<p>“我给你讲一个TCP的笑话吧？”<br>“给我讲一个TCP笑话呗！”<br>“好的，我会给你讲一个TCP的笑话。”</p>
</blockquote>
<p><strong>TCP与UDP比较：</strong>UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在浏览器中输入一个url，页面是如何呈现出来的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="知识碎片" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>JS面向对象学习笔记</title>
    <link href="http://yoursite.com/2017/08/16/17-08-16-17/"/>
    <id>http://yoursite.com/2017/08/16/17-08-16-17/</id>
    <published>2017-08-16T13:20:29.000Z</published>
    <updated>2017-10-19T08:25:54.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象（OOP）的概念"><a href="#面向对象（OOP）的概念" class="headerlink" title="面向对象（OOP）的概念"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>
<ul>
<li>一切事物皆对象</li>
<li>对象具有封装和继承特性</li>
<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>
</ul>
<p><strong>对象有哪些特性？</strong></p>
<ul>
<li><strong>封装性：</strong>通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。</li>
<li><strong>继承：</strong>很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。</li>
<li><strong>多态：</strong>多态指的不同类的对象对同一消息作出不同的响应。</li>
</ul>
<p><strong>面向对象的优点：</strong>易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。</p>
<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>
<h3 id="基于类vs基于原型"><a href="#基于类vs基于原型" class="headerlink" title="基于类vs基于原型"></a>基于类vs基于原型</h3><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>
<ul>
<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>
<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  String name;</div><div class="line">  <span class="keyword">int</span> age;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">walking</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleeping</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  Person(x,y) &#123;</div><div class="line">    name = x;</div><div class="line">    age = y;</div><div class="line">  &#125;<span class="comment">//类的构造函数</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//实例化</span></div><div class="line">Person xm = <span class="keyword">new</span> Person(<span class="string">'xm'</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure>
<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xm = <span class="keyword">new</span> Person(<span class="string">'xm'</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure></p>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>
<ul>
<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>
<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>
</ul>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>
<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>
<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>
<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png" alt=""></p>
<h3 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h3><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul>
<li>基于Object对象创建</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">'xm'</span>;</div><div class="line">person.age = <span class="number">18</span>;</div><div class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>字面量的方式：清晰的查找对象包含的属性和方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'xm'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">18</span>,</div><div class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">functioni createPerson(name,age) &#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = createPerson(<span class="string">'xm'</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure>
<ul>
<li>构造函数模式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'xm'</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure>
<ul>
<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</div><div class="line">obj.hasOwnProperty(<span class="string">'x'</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象（OOP）的概念&quot;&gt;&lt;a href=&quot;#面向对象（OOP）的概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象（OOP）的概念&quot;&gt;&lt;/a&gt;面向对象（OOP）的概念&lt;/h2&gt;&lt;p&gt;对于面向对象，有以下几个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS变量、作用域和内存问题</title>
    <link href="http://yoursite.com/2017/08/15/17-08-15-16/"/>
    <id>http://yoursite.com/2017/08/15/17-08-15-16/</id>
    <published>2017-08-15T12:30:52.000Z</published>
    <updated>2018-06-16T01:48:33.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>
<ul>
<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>
<li><strong>引用类型：</strong>数组，对象，函数</li>
<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改<a id="more"></a>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//eg1</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">4</span>;</div><div class="line">num = <span class="number">3</span>; <span class="comment">//这里的值操作并不是修改，而是覆盖</span></div><div class="line"></div><div class="line"><span class="comment">//eg2</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</div><div class="line"><span class="keyword">var</span> anotherStr = str.replace(<span class="string">'s'</span>,<span class="string">''</span>); </div><div class="line"><span class="comment">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></div></pre></td></tr></table></figure>
<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>
<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png" alt=""></p>
<h3 id="变量的比较"><a href="#变量的比较" class="headerlink" title="变量的比较"></a>变量的比较</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本类型的比较</span></div><div class="line"><span class="keyword">var</span> xmScore = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> xhScore =<span class="number">4</span>;</div><div class="line"><span class="built_in">console</span>.log(xmScore === xhScore) <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//引用类型的比较</span></div><div class="line"><span class="keyword">var</span> xm = &#123;</div><div class="line">  <span class="attr">age</span>: <span class="number">18</span>,</div><div class="line">  <span class="attr">score</span>: <span class="number">4</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> xh = &#123;</div><div class="line">  <span class="attr">age</span>: <span class="number">18</span>,</div><div class="line">  <span class="attr">score</span>: <span class="number">4</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(xm === xh); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png" alt=""><br><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png" alt=""><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xm = &#123;</div><div class="line">  <span class="attr">age</span>: <span class="number">18</span>,</div><div class="line">  <span class="attr">score</span>: <span class="number">4</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> xh = xm; <span class="comment">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></div><div class="line"><span class="built_in">console</span>.log(xm === xh); <span class="comment">//true;</span></div></pre></td></tr></table></figure>
<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">equalObjs</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> a) &#123;</div><div class="line">    <span class="keyword">if</span>(a[p] !== b[p] <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">equalArrays</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(a.length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i ++) &#123;</div><div class="line">    <span class="keyword">if</span>(a[i] !== b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量的复制"><a href="#变量的复制" class="headerlink" title="变量的复制"></a>变量的复制</h3><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObj</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> newObj = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</div><div class="line">   newObj[p] = obj[p];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>
<ul>
<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125; <span class="comment">// 在函数里声明的a与b是形参</span></div><div class="line">fn(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//在调用函数时传入的参数是实参</span></div></pre></td></tr></table></figure>
<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//eg1 当变量为基本类型时</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> score = <span class="number">10</span>;</div><div class="line">addTen(score);</div><div class="line"><span class="comment">//相当于</span></div><div class="line">num = score;</div><div class="line"></div><div class="line"><span class="comment">//eg2 当变量为引用类型时</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj.name = <span class="string">'xm'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">setName(person);</div></pre></td></tr></table></figure></p>
<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>
<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>
</blockquote>
<h3 id="全局与局部"><a href="#全局与局部" class="headerlink" title="全局与局部"></a>全局与局部</h3><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">999</span>; <span class="comment">//直接在外部声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  i = <span class="number">888</span>; <span class="comment">//在函数内部声明，但是不适用var命令</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</div><div class="line">//等同于</div><div class="line">var i = 0;</div><div class="line">for(i &lt; 10; i ++) &#123; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量的作用域链"><a href="#变量的作用域链" class="headerlink" title="变量的作用域链"></a>变量的作用域链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span>;</div><div class="line">funuction fn(argument) &#123;</div><div class="line">  <span class="keyword">var</span> name = <span class="string">'xh'</span>;</div><div class="line">  <span class="keyword">var</span> sex = <span class="string">'male'</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">argument</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'xhei'</span>;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">18</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src="https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png" alt=""></p>
<ul>
<li><strong>延长作用域链</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.name = <span class="string">'xm'</span>;</div><div class="line">person.sex = <span class="string">'male'</span>;</div><div class="line"><span class="keyword">var</span> score = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="keyword">with</span>(person) &#123;</div><div class="line">  name = <span class="string">'xh'</span>;</div><div class="line">  sex = <span class="string">'female'</span>;</div><div class="line">  score = <span class="number">44</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xh</span></div><div class="line"><span class="built_in">console</span>.log(person.sex); <span class="comment">//female</span></div><div class="line"><span class="built_in">console</span>.log(score); <span class="comment">//44</span></div></pre></td></tr></table></figure>
<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>
<ul>
<li><strong>闭包</strong></li>
</ul>
<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(n); <span class="comment">//999</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> f2; <span class="comment">//将f2作为返回值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = f1();</div><div class="line">result(); <span class="comment">//999</span></div></pre></td></tr></table></figure></p>
<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>
<ul>
<li><strong>闭包的两个用途</strong>：<ul>
<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>
<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>
</ul>
</li>
</ul>
<h3 id="JS解析机制-预解析"><a href="#JS解析机制-预解析" class="headerlink" title="JS解析机制-预解析"></a>JS解析机制-预解析</h3><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span>;</div><div class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">argument</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(name);</div><div class="line">  <span class="keyword">var</span> name = <span class="string">'xh'</span>;</div><div class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line">fn(); <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//window域预解析</span></div><div class="line"><span class="keyword">var</span> name = undefiied;</div><div class="line"><span class="keyword">var</span> age = <span class="literal">undefined</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">argument</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(name);</div><div class="line">  <span class="keyword">var</span> name = <span class="string">'xh'</span>;</div><div class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//fn域预解析</span></div><div class="line"><span class="keyword">var</span> name = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">var</span> age = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="comment">//逐行解析</span></div><div class="line">name = <span class="string">'xm'</span>;</div><div class="line">age = <span class="number">18</span>;</div><div class="line">fn(argument) &#123;</div><div class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</span></div><div class="line">  name = <span class="string">'xh'</span>;</div><div class="line">  age = <span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="number">1</span>; <span class="comment">//预解析不解析没有var的变量，所以浏览器会报错</span></div></pre></td></tr></table></figure></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>
<ul>
<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>
<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>
<li><strong>循环引用问题：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">argument</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> xm = &#123;&#125;; <span class="comment">//1</span></div><div class="line">  <span class="keyword">var</span> xh = &#123;&#125;; <span class="comment">//1</span></div><div class="line">&#125;</div><div class="line">fun();</div><div class="line">xm = <span class="literal">null</span>; <span class="comment">//0</span></div><div class="line">xh = <span class="literal">null</span>; <span class="comment">//0</span></div><div class="line"></div><div class="line">functioni fn(argument) &#123;</div><div class="line">  <span class="keyword">var</span> xm = &#123;&#125;; <span class="comment">//1</span></div><div class="line">  <span class="keyword">var</span> xh = &#123;&#125;; <span class="comment">//1</span></div><div class="line">  xm.wife = xh; <span class="comment">//2</span></div><div class="line">  xh.husband = xm; <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line">fn();</div><div class="line">xm = <span class="literal">null</span>; <span class="comment">//1</span></div><div class="line">xh = <span class="literal">null</span>; <span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>
<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;&lt;p&gt;在JavaScript中，数据类型分为基本类型和引用类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本类型：&lt;/strong&gt;数字，字符，布尔值，undefined，null&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用类型：&lt;/strong&gt;数组，对象，函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区别：&lt;/strong&gt;基本类型的值是可以修改的，而引用类型的值不可修改
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>异步编程之promise与trigger</title>
    <link href="http://yoursite.com/2017/07/15/17-07-15-15/"/>
    <id>http://yoursite.com/2017/07/15/17-07-15-15/</id>
    <published>2017-07-15T08:13:01.000Z</published>
    <updated>2017-10-19T08:38:20.788Z</updated>
    
    <content type="html"><![CDATA[<p>这周的学习任务：<code>promise</code>与<code>trigger</code></p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><blockquote>
<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>
</blockquote>
<h3 id="实现异步编程的四种方法"><a href="#实现异步编程的四种方法" class="headerlink" title="实现异步编程的四种方法"></a>实现异步编程的四种方法</h3><ul>
<li><strong>回调函数</strong></li>
</ul>
<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f1(); <span class="comment">//一个十分耗时的函数</span></div><div class="line">f2(); <span class="comment">//等待f1执行完才能执行的函数</span></div><div class="line">f3(); <span class="comment">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>
<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="comment">//f1执行代码</span></div><div class="line">  callback();</div><div class="line">&#125;</div><div class="line"></div><div class="line">f1(f2);</div><div class="line">f3();</div></pre></td></tr></table></figure></p>
<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<ul>
<li><strong>事件监听</strong></li>
</ul>
<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f1.on(<span class="string">'click'</span>,f2); <span class="comment">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>
<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $<span class="literal">null</span> = $(&#123;&#125;); <span class="comment">//绑定空对象</span></div><div class="line"><span class="keyword">var</span> hideEvent = $.Event(<span class="string">'hide.tab'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//f1执行代码</span></div><div class="line">  f1.trigger(<span class="string">'hide.tab'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$<span class="literal">null</span>.on(<span class="string">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>
<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<ul>
<li><strong>发布/订阅</strong></li>
</ul>
<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jQuery.subscribe(<span class="string">'done'</span>,f2); <span class="comment">//通过订阅中心jQuery订阅"done"信号</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//f1执行代码</span></div><div class="line">  jQuery.public(<span class="string">'done'</span>); <span class="comment">//f1执行完后，向信号中心发布"done"信号，引发f2执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">jQuery.unsubscribe(<span class="string">'done'</span>,f2); <span class="comment">//取消订阅</span></div></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<ul>
<li><strong>deferred对象</strong></li>
</ul>
<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">f1().then(f2);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">　<span class="comment">// f1的任务代码</span></div><div class="line">　dfd.resolve();</div><div class="line">　<span class="keyword">return</span> dfd.promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>
<h2 id="deferred对象详解"><a href="#deferred对象详解" class="headerlink" title="deferred对象详解"></a>deferred对象详解</h2><h3 id="deferred对象的应用场景"><a href="#deferred对象的应用场景" class="headerlink" title="deferred对象的应用场景"></a>deferred对象的应用场景</h3><ul>
<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>
<li><strong>优化ajax的嵌套执行</strong></li>
</ul>
<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">"test.html"</span>,</div><div class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      <span class="attr">url</span>: ...,</div><div class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ....</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们可以将两个<code>ajax</code>分开封装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">"test.html"</span>,</div><div class="line">    ...</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">"..."</span>,</div><div class="line">    ...</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$.when(A(),B()).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  dosth();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><ul>
<li><code>$.Deferred()</code>：生成一个deferred对象</li>
<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>
<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>
<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>
<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>
<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>
<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>
<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的学习任务：&lt;code&gt;promise&lt;/code&gt;与&lt;code&gt;trigger&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;异步编程&quot;&gt;&lt;a href=&quot;#异步编程&quot; class=&quot;headerlink&quot; title=&quot;异步编程&quot;&gt;&lt;/a&gt;异步编程&lt;/h2&gt;&lt;blockqu
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>搭建Hexo博客之后</title>
    <link href="http://yoursite.com/2017/07/15/17-07-15-14/"/>
    <id>http://yoursite.com/2017/07/15/17-07-15-14/</id>
    <published>2017-07-15T06:59:11.000Z</published>
    <updated>2017-10-19T08:38:07.627Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>
<h2 id="使用分支方法解决hexo博客无法在两台电脑上更新的问题"><a href="#使用分支方法解决hexo博客无法在两台电脑上更新的问题" class="headerlink" title="使用分支方法解决hexo博客无法在两台电脑上更新的问题"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ touch README.md</div><div class="line">$ git init </div><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;first commit&quot;</div><div class="line">$ git remote add origin 你的项目地址</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure></p>
<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git pull --rebase origin master</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure></p>
<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>
<h3 id="创建hexo分支"><a href="#创建hexo分支" class="headerlink" title="创建hexo分支"></a>创建hexo分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch hexo</div><div class="line">$ git push origin hexo</div></pre></td></tr></table></figure>
<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>
<h3 id="在hexo分支中安装hexo"><a href="#在hexo分支中安装hexo" class="headerlink" title="在hexo分支中安装hexo"></a>在hexo分支中安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout hexo</div><div class="line">$ npm install hexo</div><div class="line">$ hexo init</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="external">hexo-git-backup</a><br>安装指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>
<h3 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置_config.yml文件</h3><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line">	<span class="attr">type:</span> <span class="string">git</span> <span class="comment">#部署类型，使用github</span></div><div class="line">	<span class="attr">repository:</span> <span class="comment">#你的项目地址</span></div><div class="line">	<span class="attr">branch:</span> <span class="string">master</span> <span class="comment">#部署分支，必须是master</span></div><div class="line">	<span class="attr">message:</span> <span class="string">update</span> <span class="comment">#默认类型</span></div><div class="line"></div><div class="line"><span class="comment">#我们还需要添加那个插件的功能</span></div><div class="line"><span class="attr">backup:</span></div><div class="line">	<span class="attr">type:</span> <span class="string">git</span></div><div class="line">	<span class="attr">repository:</span></div><div class="line">		<span class="attr">github:</span> <span class="string">项目地址,hexo</span> <span class="comment">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>
<p>然后我们在执行一下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo g </div><div class="line">$ hexo d //部署博客</div><div class="line">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>
<p>然后，事情就完美的解决啦~~</p>
<h3 id="更换电脑后的操作"><a href="#更换电脑后的操作" class="headerlink" title="更换电脑后的操作"></a>更换电脑后的操作</h3><ul>
<li>使用<code>git clone</code>将远程仓库克隆到本地</li>
<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？&lt;br&gt;然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。&lt;br&gt;恩，然后找到了方法，然
    
    </summary>
    
    
      <category term="知识碎片" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>JS之this指针笔记</title>
    <link href="http://yoursite.com/2017/07/08/17-07-08-13/"/>
    <id>http://yoursite.com/2017/07/08/17-07-08-13/</id>
    <published>2017-07-08T05:48:43.000Z</published>
    <updated>2017-10-19T08:38:29.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><blockquote>
<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>
</blockquote>
<ul>
<li><p><strong>定义在全局中的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>; <span class="comment">//此处的this指的是window</span></div><div class="line">&#125;</div><div class="line">x = <span class="number">0</span>; <span class="comment">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>作为对象方法的调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">o.x = <span class="number">1</span>;</div><div class="line">o.m = test;</div><div class="line">o.m(); <span class="comment">//1</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>作为构造函数调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">test</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">  &#125; <span class="comment">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="this指向的改变"><a href="#this指向的改变" class="headerlink" title="this指向的改变"></a>this指向的改变</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">test</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class="line">    $(<span class="keyword">this</span>.xx).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class="line">    &#125;)</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在javascript中有几个函数是可以改变this的指向的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xm = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"小明"</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">"男"</span>,</div><div class="line">  <span class="attr">age</span>: <span class="string">"18"</span>,</div><div class="line">  <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name + <span class="string">","</span> + <span class="keyword">this</span>.sex + <span class="string">","</span> + <span class="keyword">this</span>.age);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xh = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"小红"</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">"女"</span>,</div><div class="line">  <span class="attr">age</span>: <span class="string">"20"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xm.say.apply(xh); <span class="comment">//小红,女,20</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xm.say.call(xh); <span class="comment">//小红,女,20</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xm.say.bind(xh)(); <span class="comment">//小红,女,20</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.txt = <span class="string">"这是一个对象属性"</span>;</div><div class="line">  $(<span class="string">"div"</span>).click($.proxy(<span class="keyword">this</span>.myClick,<span class="keyword">this</span>));</div><div class="line">  <span class="comment">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">test.prototype.myClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.txt);</div><div class="line">  alert(event.currentTarget.nodeName);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> test();</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this指针&quot;&gt;&lt;a href=&quot;#this指针&quot; class=&quot;headerlink&quot; title=&quot;this指针&quot;&gt;&lt;/a&gt;this指针&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
