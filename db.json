{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/buildTool.jpg","path":"images/buildTool.jpg","modified":0,"renderable":0},{"_id":"source/images/canvas-img-1.png","path":"images/canvas-img-1.png","modified":0,"renderable":0},{"_id":"source/images/cmd-1.png","path":"images/cmd-1.png","modified":0,"renderable":0},{"_id":"source/images/cmd-2.png","path":"images/cmd-2.png","modified":0,"renderable":0},{"_id":"source/images/cmd-3.png","path":"images/cmd-3.png","modified":0,"renderable":0},{"_id":"source/images/cmd-4.png","path":"images/cmd-4.png","modified":0,"renderable":0},{"_id":"source/images/dom-1.png","path":"images/dom-1.png","modified":0,"renderable":0},{"_id":"source/images/http-2.png","path":"images/http-2.png","modified":0,"renderable":0},{"_id":"source/images/http.png","path":"images/http.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-2.png","path":"images/iconfont-img-2.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-3.png","path":"images/iconfont-img-3.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-4.png","path":"images/iconfont-img-4.png","modified":0,"renderable":0},{"_id":"source/images/jicheng-1.png","path":"images/jicheng-1.png","modified":0,"renderable":0},{"_id":"source/images/jicheng-2.png","path":"images/jicheng-2.png","modified":0,"renderable":0},{"_id":"source/images/mvc.png","path":"images/mvc.png","modified":0,"renderable":0},{"_id":"source/images/mvvm.png","path":"images/mvvm.png","modified":0,"renderable":0},{"_id":"source/images/osi.png","path":"images/osi.png","modified":0,"renderable":0},{"_id":"source/images/stack&heap-1.png","path":"images/stack&heap-1.png","modified":0,"renderable":0},{"_id":"source/images/stack&heap-2.png","path":"images/stack&heap-2.png","modified":0,"renderable":0},{"_id":"source/images/stack&heap-3.png","path":"images/stack&heap-3.png","modified":0,"renderable":0},{"_id":"source/images/tcp-ip.png","path":"images/tcp-ip.png","modified":0,"renderable":0},{"_id":"source/images/variable-1.png","path":"images/variable-1.png","modified":0,"renderable":0},{"_id":"source/images/vuejs.png","path":"images/vuejs.png","modified":0,"renderable":0},{"_id":"source/images/webpack-1.png","path":"images/webpack-1.png","modified":0,"renderable":0},{"_id":"source/images/dom-2.png","path":"images/dom-2.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-1.png","path":"images/iconfont-img-1.png","modified":0,"renderable":0},{"_id":"source/images/prototype.png","path":"images/prototype.png","modified":0,"renderable":0},{"_id":"source/images/settimeout.png","path":"images/settimeout.png","modified":0,"renderable":0},{"_id":"themes/bmw/source/css/base.css","path":"css/base.css","modified":0,"renderable":1},{"_id":"themes/bmw/source/css/base.css.map","path":"css/base.css.map","modified":0,"renderable":1},{"_id":"themes/bmw/source/css/github-markdown.css","path":"css/github-markdown.css","modified":0,"renderable":1},{"_id":"themes/bmw/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/bmw/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/demo_fontclass.html","path":"icon/demo_fontclass.html","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/iconfont.css","path":"icon/iconfont.css","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/iconfont.eot","path":"icon/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/iconfont.js","path":"icon/iconfont.js","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/iconfont.svg","path":"icon/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/iconfont.ttf","path":"icon/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/bmw/source/icon/iconfont.woff","path":"icon/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/bmw/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/bmw/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/bmw/source/images/touch-icon.png","path":"images/touch-icon.png","modified":0,"renderable":1},{"_id":"themes/bmw/source/images/wechat.png","path":"images/wechat.png","modified":0,"renderable":1},{"_id":"themes/bmw/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/animation.scss","path":"scss/animation.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/article.scss","path":"scss/article.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/base.scss","path":"scss/base.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/mathjax.scss","path":"scss/mathjax.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/vcomments.scss","path":"scss/vcomments.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/stylus/highlight.styl","path":"stylus/highlight.styl","modified":0,"renderable":1},{"_id":"themes/bmw/source/js/valine.min.js","path":"js/valine.min.js","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/about.scss","path":"scss/layout/about.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/category.scss","path":"scss/layout/category.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/friend.scss","path":"scss/layout/friend.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/home.scss","path":"scss/layout/home.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/index.scss","path":"scss/layout/index.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/post.scss","path":"scss/layout/post.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/layout/tag.scss","path":"scss/layout/tag.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/partial/footer.scss","path":"scss/partial/footer.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/partial/navigation.scss","path":"scss/partial/navigation.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/partial/reward.scss","path":"scss/partial/reward.scss","modified":0,"renderable":1},{"_id":"themes/bmw/source/scss/partial/timeline.scss","path":"scss/partial/timeline.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/bmw/.gitignore","hash":"249186d37752b254b54734e92f6bf242deda1c3a","modified":1578496973352},{"_id":"themes/bmw/LICENSE","hash":"ecd7addf36fdeb14bcef981bfbe7aa121810ac30","modified":1578496973352},{"_id":"themes/bmw/README.md","hash":"34a0058243ed01346466a84c8871f117a711f5dc","modified":1578496973352},{"_id":"themes/bmw/_config.yml","hash":"c583ac76c7b59d0edde43be1753b3c7eb35a3750","modified":1578497060165},{"_id":"themes/bmw/demo._config.yml","hash":"24b088ae4975cf17705e173deea711f1fcc9c3eb","modified":1578496973352},{"_id":"source/_posts/AJAX学习笔记.md","hash":"19fd2d60b110c1515fa8258a0cb2294bd16f2328","modified":1578491290782},{"_id":"source/_posts/DOM本质.md","hash":"e9af65872ee240f6303344e6be8ec617310a9fa6","modified":1578491290782},{"_id":"source/_posts/ES6 核心向新特性（01）.md","hash":"c4cbf5908b1af6fb244f3fa13193e74b84ad5c59","modified":1578491290782},{"_id":"source/_posts/ES6 核心向新特性（02）.md","hash":"16645a7cbd4c01b34e172f7dd89a690937401d23","modified":1578491290782},{"_id":"source/_posts/ES6 核心向新特性（03）.md","hash":"685f2414593e62da8544040bc22c17de47a54a20","modified":1578491290782},{"_id":"source/_posts/JSON学习笔记.md","hash":"6525405f91c828a6b476beb87f77bacb61bd124c","modified":1578491290782},{"_id":"source/_posts/JS之this指针笔记.md","hash":"cd1a82336b3b290ae12a96690cb9868f61c336f1","modified":1578491290782},{"_id":"source/_posts/JS变量、作用域和内存问题.md","hash":"c47a874a0da76dc07f9a8f65eccb1654b945f977","modified":1578491290782},{"_id":"source/_posts/JS变量计算.md","hash":"b3fe1c52f1e2bb82cc6a00a7ff57f1f5f21c2d2c","modified":1578491290782},{"_id":"source/_posts/JS继承笔记.md","hash":"a3cfcdeb51f56241d0cf835be5c163af8502f59f","modified":1578491290782},{"_id":"source/_posts/JS面向对象学习笔记.md","hash":"e3f6c1644fd66c67c9e9adb0fb5a41dc106b18a0","modified":1578491290782},{"_id":"source/_posts/JavaScript单线程.md","hash":"ee783b7488ee461d0c4298d711262e5d1208f5d0","modified":1578491290782},{"_id":"source/_posts/JavaScript正则表达式.md","hash":"a025819480883367ccd532d2efb0ebf25b643b1e","modified":1578491290782},{"_id":"source/_posts/Promise详解.md","hash":"25c77ca04209f83b350802ece84f297d50955479","modified":1578492431302},{"_id":"source/_posts/TypeScript学习笔记（基础）.md","hash":"c586865244c46f9245940fb1d860ce4d573f675f","modified":1578491290783},{"_id":"source/_posts/Vue.js学习笔记（01）.md","hash":"76a3bfe035a27be4720b1c44b4e43955ccba685c","modified":1578491290783},{"_id":"source/_posts/Vue.js学习笔记（02）.md","hash":"1198fb1ae61a6604fd965827661a0331e72dc208","modified":1578491290783},{"_id":"source/_posts/Vue.js学习笔记（03）.md","hash":"a277ec00dd9075d8e02d4e05b1ab22caa58d8e99","modified":1578491290783},{"_id":"source/_posts/Webpack学习笔记.md","hash":"09def5f18ace882a2d9d6a734b0c1f13e174353e","modified":1578491290783},{"_id":"source/_posts/cli工具之init.md","hash":"e7afdaf11e8d1861b06049e278393bff88845dd5","modified":1578491290783},{"_id":"source/_posts/iconfont使用方法.md","hash":"d84cac1154215a81fb177aede14432c421c53d2d","modified":1578491290783},{"_id":"source/_posts/vuex的学习整理.md","hash":"c94828ba0888b2aa16e8bf9c8cb121cf2991ff99","modified":1578491290783},{"_id":"source/_posts/关于HTTP请求小记.md","hash":"1dc88c00e82aef850aa93c392ed82607a3b91d57","modified":1578491290783},{"_id":"source/_posts/如何开发命令行工具.md","hash":"899c11eb19868afc8ea33dfc704368f9017a8ad4","modified":1578492431302},{"_id":"source/_posts/异步编程之promise与trigger.md","hash":"28e97c360c76d4d78c294894985524b837bbfeec","modified":1578491290783},{"_id":"source/_posts/搭建Hexo博客之后.md","hash":"3dde9845717cb122dd09044e64177c71a4d2d2c2","modified":1578491290783},{"_id":"source/_posts/有关一些数组和对象方法的比较和总结.md","hash":"2ca3288eaa6b8bed3ba69413aab3daa52a7486c8","modified":1578491290783},{"_id":"source/_posts/网络知识补充——浏览器请求过程.md","hash":"05d972f0f23ed676c3133fbc0f45e63b584897be","modified":1578491290784},{"_id":"source/_posts/页面加载——浏览器渲染.md","hash":"f8fc7f3df808638fe153de573c30b99be9394fea","modified":1578491290784},{"_id":"source/categories/index.md","hash":"64ae17c94c4eb665fcb7bbfa85e7111df7664819","modified":1578491290784},{"_id":"source/images/avatar.jpg","hash":"b2cd72c603ca58a27504c4744bb78de605adf456","modified":1578491290784},{"_id":"source/images/buildTool.jpg","hash":"86b388da7416cbd0e1e3ec3db095c7069890436b","modified":1578491290784},{"_id":"source/images/canvas-img-1.png","hash":"79357cc2687e1f19ebb11c7f5d3ed032ecaf9ee7","modified":1578491290784},{"_id":"source/images/cmd-1.png","hash":"80cc78f8aa26bd1913029f5f04892c1e0f3e4b0b","modified":1578491290784},{"_id":"source/images/cmd-2.png","hash":"c9b05c2222da11e1b2bd05f32c0c1e9316f1da2c","modified":1578491290785},{"_id":"source/images/cmd-3.png","hash":"43415c32a6eba048b7dbfdc38f34e443e0418716","modified":1578491290785},{"_id":"source/images/cmd-4.png","hash":"fbc83bd79875825fa1c07f4d4e70f42fa8af0ff2","modified":1578491290785},{"_id":"source/images/dom-1.png","hash":"d72db475c0f66b0e504ee8a8d4a4aa81e22e1da6","modified":1578491290785},{"_id":"source/images/http-2.png","hash":"a52a2cc5f95862f59c494c4f285098bca833f2f6","modified":1578491290786},{"_id":"source/images/http.png","hash":"8bd1247192e8b695a72657fec3c44b95092dcdf5","modified":1578491290786},{"_id":"source/images/iconfont-img-2.png","hash":"4f9c43a8d9b5a498dadcd1e7982d8c464b60462b","modified":1578491290787},{"_id":"source/images/iconfont-img-3.png","hash":"379845359d10d9578bff906cc328b00f18683b34","modified":1578491290787},{"_id":"source/images/iconfont-img-4.png","hash":"32eac83fe1450db586186a0e51e83f68db694ca3","modified":1578491290787},{"_id":"source/images/jicheng-1.png","hash":"405f7177225c5f12a289603689ccbb51a428a80f","modified":1578491290787},{"_id":"source/images/jicheng-2.png","hash":"35606fc921e2a7f254235f72234add1136ca7fb9","modified":1578491290787},{"_id":"source/images/mvc.png","hash":"9fb1613f1108a36d9c2d88c4a5239906bea963c3","modified":1578491290787},{"_id":"source/images/mvvm.png","hash":"05b38e8215d93b22c2cbd6f4a1903fd26e9e9782","modified":1578491290787},{"_id":"source/images/osi.png","hash":"0c7e06a9aa0dfd19968cfcf18cddf4ed82ee1da1","modified":1578491290788},{"_id":"source/images/stack&heap-1.png","hash":"4ed0fef087862dff2c7aa0d39e475a89f508e08e","modified":1578491290789},{"_id":"source/images/stack&heap-2.png","hash":"e8413df1ec7ce0649f2fa65bce3eafd6502fd2f5","modified":1578491290789},{"_id":"source/images/stack&heap-3.png","hash":"436d00a04593ec48893bf28136880239e0f6da39","modified":1578491290789},{"_id":"source/images/tcp-ip.png","hash":"04690e3f9af90a60215b9a6a729cf005b5375100","modified":1578491290789},{"_id":"source/images/variable-1.png","hash":"426cb0d62af8bf6fa08b56e56b9fd91de9d5401e","modified":1578491290789},{"_id":"source/images/vuejs.png","hash":"09ee13eaae9cece48673d65436a9ee0fd9a10c8d","modified":1578491290790},{"_id":"source/images/webpack-1.png","hash":"942029007eb0276779fe9ead10963029f4e10d91","modified":1578491290790},{"_id":"source/tags/index.md","hash":"2612efef3de723c061fe3e09a563ac6359932c9f","modified":1578491290790},{"_id":"themes/bmw/layout/archive.ejs","hash":"c770c490af2ac726a905fca7ba8a7ffcf49468e7","modified":1578496973352},{"_id":"themes/bmw/layout/category.ejs","hash":"c770c490af2ac726a905fca7ba8a7ffcf49468e7","modified":1578496973352},{"_id":"themes/bmw/layout/index.ejs","hash":"fea34b0179ec6b7cf91273ba61f853a544d60284","modified":1578496973352},{"_id":"themes/bmw/layout/layout.ejs","hash":"d54e37533cabb21d3ad98f2f44a53030550fb8ec","modified":1578496973352},{"_id":"themes/bmw/layout/post.ejs","hash":"fb5ba7d8910aaf4f6ae811d1cada93aa03a2dc56","modified":1578496973353},{"_id":"themes/bmw/layout/tag.ejs","hash":"c770c490af2ac726a905fca7ba8a7ffcf49468e7","modified":1578496973353},{"_id":"source/images/dom-2.png","hash":"21fe948dddf19361d725b4bba6f1e0388c4d4f26","modified":1578491290785},{"_id":"source/images/iconfont-img-1.png","hash":"845102fc4a31fb67e15b1395f99b3d7aeec307e2","modified":1578491290786},{"_id":"source/images/prototype.png","hash":"99ddac4ff9725edf9afb918ba03f7773655391d0","modified":1578491290788},{"_id":"source/images/settimeout.png","hash":"3fb1d61e1f94468e8dfcb23b3dd7d5a2dacc38eb","modified":1578491290789},{"_id":"themes/bmw/layout/_partial/comment.ejs","hash":"9d82642448abbd30dc00ae906821968a27f92148","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/fancybox.ejs","hash":"be6f655a475098bf3fa1da218c352b8c07e5df90","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/footer.ejs","hash":"32e451b87c1a2faf17a04c8750284e3d7bfd774b","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/header.ejs","hash":"511350a1c2f77821a9b7a231c7340ac9fb4ce21f","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/mathjax.ejs","hash":"1c71755c63ae74fafb633bfe383ad0a584843259","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/navigation.ejs","hash":"021c84bfeb638c71bbd39868601d3c9f39658209","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/player.ejs","hash":"55f4e5edd194ad7f793d91325e69c0bf2c0ba0a9","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/reward.ejs","hash":"9189965b71044de79e633d365be07ccd796b520b","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/social.ejs","hash":"c37342ff555f67b199e265b5678517d1bfbe7d80","modified":1578496973352},{"_id":"themes/bmw/layout/_partial/timer.ejs","hash":"bfca7a62af6aa01f2dd3ad660392d68a2c68e62c","modified":1578496973352},{"_id":"themes/bmw/layout/component/back-to-up.ejs","hash":"dbe8fc9f58da9d7b6622bb0c652d41c1c8acfb1f","modified":1578496973352},{"_id":"themes/bmw/layout/component/passage-viewer.ejs","hash":"907d2ef218a9a9935c06e0434e89275f9548de17","modified":1578496973352},{"_id":"themes/bmw/layout/component/timeline.ejs","hash":"a5e3ea8779f22250edbcf06e6d4873ba056ee8a3","modified":1578496973352},{"_id":"themes/bmw/source/css/base.css","hash":"b35e69a6af1078f8ce3f5ec01d48bba9af142d14","modified":1578496973353},{"_id":"themes/bmw/source/css/base.css.map","hash":"96f74f144960dc1af4f7eda0edb955fde4a78ed5","modified":1578496973353},{"_id":"themes/bmw/source/css/github-markdown.css","hash":"0410ba978d226febee6d3236e8c5147689771299","modified":1578496973353},{"_id":"themes/bmw/source/css/highlight.css","hash":"ce8f7a91da7e2980e3778cef0bcff2a5e4b66b75","modified":1578496973353},{"_id":"themes/bmw/source/css/prism.css","hash":"a3acad3ed1d1d0a4f265d772f6cb190107d72e55","modified":1578496973353},{"_id":"themes/bmw/source/icon/demo_fontclass.html","hash":"52e0e3bb43e5fab3245cd6dbee11a2bf6fe8a46e","modified":1578496973353},{"_id":"themes/bmw/source/icon/iconfont.css","hash":"7c38a344145825ed80bc1e4da757a4733fb50652","modified":1578496973353},{"_id":"themes/bmw/source/icon/iconfont.eot","hash":"adc3cc9072b4d2f3939fb2f177ddcf7bd4ab009a","modified":1578496973353},{"_id":"themes/bmw/source/icon/iconfont.js","hash":"c5e9d861865c112c1b9971e0409503ed95c815c0","modified":1578496973353},{"_id":"themes/bmw/source/icon/iconfont.svg","hash":"f169491400b047eae7108fcd600b2dae5e457ad3","modified":1578496973354},{"_id":"themes/bmw/source/icon/iconfont.ttf","hash":"0a3b2a7882c61d6b4c85fe4e72f9f26948c6758d","modified":1578496973354},{"_id":"themes/bmw/source/icon/iconfont.woff","hash":"6dd1f927e13de5db063a4898e563a70a14e13b80","modified":1578496973354},{"_id":"themes/bmw/source/images/alipay.png","hash":"d58434f2543e983ecb2e2240d92bdc825e40fa60","modified":1578496973354},{"_id":"themes/bmw/source/images/favicon.ico","hash":"cc7c201861748e92f4809507096df74a40ef496a","modified":1578496973354},{"_id":"themes/bmw/source/images/touch-icon.png","hash":"df5a490c2e8d549ca767505fbe46eed3cbe3df43","modified":1578496973354},{"_id":"themes/bmw/source/images/wechat.png","hash":"4742a2f020b5be1d9b12681faaeace8a7c91c570","modified":1578496973354},{"_id":"themes/bmw/source/js/util.js","hash":"e934cc45e3f7e5f5be3618ba9e9a1f4637482a7b","modified":1578496973354},{"_id":"themes/bmw/source/scss/animation.scss","hash":"263f223b4977350635f91a3dfbc522885ee7a1a1","modified":1578496973355},{"_id":"themes/bmw/source/scss/article.scss","hash":"ed53f9ee14f84c651fd6b3deb864d4362508e64a","modified":1578496973355},{"_id":"themes/bmw/source/scss/base.scss","hash":"dc8ece1d059dc3669690bfd9feda866bd590e71c","modified":1578496973355},{"_id":"themes/bmw/source/scss/mathjax.scss","hash":"1c505af96fa77d65ad5d13081c71a612e2f9587f","modified":1578496973355},{"_id":"themes/bmw/source/scss/vcomments.scss","hash":"6f0d9b22aa0988831c1700b8c5ef55bc655f4b50","modified":1578496973355},{"_id":"themes/bmw/source/stylus/highlight.styl","hash":"8061950ee824c1b91bee01bd3373d858dc9296a9","modified":1578496973355},{"_id":"themes/bmw/source/js/valine.min.js","hash":"ede5d4e0bc808cc8d9852b176237dc9b951a7045","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/about.scss","hash":"b5530f7eba54053a504014e3d13d6c4fddfca65e","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/category.scss","hash":"71e35eee5232fb33b5ea40d64d2f1073db798838","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/friend.scss","hash":"d722788163872ac59bd138c5bd5ffe0ac5b75459","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/home.scss","hash":"0b3905cf565219cf970c512351c1b918ab802a02","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/index.scss","hash":"21f96d488fe8b64ff2ab016fab9e8a1c02a87d30","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/post.scss","hash":"1ed149bf23774237c90f68610336a43c190d98e2","modified":1578496973355},{"_id":"themes/bmw/source/scss/layout/tag.scss","hash":"46611ae788ed3cc5185f909864da26f012c1c978","modified":1578496973355},{"_id":"themes/bmw/source/scss/partial/footer.scss","hash":"f3d5d39f7b630fa8edba26bd996599ddd860a445","modified":1578496973355},{"_id":"themes/bmw/source/scss/partial/navigation.scss","hash":"29dafd5e8a8cfa45f7069ef40f5ef3e499b60124","modified":1578496973355},{"_id":"themes/bmw/source/scss/partial/reward.scss","hash":"32e04d72f58098affa010e59f8f1f63da06374e2","modified":1578496973355},{"_id":"themes/bmw/source/scss/partial/timeline.scss","hash":"066c1e7a8e3a956d5885c104b8236c9803123b72","modified":1578496973355},{"_id":"public/atom.xml","hash":"a14e4c991c7b966489d62e459b9ab6a9212eb077","modified":1578499010930},{"_id":"public/content.json","hash":"4c18583dea768769966350624c5e8d147a0bbde4","modified":1578499010930},{"_id":"public/sitemap.xml","hash":"2b2be718362bd753eefd98d1cb08124d40059682","modified":1578499010931},{"_id":"public/categories/index.html","hash":"d929fa05e92bc0705a0f8dff6bfca762a696cf0b","modified":1578499010988},{"_id":"public/tags/index.html","hash":"87742f7355c08d4194d7103012b9d228508b0fd6","modified":1578499010988},{"_id":"public/2019/12/03/Promise详解/index.html","hash":"7109a1acb1c7bad111397a8d97bb5731ee87ceea","modified":1578499010989},{"_id":"public/2018/08/19/Vue.js学习笔记（03）/index.html","hash":"7cda6714a8674a95c26f3360c2f53c68982777b1","modified":1578499010989},{"_id":"public/categories/知识碎片/index.html","hash":"0f55a626df205c8fb0362d1b13c4b6066d1e905c","modified":1578499010989},{"_id":"public/categories/JS相关/index.html","hash":"7e798fb8fa13b80caa556f8963746031ca86d8c7","modified":1578499010989},{"_id":"public/categories/JS相关/page/2/index.html","hash":"2fc46b2d402ccde0e6a0ee37a9d19628f6e229d5","modified":1578499010989},{"_id":"public/categories/TS相关/index.html","hash":"7edd8fe916bc57acde311669d9ab42da5dff5822","modified":1578499010989},{"_id":"public/categories/Vue相关/index.html","hash":"77f7d84d57d2c752eada379f8be70502de8de150","modified":1578499010989},{"_id":"public/categories/项目自动化/index.html","hash":"0d8815292019e3b3b143bbabacfd1e208d907e2c","modified":1578499010990},{"_id":"public/categories/node相关/index.html","hash":"c829043b58bbabe0cdabf088c6da3fbdc3b4b460","modified":1578499010990},{"_id":"public/tags/Ajax/index.html","hash":"e44ecc0a790460486b0e0f84f79cbcb1505e36d5","modified":1578499010990},{"_id":"public/tags/DOM/index.html","hash":"3d70c6a772ec5885155caf0cdc93bdc8da842a0c","modified":1578499010990},{"_id":"public/tags/BOM/index.html","hash":"138dcdbdd2498559d5eccfe6e017e7925983053d","modified":1578499010990},{"_id":"public/tags/HTML/index.html","hash":"1392e4d255fb1ea14c73caf68c2c7b7e7d9d0aff","modified":1578499010990},{"_id":"public/tags/JavaScript/index.html","hash":"0392c475735498b017c344964f5925ae0962b300","modified":1578499010990},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"ac31be4e83414078930b120b65a6be6303a025ea","modified":1578499010990},{"_id":"public/tags/ES6/index.html","hash":"5a71f3cb994caa22f3ce5c016e8e26bd6bd802d1","modified":1578499010990},{"_id":"public/tags/JSON/index.html","hash":"c326cc34c3fd24ef83676c0548ab513ea2a2322c","modified":1578499010991},{"_id":"public/tags/TypeScript/index.html","hash":"79dcdc15f25c51e9fcf0bf089115d3b7a503f2ed","modified":1578499010991},{"_id":"public/tags/Vue/index.html","hash":"f18c6e90c048ac866bb27080585614c60ef03e3e","modified":1578499010991},{"_id":"public/tags/MVC/index.html","hash":"8f1233961df7917d48a93b78a8f383c8d1cd627c","modified":1578499010991},{"_id":"public/tags/MVVM/index.html","hash":"a4219537c904313a85b09215215c3321c1cc074e","modified":1578499010991},{"_id":"public/tags/Vue生命周期/index.html","hash":"4f21fc42edc0c069db43a99361c864f6051f6bc8","modified":1578499010991},{"_id":"public/tags/Vue指令/index.html","hash":"64f2868d256d7c607610e29010a3045b1e8e01c9","modified":1578499010991},{"_id":"public/tags/Vue事件/index.html","hash":"36b3176de6ed429bc1e0f5f21d0b979dbe9f3b8c","modified":1578499010992},{"_id":"public/tags/Webpack/index.html","hash":"d52c52b2af3d4f381f2e1415ac0637432aea5ec1","modified":1578499010992},{"_id":"public/tags/node/index.html","hash":"6cb3d392daccb3253db54a95d3219e8194be7923","modified":1578499010992},{"_id":"public/tags/fet源码/index.html","hash":"02dcd02a2724f8ea4a3b6ee41eaddfacf489f890","modified":1578499010992},{"_id":"public/tags/cli工具/index.html","hash":"51eb07b247617d468104ee61f8303b93d7a134c8","modified":1578499010992},{"_id":"public/tags/iconfont/index.html","hash":"a1061d91f27ff00c999962488c0b65e29588d637","modified":1578499010992},{"_id":"public/tags/Vuex/index.html","hash":"9b2c1b52410cff537d604b6edfdacddb1008646b","modified":1578499010992},{"_id":"public/tags/HTTP/index.html","hash":"56e12799ffe7aa0d16b910c6ceed688c56916934","modified":1578499010992},{"_id":"public/tags/网络/index.html","hash":"8c7600140943fc2a509d0213316920636605e830","modified":1578499010993},{"_id":"public/tags/异步/index.html","hash":"27f6a69e7f513f329e62730e73685919b704b8ec","modified":1578499010993},{"_id":"public/tags/hexo/index.html","hash":"2201ac79fc509d04b6f81157156fc7d9d1eeceeb","modified":1578499010993},{"_id":"public/tags/lodash/index.html","hash":"99f08c14883ae2251f301a517de491f0bad8732a","modified":1578499010993},{"_id":"public/tags/网络知识/index.html","hash":"88ecd1e005d93ecba8e151b2f4827298e9f74cfc","modified":1578499010993},{"_id":"public/2019/10/19/cli工具之init/index.html","hash":"d8d40e80e7c8ff04c48bfd7141dcbdeced110ebb","modified":1578499010993},{"_id":"public/2019/06/04/如何开发命令行工具/index.html","hash":"15aa49a4069d1aeb64b567beb00108a117e58630","modified":1578499010993},{"_id":"public/2019/05/26/TypeScript学习笔记（基础）/index.html","hash":"2894418992690d31442bd3ba4c8b71c2d204f02d","modified":1578499010993},{"_id":"public/2019/05/09/vuex的学习整理/index.html","hash":"8af3cc790cf924862e2aa086a359b093798914ee","modified":1578499010994},{"_id":"public/2018/11/04/有关一些数组和对象方法的比较和总结/index.html","hash":"fbab52f4ac226cf166003e5377dbd19857999b4a","modified":1578499010994},{"_id":"public/2018/07/25/Vue.js学习笔记（02）/index.html","hash":"8508bf1c4b7651e7c302e0818fb7180c71a2d30f","modified":1578499010994},{"_id":"public/2018/03/09/ES6 核心向新特性（03）/index.html","hash":"7086fc78ff8b2d296ec427f1b9e85fdc25014df3","modified":1578499010994},{"_id":"public/2018/03/08/ES6 核心向新特性（02）/index.html","hash":"a8dafeaaa991b8bff848c4875014e0f483d88724","modified":1578499010995},{"_id":"public/2018/03/07/ES6 核心向新特性（01）/index.html","hash":"2e48fc7ba884d2bfccbd22540e3e0459425b620e","modified":1578499010995},{"_id":"public/2018/01/15/Webpack学习笔记/index.html","hash":"d91bda9472c9484af03e6e2e328b0c66f3935c37","modified":1578499010995},{"_id":"public/2017/10/19/Vue.js学习笔记（01）/index.html","hash":"41b16cd6c5130012bb208b47c0982146c75e3aff","modified":1578499010995},{"_id":"public/2017/10/02/DOM本质/index.html","hash":"02423e47d5ed2e219bd8cbd3cea9e4de3192ce15","modified":1578499010995},{"_id":"public/2017/09/25/JavaScript单线程/index.html","hash":"2a75dafd1751143b86f9efa9fafafad3bb8ed819","modified":1578499010995},{"_id":"public/2017/08/24/JS变量计算/index.html","hash":"962dd3816d982e33909204d0a9da16ee3e04a38e","modified":1578499010995},{"_id":"public/2017/08/19/页面加载——浏览器渲染/index.html","hash":"48a9791688ffc46bd85ceb2804542e1f41459cb7","modified":1578499010996},{"_id":"public/2017/08/17/网络知识补充——浏览器请求过程/index.html","hash":"8a463bced64bfb7447f66c1bdab8faa7d49282de","modified":1578499010996},{"_id":"public/2017/08/16/JS面向对象学习笔记/index.html","hash":"616c0eda91affa7cd458cf33e426e132ccededd7","modified":1578499010997},{"_id":"public/2017/08/15/JS变量、作用域和内存问题/index.html","hash":"0f631a3765e30c501bb7ecef379d76ad6aca85cc","modified":1578499010997},{"_id":"public/2017/07/15/异步编程之promise与trigger/index.html","hash":"3ffd9416f9922fdffe0c292699492bd226f016eb","modified":1578499010997},{"_id":"public/2017/07/15/搭建Hexo博客之后/index.html","hash":"a3408b7ec1ff13939774a2bb338a44f40f3d5ac2","modified":1578499010997},{"_id":"public/2017/07/08/JS之this指针笔记/index.html","hash":"7e0769e21feae851b249f6f73ef3035a6f479372","modified":1578499010997},{"_id":"public/2017/07/07/JS继承笔记/index.html","hash":"b69e0f5297c48947745fa804fbe421542c3cb19f","modified":1578499010998},{"_id":"public/2017/04/21/JavaScript正则表达式/index.html","hash":"09d2999240868d8a8f03854b837a47a255ccb5ad","modified":1578499011013},{"_id":"public/2017/03/26/iconfont使用方法/index.html","hash":"15ab1f2bbb4484e504b394a51c5ac413b45c825d","modified":1578499011013},{"_id":"public/2017/03/21/JSON学习笔记/index.html","hash":"44dd65129985d8a72356580a21b81781204b7aa8","modified":1578499011013},{"_id":"public/2017/03/21/AJAX学习笔记/index.html","hash":"984607665faf8c7a4d69aee41027eb441e69dd21","modified":1578499011013},{"_id":"public/2017/03/20/关于HTTP请求小记/index.html","hash":"f43516b20c324f8ddb010917cb8ebbe4706a5304","modified":1578499011013},{"_id":"public/archives/index.html","hash":"21fce68db7bb0a99a6789db8e41f678bad6246ad","modified":1578499011014},{"_id":"public/index.html","hash":"1f24e42f8695f85f13e056a45cdf0f6b8eeb8bb8","modified":1578499011014},{"_id":"public/page/2/index.html","hash":"f58b320f1129bbfd67a2545e864f4225cd0f264b","modified":1578499011014},{"_id":"public/page/3/index.html","hash":"5c4d8f106c29048bfe73388ca390484ba8ab9a27","modified":1578499011015},{"_id":"public/images/buildTool.jpg","hash":"86b388da7416cbd0e1e3ec3db095c7069890436b","modified":1578499011032},{"_id":"public/images/cmd-1.png","hash":"80cc78f8aa26bd1913029f5f04892c1e0f3e4b0b","modified":1578499011032},{"_id":"public/images/cmd-2.png","hash":"c9b05c2222da11e1b2bd05f32c0c1e9316f1da2c","modified":1578499011032},{"_id":"public/images/cmd-3.png","hash":"43415c32a6eba048b7dbfdc38f34e443e0418716","modified":1578499011032},{"_id":"public/images/cmd-4.png","hash":"fbc83bd79875825fa1c07f4d4e70f42fa8af0ff2","modified":1578499011033},{"_id":"public/images/dom-1.png","hash":"d72db475c0f66b0e504ee8a8d4a4aa81e22e1da6","modified":1578499011033},{"_id":"public/images/http.png","hash":"8bd1247192e8b695a72657fec3c44b95092dcdf5","modified":1578499011033},{"_id":"public/images/iconfont-img-2.png","hash":"4f9c43a8d9b5a498dadcd1e7982d8c464b60462b","modified":1578499011033},{"_id":"public/images/iconfont-img-3.png","hash":"379845359d10d9578bff906cc328b00f18683b34","modified":1578499011033},{"_id":"public/images/iconfont-img-4.png","hash":"32eac83fe1450db586186a0e51e83f68db694ca3","modified":1578499011033},{"_id":"public/images/jicheng-1.png","hash":"405f7177225c5f12a289603689ccbb51a428a80f","modified":1578499011034},{"_id":"public/images/jicheng-2.png","hash":"35606fc921e2a7f254235f72234add1136ca7fb9","modified":1578499011034},{"_id":"public/images/mvvm.png","hash":"05b38e8215d93b22c2cbd6f4a1903fd26e9e9782","modified":1578499011034},{"_id":"public/images/osi.png","hash":"0c7e06a9aa0dfd19968cfcf18cddf4ed82ee1da1","modified":1578499011034},{"_id":"public/images/stack&heap-1.png","hash":"4ed0fef087862dff2c7aa0d39e475a89f508e08e","modified":1578499011034},{"_id":"public/images/stack&heap-2.png","hash":"e8413df1ec7ce0649f2fa65bce3eafd6502fd2f5","modified":1578499011034},{"_id":"public/images/stack&heap-3.png","hash":"436d00a04593ec48893bf28136880239e0f6da39","modified":1578499011035},{"_id":"public/images/tcp-ip.png","hash":"04690e3f9af90a60215b9a6a729cf005b5375100","modified":1578499011035},{"_id":"public/images/variable-1.png","hash":"426cb0d62af8bf6fa08b56e56b9fd91de9d5401e","modified":1578499011035},{"_id":"public/images/webpack-1.png","hash":"942029007eb0276779fe9ead10963029f4e10d91","modified":1578499011035},{"_id":"public/css/base.css.map","hash":"96f74f144960dc1af4f7eda0edb955fde4a78ed5","modified":1578499011041},{"_id":"public/icon/iconfont.eot","hash":"adc3cc9072b4d2f3939fb2f177ddcf7bd4ab009a","modified":1578499011041},{"_id":"public/icon/iconfont.svg","hash":"f169491400b047eae7108fcd600b2dae5e457ad3","modified":1578499011042},{"_id":"public/icon/iconfont.ttf","hash":"0a3b2a7882c61d6b4c85fe4e72f9f26948c6758d","modified":1578499011042},{"_id":"public/icon/iconfont.woff","hash":"6dd1f927e13de5db063a4898e563a70a14e13b80","modified":1578499011052},{"_id":"public/images/favicon.ico","hash":"cc7c201861748e92f4809507096df74a40ef496a","modified":1578499011052},{"_id":"public/images/touch-icon.png","hash":"df5a490c2e8d549ca767505fbe46eed3cbe3df43","modified":1578499011052},{"_id":"public/images/wechat.png","hash":"4742a2f020b5be1d9b12681faaeace8a7c91c570","modified":1578499011053},{"_id":"public/scss/animation.scss","hash":"263f223b4977350635f91a3dfbc522885ee7a1a1","modified":1578499011053},{"_id":"public/scss/article.scss","hash":"ed53f9ee14f84c651fd6b3deb864d4362508e64a","modified":1578499011053},{"_id":"public/scss/base.scss","hash":"dc8ece1d059dc3669690bfd9feda866bd590e71c","modified":1578499011053},{"_id":"public/scss/mathjax.scss","hash":"1c505af96fa77d65ad5d13081c71a612e2f9587f","modified":1578499011053},{"_id":"public/scss/vcomments.scss","hash":"6f0d9b22aa0988831c1700b8c5ef55bc655f4b50","modified":1578499011053},{"_id":"public/scss/layout/about.scss","hash":"b5530f7eba54053a504014e3d13d6c4fddfca65e","modified":1578499011053},{"_id":"public/scss/layout/category.scss","hash":"71e35eee5232fb33b5ea40d64d2f1073db798838","modified":1578499011053},{"_id":"public/scss/layout/friend.scss","hash":"d722788163872ac59bd138c5bd5ffe0ac5b75459","modified":1578499011053},{"_id":"public/scss/layout/home.scss","hash":"0b3905cf565219cf970c512351c1b918ab802a02","modified":1578499011054},{"_id":"public/scss/layout/index.scss","hash":"21f96d488fe8b64ff2ab016fab9e8a1c02a87d30","modified":1578499011054},{"_id":"public/scss/layout/post.scss","hash":"1ed149bf23774237c90f68610336a43c190d98e2","modified":1578499011054},{"_id":"public/scss/layout/tag.scss","hash":"46611ae788ed3cc5185f909864da26f012c1c978","modified":1578499011054},{"_id":"public/scss/partial/footer.scss","hash":"f3d5d39f7b630fa8edba26bd996599ddd860a445","modified":1578499011058},{"_id":"public/scss/partial/navigation.scss","hash":"29dafd5e8a8cfa45f7069ef40f5ef3e499b60124","modified":1578499011059},{"_id":"public/scss/partial/reward.scss","hash":"32e04d72f58098affa010e59f8f1f63da06374e2","modified":1578499011059},{"_id":"public/scss/partial/timeline.scss","hash":"066c1e7a8e3a956d5885c104b8236c9803123b72","modified":1578499011059},{"_id":"public/images/avatar.jpg","hash":"b2cd72c603ca58a27504c4744bb78de605adf456","modified":1578499011059},{"_id":"public/images/canvas-img-1.png","hash":"79357cc2687e1f19ebb11c7f5d3ed032ecaf9ee7","modified":1578499011059},{"_id":"public/images/http-2.png","hash":"a52a2cc5f95862f59c494c4f285098bca833f2f6","modified":1578499011059},{"_id":"public/images/mvc.png","hash":"9fb1613f1108a36d9c2d88c4a5239906bea963c3","modified":1578499011059},{"_id":"public/images/vuejs.png","hash":"09ee13eaae9cece48673d65436a9ee0fd9a10c8d","modified":1578499011059},{"_id":"public/images/dom-2.png","hash":"21fe948dddf19361d725b4bba6f1e0388c4d4f26","modified":1578499011059},{"_id":"public/images/iconfont-img-1.png","hash":"845102fc4a31fb67e15b1395f99b3d7aeec307e2","modified":1578499011059},{"_id":"public/images/prototype.png","hash":"99ddac4ff9725edf9afb918ba03f7773655391d0","modified":1578499011427},{"_id":"public/images/settimeout.png","hash":"3fb1d61e1f94468e8dfcb23b3dd7d5a2dacc38eb","modified":1578499011427},{"_id":"public/images/alipay.png","hash":"d58434f2543e983ecb2e2240d92bdc825e40fa60","modified":1578499011427},{"_id":"public/css/highlight.css","hash":"ce8f7a91da7e2980e3778cef0bcff2a5e4b66b75","modified":1578499011432},{"_id":"public/css/prism.css","hash":"a3acad3ed1d1d0a4f265d772f6cb190107d72e55","modified":1578499011432},{"_id":"public/icon/iconfont.css","hash":"7c38a344145825ed80bc1e4da757a4733fb50652","modified":1578499011432},{"_id":"public/js/util.js","hash":"e934cc45e3f7e5f5be3618ba9e9a1f4637482a7b","modified":1578499011432},{"_id":"public/stylus/highlight.css","hash":"2f39e0fcb3bf8124045ef6fa5f7aec2575a968fc","modified":1578499011432},{"_id":"public/icon/demo_fontclass.html","hash":"78a9d9e64e5c077d3a1a8155a574580625c8945d","modified":1578499011432},{"_id":"public/css/github-markdown.css","hash":"0410ba978d226febee6d3236e8c5147689771299","modified":1578499011434},{"_id":"public/icon/iconfont.js","hash":"c5e9d861865c112c1b9971e0409503ed95c815c0","modified":1578499011434},{"_id":"public/css/base.css","hash":"b35e69a6af1078f8ce3f5ec01d48bba9af142d14","modified":1578499011449},{"_id":"public/js/valine.min.js","hash":"ede5d4e0bc808cc8d9852b176237dc9b951a7045","modified":1578499011485}],"Category":[{"name":"知识碎片","_id":"ck55hfl90000sfr03uzjcvaj6"},{"name":"JS相关","_id":"ck55hfla1000zfr0384pnpqr4"},{"name":"TS相关","_id":"ck55hflad001hfr03vm7x1nvr"},{"name":"Vue相关","_id":"ck55hflae001jfr03lwekxlv0"},{"name":"项目自动化","_id":"ck55hflah001pfr03xqwg8tg0"},{"name":"node相关","_id":"ck55hflai001rfr034luajxx8"}],"Data":[],"Page":[{"title":"categories","date":"2019-05-24T11:45:24.000Z","type":"categories","categories":null,"tags":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-05-24 19:45:24\ntype: \"categories\"\ncategories:\ntags:\n---\n","updated":"2020-01-08T13:48:10.784Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck55hfl6h0000fr03zg24ac7n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-05-24T11:45:13.000Z","type":"tags","categories":null,"tags":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-05-24 19:45:13\ntype: \"tags\"\ncategories:\ntags:\n---\n","updated":"2020-01-08T13:48:10.790Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck55hfl7g0001fr03y7d7nkhd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AJAX学习笔记","date":"2017-03-21T08:21:19.000Z","_content":"> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","source":"_posts/AJAX学习笔记.md","raw":"---\ntitle: AJAX学习笔记\ndate: 2017-03-21 16:21:19\ncategories: 知识碎片\ntags: \n  - Ajax\n---\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","slug":"AJAX学习笔记","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7h0002fr03wpa6ofih","content":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></span><br><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">request.send();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建信息</span></span><br><span class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></span><br><span class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">request.send();</span><br><span class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\ttype:<span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">\turl:<span class=\"string\">\"get.php\"</span>,</span><br><span class=\"line\">\tdataType:<span class=\"string\">\"json\"</span>,</span><br><span class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\ttype:<span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">\turl:<span class=\"string\">\"get.php\"</span>,</span><br><span class=\"line\">\tdataType:<span class=\"string\">\"json\"</span>,</span><br><span class=\"line\">\tdata:&#123;</span><br><span class=\"line\">\t\tname:<span class=\"number\">123</span></span><br><span class=\"line\">\t\tnumber:<span class=\"number\">123</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在www.aaa.com中</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\"> \talert(json[<span class=\"string\">\"name\"</span>]);</span></span><br><span class=\"line\"><span class=\"undefined\"> &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> 在www.bbb.com中</span><br><span class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\ttype:<span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">\turl:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</span><br><span class=\"line\">\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\tjsonp:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></span><br><span class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>","more":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></span><br><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">request.send();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建信息</span></span><br><span class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></span><br><span class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">request.send();</span><br><span class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\ttype:<span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">\turl:<span class=\"string\">\"get.php\"</span>,</span><br><span class=\"line\">\tdataType:<span class=\"string\">\"json\"</span>,</span><br><span class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\ttype:<span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">\turl:<span class=\"string\">\"get.php\"</span>,</span><br><span class=\"line\">\tdataType:<span class=\"string\">\"json\"</span>,</span><br><span class=\"line\">\tdata:&#123;</span><br><span class=\"line\">\t\tname:<span class=\"number\">123</span></span><br><span class=\"line\">\t\tnumber:<span class=\"number\">123</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在www.aaa.com中</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\"> \talert(json[<span class=\"string\">\"name\"</span>]);</span></span><br><span class=\"line\"><span class=\"undefined\"> &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> 在www.bbb.com中</span><br><span class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\ttype:<span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">\turl:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</span><br><span class=\"line\">\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\tjsonp:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></span><br><span class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>"},{"title":"DOM基础知识巩固","date":"2017-10-02T05:15:36.000Z","_content":"## DOM本质\nDOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。\n\n## DOM节点操作\n\n### 获取DOM节点\n\n* `document.getElementById`\n* `document.getElementsByTagName`\n* `document.getElementsByClassName`\n* `document.querySelectorAll`\n\n<!-- more -->\n\n## DOM本质\nDOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。\n\n## DOM节点操作\n\n### 获取DOM节点\n\n* `document.getElementById`\n* `document.getElementsByTagName`\n* `document.getElementsByClassName`\n* `document.querySelectorAll`\n\n### property与attribute\n\n虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。\n\n* property是DOM中的属性，是JavaScript里的对象；\n* attribute是HTML标签上的特性，它的值只能够是字符串；\n\n例如在html中有一段这样的代码：\n```html\n<input id=\"test\" value=\"1\" sth=\"whatever\">\n```\n我们在js中来获取这个DOM对象：\n```javascript\nvar test = document.getElementById('test');\nconsole.log(test);\nconsole.log(test.id); // 'test'\nconsole.log(test.value); // 1\nconsole.log(test.sth) // undefined\n```\n由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：\n```html\n<input id=\"test-2\" >\n```\n```javascript\nvar test_2 = document.getElementById('test-2');\nconsole.log(test_2.value); // null\n```\n虽然没有在标签中定义`value`，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：\n\n* DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。\n* 如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。\n\n那么标签上的sth定义在哪里呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png)\n\n也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。\n```javascript\nconsole.log(test.attibutes.sth); // 'sth=\"whatever\"'\n```\n由此可以得出：\n\n* HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；\n* 这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；\n\n那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：\n```javascript\ntest.value = 'new value of prop';\nconsole.log(test.value); // 'new value of prop'\nconsole.log(test.arrtibutes.value); // 'value=\"1\"'\n```\n如果反过来，效果又是如何呢？\n```javascript\ntest.attributes.value = 'new value of attr';\nconsole.log(test.value); // 'new value of attr'\nconsole.log(test.attributes.value); // 'new value of attr'\n```\n此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：\n```javascript\ntest.attributes.value.nodeValue = 'new value of attr';\n```\n由此，可得出结论：\n\n* property能够从attribute中得到同步；\n* attribute不会同步property上的值；\n* attribute和property之间的数据绑定是单向的，attribute->property；\n* 更改property和attribute上的任意值，都会将更新反映到HTML页面中；\n\n### DOM操作\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png)\n\n有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：\n* 减少DOM访问次数\n* 多次访问同一DOM，应该用局部变量缓存该DOM\n* 尽可能使用querySelector，而不是使用获取HTML集合的API\n* 注意重排（reflow）和重绘（repaint）\n* 使用事件委托，减少绑定事件的数量\n\n### 重排（重构）&重绘\n\n重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：\n\n* 添加或删除DOM元素\n* 元素位置、大小、内容改变\n* 浏览器窗口大小改变\n* 滚动条出现\n\n**最小化重排、重绘的建议：**\n\n* 不要再修改布局信息的时候，去查询布局信息\n* 修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式\n* :hover会降低响应速度，在处理很大的列表时，避免使用\n\n## BOM操作\nBOM（Browser Object Model）指的是浏览器对象模型，主要用途：\n* 检测浏览器的类型\n* 拆解url的各部分\n\n### navigator\n\n`navigator`对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。\n常用方法有：\n* `navigator.userAgent` //用户代理头的字符串表示\n\n### screen\n\n`screen`对象：用于获取某些关于用户屏幕的信息。\n常用方法有：\n* `screen.width/height` //屏幕的宽度与高度，以像素计 \n* `screen.availWidth/availHeight` //窗口可以使用的屏幕的宽度和高度，以像素计 \n* `screen.colorDepth` //用户表示颜色的位数，大多数系统采用32位 \n* `window.moveTo(0, 0); `\n* `window.resizeTo(screen.availWidth, screen.availHeight); ` //填充用户的屏幕\n\n### location\n\n`location`对象：表示载入窗口的URL。\n常用方法有：\n* `location.href` //当前载入页面的完整URL\n* `location.portocol` //URL中使用的协议，即双斜杠之前的部分，如http\n* `location.host` //服务器的名字，如www.wrox.com\n* `location.hostname` //通常等于host，有时会省略前面的www\n* `location.port` //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080\n* `location.pathname` //URL中主机名后的部分，如/pictures/index.htm\n* `location.search` //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx\n* `location.hash` //如果URL包含#，返回该符号之后的内容，如#anchor1\n* `location.assign(\"http:www.baidu.com\");` //同location.href，新地址都会被加到浏览器的历史栈中\n* `location.replace(\"http:www.baidu.com\");` //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问\n* `location.reload(true | false);` //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false\n\n### history\n\n`history`对象：浏览器窗口的历史\n常用方法有：\n* `history.go(-1);` //访问浏览器窗口的历史，负数为后退，正数为前进\n* `history.back();` //同上\n* `history.forward();` //同上\n* `history.length` //可以查看历史中的页面数\n\n","source":"_posts/DOM本质.md","raw":"---\ntitle: DOM基础知识巩固\ndate: 2017-10-02 13:15:36\ncategories: 知识碎片\ntags: \n  - DOM\n  - BOM\n  - HTML\n---\n## DOM本质\nDOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。\n\n## DOM节点操作\n\n### 获取DOM节点\n\n* `document.getElementById`\n* `document.getElementsByTagName`\n* `document.getElementsByClassName`\n* `document.querySelectorAll`\n\n<!-- more -->\n\n## DOM本质\nDOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。\n\n## DOM节点操作\n\n### 获取DOM节点\n\n* `document.getElementById`\n* `document.getElementsByTagName`\n* `document.getElementsByClassName`\n* `document.querySelectorAll`\n\n### property与attribute\n\n虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。\n\n* property是DOM中的属性，是JavaScript里的对象；\n* attribute是HTML标签上的特性，它的值只能够是字符串；\n\n例如在html中有一段这样的代码：\n```html\n<input id=\"test\" value=\"1\" sth=\"whatever\">\n```\n我们在js中来获取这个DOM对象：\n```javascript\nvar test = document.getElementById('test');\nconsole.log(test);\nconsole.log(test.id); // 'test'\nconsole.log(test.value); // 1\nconsole.log(test.sth) // undefined\n```\n由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：\n```html\n<input id=\"test-2\" >\n```\n```javascript\nvar test_2 = document.getElementById('test-2');\nconsole.log(test_2.value); // null\n```\n虽然没有在标签中定义`value`，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：\n\n* DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。\n* 如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。\n\n那么标签上的sth定义在哪里呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png)\n\n也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。\n```javascript\nconsole.log(test.attibutes.sth); // 'sth=\"whatever\"'\n```\n由此可以得出：\n\n* HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；\n* 这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；\n\n那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：\n```javascript\ntest.value = 'new value of prop';\nconsole.log(test.value); // 'new value of prop'\nconsole.log(test.arrtibutes.value); // 'value=\"1\"'\n```\n如果反过来，效果又是如何呢？\n```javascript\ntest.attributes.value = 'new value of attr';\nconsole.log(test.value); // 'new value of attr'\nconsole.log(test.attributes.value); // 'new value of attr'\n```\n此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：\n```javascript\ntest.attributes.value.nodeValue = 'new value of attr';\n```\n由此，可得出结论：\n\n* property能够从attribute中得到同步；\n* attribute不会同步property上的值；\n* attribute和property之间的数据绑定是单向的，attribute->property；\n* 更改property和attribute上的任意值，都会将更新反映到HTML页面中；\n\n### DOM操作\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png)\n\n有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：\n* 减少DOM访问次数\n* 多次访问同一DOM，应该用局部变量缓存该DOM\n* 尽可能使用querySelector，而不是使用获取HTML集合的API\n* 注意重排（reflow）和重绘（repaint）\n* 使用事件委托，减少绑定事件的数量\n\n### 重排（重构）&重绘\n\n重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：\n\n* 添加或删除DOM元素\n* 元素位置、大小、内容改变\n* 浏览器窗口大小改变\n* 滚动条出现\n\n**最小化重排、重绘的建议：**\n\n* 不要再修改布局信息的时候，去查询布局信息\n* 修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式\n* :hover会降低响应速度，在处理很大的列表时，避免使用\n\n## BOM操作\nBOM（Browser Object Model）指的是浏览器对象模型，主要用途：\n* 检测浏览器的类型\n* 拆解url的各部分\n\n### navigator\n\n`navigator`对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。\n常用方法有：\n* `navigator.userAgent` //用户代理头的字符串表示\n\n### screen\n\n`screen`对象：用于获取某些关于用户屏幕的信息。\n常用方法有：\n* `screen.width/height` //屏幕的宽度与高度，以像素计 \n* `screen.availWidth/availHeight` //窗口可以使用的屏幕的宽度和高度，以像素计 \n* `screen.colorDepth` //用户表示颜色的位数，大多数系统采用32位 \n* `window.moveTo(0, 0); `\n* `window.resizeTo(screen.availWidth, screen.availHeight); ` //填充用户的屏幕\n\n### location\n\n`location`对象：表示载入窗口的URL。\n常用方法有：\n* `location.href` //当前载入页面的完整URL\n* `location.portocol` //URL中使用的协议，即双斜杠之前的部分，如http\n* `location.host` //服务器的名字，如www.wrox.com\n* `location.hostname` //通常等于host，有时会省略前面的www\n* `location.port` //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080\n* `location.pathname` //URL中主机名后的部分，如/pictures/index.htm\n* `location.search` //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx\n* `location.hash` //如果URL包含#，返回该符号之后的内容，如#anchor1\n* `location.assign(\"http:www.baidu.com\");` //同location.href，新地址都会被加到浏览器的历史栈中\n* `location.replace(\"http:www.baidu.com\");` //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问\n* `location.reload(true | false);` //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false\n\n### history\n\n`history`对象：浏览器窗口的历史\n常用方法有：\n* `history.go(-1);` //访问浏览器窗口的历史，负数为后退，正数为前进\n* `history.back();` //同上\n* `history.forward();` //同上\n* `history.length` //可以查看历史中的页面数\n\n","slug":"DOM本质","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7l0003fr03vf9lpqzj","content":"<h2 id=\"DOM本质\"><a href=\"#DOM本质\" class=\"headerlink\" title=\"DOM本质\"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>\n<h2 id=\"DOM节点操作\"><a href=\"#DOM节点操作\" class=\"headerlink\" title=\"DOM节点操作\"></a>DOM节点操作</h2><h3 id=\"获取DOM节点\"><a href=\"#获取DOM节点\" class=\"headerlink\" title=\"获取DOM节点\"></a>获取DOM节点</h3><ul>\n<li><code>document.getElementById</code></li>\n<li><code>document.getElementsByTagName</code></li>\n<li><code>document.getElementsByClassName</code></li>\n<li><code>document.querySelectorAll</code></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"DOM本质-1\"><a href=\"#DOM本质-1\" class=\"headerlink\" title=\"DOM本质\"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>\n<h2 id=\"DOM节点操作-1\"><a href=\"#DOM节点操作-1\" class=\"headerlink\" title=\"DOM节点操作\"></a>DOM节点操作</h2><h3 id=\"获取DOM节点-1\"><a href=\"#获取DOM节点-1\" class=\"headerlink\" title=\"获取DOM节点\"></a>获取DOM节点</h3><ul>\n<li><code>document.getElementById</code></li>\n<li><code>document.getElementsByTagName</code></li>\n<li><code>document.getElementsByClassName</code></li>\n<li><code>document.querySelectorAll</code></li>\n</ul>\n<h3 id=\"property与attribute\"><a href=\"#property与attribute\" class=\"headerlink\" title=\"property与attribute\"></a>property与attribute</h3><p>虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。</p>\n<ul>\n<li>property是DOM中的属性，是JavaScript里的对象；</li>\n<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>\n</ul>\n<p>例如在html中有一段这样的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">sth</span>=<span class=\"string\">\"whatever\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们在js中来获取这个DOM对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.id); <span class=\"comment\">// 'test'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.sth) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test-2\"</span> &gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test_2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test-2'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test_2.value); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>虽然没有在标签中定义<code>value</code>，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：</p>\n<ul>\n<li>DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。</li>\n<li>如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。</li>\n</ul>\n<p>那么标签上的sth定义在哪里呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png\" alt></p>\n<p>也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(test.attibutes.sth); <span class=\"comment\">// 'sth=\"whatever\"'</span></span><br></pre></td></tr></table></figure></p>\n<p>由此可以得出：</p>\n<ul>\n<li>HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；</li>\n<li>这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；</li>\n</ul>\n<p>那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.value = <span class=\"string\">'new value of prop'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of prop'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.arrtibutes.value); <span class=\"comment\">// 'value=\"1\"'</span></span><br></pre></td></tr></table></figure></p>\n<p>如果反过来，效果又是如何呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.attributes.value = <span class=\"string\">'new value of attr'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of attr'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.attributes.value); <span class=\"comment\">// 'new value of attr'</span></span><br></pre></td></tr></table></figure></p>\n<p>此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.attributes.value.nodeValue = <span class=\"string\">'new value of attr'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>由此，可得出结论：</p>\n<ul>\n<li>property能够从attribute中得到同步；</li>\n<li>attribute不会同步property上的值；</li>\n<li>attribute和property之间的数据绑定是单向的，attribute-&gt;property；</li>\n<li>更改property和attribute上的任意值，都会将更新反映到HTML页面中；</li>\n</ul>\n<h3 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png\" alt></p>\n<p>有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：</p>\n<ul>\n<li>减少DOM访问次数</li>\n<li>多次访问同一DOM，应该用局部变量缓存该DOM</li>\n<li>尽可能使用querySelector，而不是使用获取HTML集合的API</li>\n<li>注意重排（reflow）和重绘（repaint）</li>\n<li>使用事件委托，减少绑定事件的数量</li>\n</ul>\n<h3 id=\"重排（重构）-amp-重绘\"><a href=\"#重排（重构）-amp-重绘\" class=\"headerlink\" title=\"重排（重构）&amp;重绘\"></a>重排（重构）&amp;重绘</h3><p>重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：</p>\n<ul>\n<li>添加或删除DOM元素</li>\n<li>元素位置、大小、内容改变</li>\n<li>浏览器窗口大小改变</li>\n<li>滚动条出现</li>\n</ul>\n<p><strong>最小化重排、重绘的建议：</strong></p>\n<ul>\n<li>不要再修改布局信息的时候，去查询布局信息</li>\n<li>修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式</li>\n<li>:hover会降低响应速度，在处理很大的列表时，避免使用</li>\n</ul>\n<h2 id=\"BOM操作\"><a href=\"#BOM操作\" class=\"headerlink\" title=\"BOM操作\"></a>BOM操作</h2><p>BOM（Browser Object Model）指的是浏览器对象模型，主要用途：</p>\n<ul>\n<li>检测浏览器的类型</li>\n<li>拆解url的各部分</li>\n</ul>\n<h3 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h3><p><code>navigator</code>对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。<br>常用方法有：</p>\n<ul>\n<li><code>navigator.userAgent</code> //用户代理头的字符串表示</li>\n</ul>\n<h3 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h3><p><code>screen</code>对象：用于获取某些关于用户屏幕的信息。<br>常用方法有：</p>\n<ul>\n<li><code>screen.width/height</code> //屏幕的宽度与高度，以像素计 </li>\n<li><code>screen.availWidth/availHeight</code> //窗口可以使用的屏幕的宽度和高度，以像素计 </li>\n<li><code>screen.colorDepth</code> //用户表示颜色的位数，大多数系统采用32位 </li>\n<li><code>window.moveTo(0, 0);</code></li>\n<li><code>window.resizeTo(screen.availWidth, screen.availHeight);</code> //填充用户的屏幕</li>\n</ul>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p><code>location</code>对象：表示载入窗口的URL。<br>常用方法有：</p>\n<ul>\n<li><code>location.href</code> //当前载入页面的完整URL</li>\n<li><code>location.portocol</code> //URL中使用的协议，即双斜杠之前的部分，如http</li>\n<li><code>location.host</code> //服务器的名字，如www.wrox.com</li>\n<li><code>location.hostname</code> //通常等于host，有时会省略前面的www</li>\n<li><code>location.port</code> //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080</li>\n<li><code>location.pathname</code> //URL中主机名后的部分，如/pictures/index.htm</li>\n<li><code>location.search</code> //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx</li>\n<li><code>location.hash</code> //如果URL包含#，返回该符号之后的内容，如#anchor1</li>\n<li><code>location.assign(&quot;http:www.baidu.com&quot;);</code> //同location.href，新地址都会被加到浏览器的历史栈中</li>\n<li><code>location.replace(&quot;http:www.baidu.com&quot;);</code> //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问</li>\n<li><code>location.reload(true | false);</code> //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false</li>\n</ul>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p><code>history</code>对象：浏览器窗口的历史<br>常用方法有：</p>\n<ul>\n<li><code>history.go(-1);</code> //访问浏览器窗口的历史，负数为后退，正数为前进</li>\n<li><code>history.back();</code> //同上</li>\n<li><code>history.forward();</code> //同上</li>\n<li><code>history.length</code> //可以查看历史中的页面数</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"DOM本质\"><a href=\"#DOM本质\" class=\"headerlink\" title=\"DOM本质\"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>\n<h2 id=\"DOM节点操作\"><a href=\"#DOM节点操作\" class=\"headerlink\" title=\"DOM节点操作\"></a>DOM节点操作</h2><h3 id=\"获取DOM节点\"><a href=\"#获取DOM节点\" class=\"headerlink\" title=\"获取DOM节点\"></a>获取DOM节点</h3><ul>\n<li><code>document.getElementById</code></li>\n<li><code>document.getElementsByTagName</code></li>\n<li><code>document.getElementsByClassName</code></li>\n<li><code>document.querySelectorAll</code></li>\n</ul>","more":"<h2 id=\"DOM本质-1\"><a href=\"#DOM本质-1\" class=\"headerlink\" title=\"DOM本质\"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>\n<h2 id=\"DOM节点操作-1\"><a href=\"#DOM节点操作-1\" class=\"headerlink\" title=\"DOM节点操作\"></a>DOM节点操作</h2><h3 id=\"获取DOM节点-1\"><a href=\"#获取DOM节点-1\" class=\"headerlink\" title=\"获取DOM节点\"></a>获取DOM节点</h3><ul>\n<li><code>document.getElementById</code></li>\n<li><code>document.getElementsByTagName</code></li>\n<li><code>document.getElementsByClassName</code></li>\n<li><code>document.querySelectorAll</code></li>\n</ul>\n<h3 id=\"property与attribute\"><a href=\"#property与attribute\" class=\"headerlink\" title=\"property与attribute\"></a>property与attribute</h3><p>虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。</p>\n<ul>\n<li>property是DOM中的属性，是JavaScript里的对象；</li>\n<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>\n</ul>\n<p>例如在html中有一段这样的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">sth</span>=<span class=\"string\">\"whatever\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们在js中来获取这个DOM对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.id); <span class=\"comment\">// 'test'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.sth) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test-2\"</span> &gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test_2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test-2'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test_2.value); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>虽然没有在标签中定义<code>value</code>，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：</p>\n<ul>\n<li>DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。</li>\n<li>如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。</li>\n</ul>\n<p>那么标签上的sth定义在哪里呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png\" alt></p>\n<p>也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(test.attibutes.sth); <span class=\"comment\">// 'sth=\"whatever\"'</span></span><br></pre></td></tr></table></figure></p>\n<p>由此可以得出：</p>\n<ul>\n<li>HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；</li>\n<li>这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；</li>\n</ul>\n<p>那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.value = <span class=\"string\">'new value of prop'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of prop'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.arrtibutes.value); <span class=\"comment\">// 'value=\"1\"'</span></span><br></pre></td></tr></table></figure></p>\n<p>如果反过来，效果又是如何呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.attributes.value = <span class=\"string\">'new value of attr'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of attr'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.attributes.value); <span class=\"comment\">// 'new value of attr'</span></span><br></pre></td></tr></table></figure></p>\n<p>此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.attributes.value.nodeValue = <span class=\"string\">'new value of attr'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>由此，可得出结论：</p>\n<ul>\n<li>property能够从attribute中得到同步；</li>\n<li>attribute不会同步property上的值；</li>\n<li>attribute和property之间的数据绑定是单向的，attribute-&gt;property；</li>\n<li>更改property和attribute上的任意值，都会将更新反映到HTML页面中；</li>\n</ul>\n<h3 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png\" alt></p>\n<p>有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：</p>\n<ul>\n<li>减少DOM访问次数</li>\n<li>多次访问同一DOM，应该用局部变量缓存该DOM</li>\n<li>尽可能使用querySelector，而不是使用获取HTML集合的API</li>\n<li>注意重排（reflow）和重绘（repaint）</li>\n<li>使用事件委托，减少绑定事件的数量</li>\n</ul>\n<h3 id=\"重排（重构）-amp-重绘\"><a href=\"#重排（重构）-amp-重绘\" class=\"headerlink\" title=\"重排（重构）&amp;重绘\"></a>重排（重构）&amp;重绘</h3><p>重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：</p>\n<ul>\n<li>添加或删除DOM元素</li>\n<li>元素位置、大小、内容改变</li>\n<li>浏览器窗口大小改变</li>\n<li>滚动条出现</li>\n</ul>\n<p><strong>最小化重排、重绘的建议：</strong></p>\n<ul>\n<li>不要再修改布局信息的时候，去查询布局信息</li>\n<li>修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式</li>\n<li>:hover会降低响应速度，在处理很大的列表时，避免使用</li>\n</ul>\n<h2 id=\"BOM操作\"><a href=\"#BOM操作\" class=\"headerlink\" title=\"BOM操作\"></a>BOM操作</h2><p>BOM（Browser Object Model）指的是浏览器对象模型，主要用途：</p>\n<ul>\n<li>检测浏览器的类型</li>\n<li>拆解url的各部分</li>\n</ul>\n<h3 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h3><p><code>navigator</code>对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。<br>常用方法有：</p>\n<ul>\n<li><code>navigator.userAgent</code> //用户代理头的字符串表示</li>\n</ul>\n<h3 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h3><p><code>screen</code>对象：用于获取某些关于用户屏幕的信息。<br>常用方法有：</p>\n<ul>\n<li><code>screen.width/height</code> //屏幕的宽度与高度，以像素计 </li>\n<li><code>screen.availWidth/availHeight</code> //窗口可以使用的屏幕的宽度和高度，以像素计 </li>\n<li><code>screen.colorDepth</code> //用户表示颜色的位数，大多数系统采用32位 </li>\n<li><code>window.moveTo(0, 0);</code></li>\n<li><code>window.resizeTo(screen.availWidth, screen.availHeight);</code> //填充用户的屏幕</li>\n</ul>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p><code>location</code>对象：表示载入窗口的URL。<br>常用方法有：</p>\n<ul>\n<li><code>location.href</code> //当前载入页面的完整URL</li>\n<li><code>location.portocol</code> //URL中使用的协议，即双斜杠之前的部分，如http</li>\n<li><code>location.host</code> //服务器的名字，如www.wrox.com</li>\n<li><code>location.hostname</code> //通常等于host，有时会省略前面的www</li>\n<li><code>location.port</code> //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080</li>\n<li><code>location.pathname</code> //URL中主机名后的部分，如/pictures/index.htm</li>\n<li><code>location.search</code> //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx</li>\n<li><code>location.hash</code> //如果URL包含#，返回该符号之后的内容，如#anchor1</li>\n<li><code>location.assign(&quot;http:www.baidu.com&quot;);</code> //同location.href，新地址都会被加到浏览器的历史栈中</li>\n<li><code>location.replace(&quot;http:www.baidu.com&quot;);</code> //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问</li>\n<li><code>location.reload(true | false);</code> //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false</li>\n</ul>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p><code>history</code>对象：浏览器窗口的历史<br>常用方法有：</p>\n<ul>\n<li><code>history.go(-1);</code> //访问浏览器窗口的历史，负数为后退，正数为前进</li>\n<li><code>history.back();</code> //同上</li>\n<li><code>history.forward();</code> //同上</li>\n<li><code>history.length</code> //可以查看历史中的页面数</li>\n</ul>"},{"title":"ES6 核心向新特性（01）","date":"2018-03-07T06:19:15.000Z","_content":"## 块级作用域变量声明关键字 let 、 const\n\n### let 、 const 与 var 的对比\n* 不存在变量提升；\n```js\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n<!-- more -->\n\n## 块级作用域变量声明关键字 let 、 const\n\n### let 、 const 与 var 的对比\n* 不存在变量提升；\n```js\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n* 暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）；\n```js\ntypeof x; // ReferenceError\nlet x;\n```\n* let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用；\n```js\n{\n  let a = 10;\n  var b = 1;\n}\na // ReferenceError: a is not defined.\nb // 1\n```\n* 使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改；\n```js\nconst b = 'hello';\nb = 'world'; // Uncaught TyperError: Assignment to constant variable.\n```\n* 使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面；\n```js\nlet a = 1;\nvar A = 2;\n\nconsole.log(window.a || global.a); // undefined\nconsole.log(window.A || global.A); // 2\n```\n* 用 let 、 const 赋值语句的执行速度比使用 var 快约65%；\n\n### 使用场景的区分\n模块内不变的引用和常量，使用`const`定义；可变的变量或引用使用`let`声明；`var`仅用于声明函数整个作用域内需要使用的变量。\n\n## 字符串模板\n```js\nlet name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n* 字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁\n* 字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出\n\n## 解构赋值\n解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。\n### 数组解构\n▼ **变量的赋值**\n```js\nlet [a, b, c] = [11, 22];\na // 11\nb // 22\nc // undefined\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n▼ **指定默认值**\n```js\nlet [foo = true] = [];\nfoo // true\n```\n### 对象解构\n▼ **变量的赋值**（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）\n```js\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n```\n▼ **指定默认值**\n```js\nvar {x = 3} = {};\nx // 3\n```\n\n## 数组的新特性\n### 扩展运算符(`...`)\n```js\nconst arr =['hello', 'world'];\nconst newArr = [...arr]; // ['hello', 'world']\n```\n**注意点**： `...`进行的数组复制是浅拷贝\n### 扩展API\n* `Array.from`: 用于将数组对象转化为真正的数组\n```js\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n* `Array.of`: 将传入的一组参数转换为数组\n```js\nArray.of(3, 11, 8) // [3,11,8]\n```\n* `Array.prototype.copyWithin`: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用`copyWithin`方法会修改当前数组\n```js\nlet colors = ['red', 'blue', 'green', 'green'];\ncolors.copyWithin(0, 3); // ['green', 'blue', 'green', 'green']\n```\n* `Array.prototype.fill`: 使用给定值，填充一个数组，会改变原来的数组\n```js\ncolors.fill('black'); // ['black', black', black', black']\n```\n* `Arrau.prototype.find`: 用于找出第一个符合条件的数组元素\n```js\ncolors.find(function(color) {\n  if(color === 'green') {\n    return color;\n  }\n}) // green\n```\n* `Array.prototype.findIndex`: 用来返回某个特定数组元素在数组中的位置\n```js\ncolors.findIndex(function(color) {\n  if(color === 'green') {\n    return color;\n  }\n}) // 2\n```\n### 新的数组迭代方式\n`entries()`、`keys()`和`values()`，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用`for...of`循环进行遍历，区别是`keys()`是对数组键名进行遍历，`values()`是对数组键值进行遍历，`entries()`是对数组中键值对进行遍历。\n```js\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n## 增强函数\n### 函数参数\nES6 对函数参数的改进主要是添加了默认参数、不定参数和拓展参数\n\n▼ **默认参数** \n```js\nfunction sayHi(name = 'ouven') {\n  console.log(`Hello ${name}`);\n}\nsayHi(); // Hello ouven\n```\n▼ **不定参数**\n```js\nfunction sayHi(...name) {\n  console.log(name.reduce((a,b) => `Hello ${a} ${b}`));\n}\nsayHi('oven', 'zhang'); // Hello ouven zhang\n```\n▼ **扩展参数**\n```js\nlet name = ['oven', 'zhang'];\nfunction sayHello(name1, name2) {\n  console.log(`Hello ${name1} ${name2}`);\n}\nsayHello(...name); // Hello ouven zhang\n```\n其中不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数将多个参数映射到一个数组。\n▼ **不定参数与 arguments 的对比**\n不定参数和`arguments`都可以使用函数的形参来表示所有的参数组成的列表，但是`arguments`不是真正的数组，所有使用数组的方法必须使用`Array.prototype.slice.call`先将其转换成数组，所有使用起来不定参数更加的方便。\n\n### 箭头函数\n```js\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n**注意点**：箭头函数没有完整的执行上下文，因为其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链， 没有 this 值。\n\n## 增强对象\nes6 中，对象的使用更加方便。在定义对象时通过属性简写、变量作为属性名或省略对象函数属性的书写等方式可以提高编码的效率。\n```js\nconst name = 'onven';\n\nfunction getKey(key) {\n  return key;\n}\n\nconst people = {\n  // 属性简写\n  name,\n  // 返回变量或对象作为属性名\n  [getKey('family')]: 'zhang',\n  // 对象方法属性简写声明\n  sayHi() {\n    console.log(`Hello ${this.name} ${this.family}`);\n  }\n}\n\npeople.sayHi(); // Hello ouven zhang\n```\n**注意点**：为了代码便于维护和理解，建议尽量不将变量或对象作为对象的属性名。\n\n学习参考：\n[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)\n《现代前端技术解析》","source":"_posts/ES6 核心向新特性（01）.md","raw":"---\ntitle: ES6 核心向新特性（01）\ndate: 2018-03-07 14:19:15\ncategories: JS相关\ntags: \n  - JavaScript\n  - ES6\n---\n## 块级作用域变量声明关键字 let 、 const\n\n### let 、 const 与 var 的对比\n* 不存在变量提升；\n```js\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n<!-- more -->\n\n## 块级作用域变量声明关键字 let 、 const\n\n### let 、 const 与 var 的对比\n* 不存在变量提升；\n```js\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n* 暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）；\n```js\ntypeof x; // ReferenceError\nlet x;\n```\n* let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用；\n```js\n{\n  let a = 10;\n  var b = 1;\n}\na // ReferenceError: a is not defined.\nb // 1\n```\n* 使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改；\n```js\nconst b = 'hello';\nb = 'world'; // Uncaught TyperError: Assignment to constant variable.\n```\n* 使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面；\n```js\nlet a = 1;\nvar A = 2;\n\nconsole.log(window.a || global.a); // undefined\nconsole.log(window.A || global.A); // 2\n```\n* 用 let 、 const 赋值语句的执行速度比使用 var 快约65%；\n\n### 使用场景的区分\n模块内不变的引用和常量，使用`const`定义；可变的变量或引用使用`let`声明；`var`仅用于声明函数整个作用域内需要使用的变量。\n\n## 字符串模板\n```js\nlet name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n* 字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁\n* 字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出\n\n## 解构赋值\n解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。\n### 数组解构\n▼ **变量的赋值**\n```js\nlet [a, b, c] = [11, 22];\na // 11\nb // 22\nc // undefined\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n▼ **指定默认值**\n```js\nlet [foo = true] = [];\nfoo // true\n```\n### 对象解构\n▼ **变量的赋值**（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）\n```js\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n```\n▼ **指定默认值**\n```js\nvar {x = 3} = {};\nx // 3\n```\n\n## 数组的新特性\n### 扩展运算符(`...`)\n```js\nconst arr =['hello', 'world'];\nconst newArr = [...arr]; // ['hello', 'world']\n```\n**注意点**： `...`进行的数组复制是浅拷贝\n### 扩展API\n* `Array.from`: 用于将数组对象转化为真正的数组\n```js\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n* `Array.of`: 将传入的一组参数转换为数组\n```js\nArray.of(3, 11, 8) // [3,11,8]\n```\n* `Array.prototype.copyWithin`: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用`copyWithin`方法会修改当前数组\n```js\nlet colors = ['red', 'blue', 'green', 'green'];\ncolors.copyWithin(0, 3); // ['green', 'blue', 'green', 'green']\n```\n* `Array.prototype.fill`: 使用给定值，填充一个数组，会改变原来的数组\n```js\ncolors.fill('black'); // ['black', black', black', black']\n```\n* `Arrau.prototype.find`: 用于找出第一个符合条件的数组元素\n```js\ncolors.find(function(color) {\n  if(color === 'green') {\n    return color;\n  }\n}) // green\n```\n* `Array.prototype.findIndex`: 用来返回某个特定数组元素在数组中的位置\n```js\ncolors.findIndex(function(color) {\n  if(color === 'green') {\n    return color;\n  }\n}) // 2\n```\n### 新的数组迭代方式\n`entries()`、`keys()`和`values()`，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用`for...of`循环进行遍历，区别是`keys()`是对数组键名进行遍历，`values()`是对数组键值进行遍历，`entries()`是对数组中键值对进行遍历。\n```js\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n## 增强函数\n### 函数参数\nES6 对函数参数的改进主要是添加了默认参数、不定参数和拓展参数\n\n▼ **默认参数** \n```js\nfunction sayHi(name = 'ouven') {\n  console.log(`Hello ${name}`);\n}\nsayHi(); // Hello ouven\n```\n▼ **不定参数**\n```js\nfunction sayHi(...name) {\n  console.log(name.reduce((a,b) => `Hello ${a} ${b}`));\n}\nsayHi('oven', 'zhang'); // Hello ouven zhang\n```\n▼ **扩展参数**\n```js\nlet name = ['oven', 'zhang'];\nfunction sayHello(name1, name2) {\n  console.log(`Hello ${name1} ${name2}`);\n}\nsayHello(...name); // Hello ouven zhang\n```\n其中不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数将多个参数映射到一个数组。\n▼ **不定参数与 arguments 的对比**\n不定参数和`arguments`都可以使用函数的形参来表示所有的参数组成的列表，但是`arguments`不是真正的数组，所有使用数组的方法必须使用`Array.prototype.slice.call`先将其转换成数组，所有使用起来不定参数更加的方便。\n\n### 箭头函数\n```js\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n**注意点**：箭头函数没有完整的执行上下文，因为其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链， 没有 this 值。\n\n## 增强对象\nes6 中，对象的使用更加方便。在定义对象时通过属性简写、变量作为属性名或省略对象函数属性的书写等方式可以提高编码的效率。\n```js\nconst name = 'onven';\n\nfunction getKey(key) {\n  return key;\n}\n\nconst people = {\n  // 属性简写\n  name,\n  // 返回变量或对象作为属性名\n  [getKey('family')]: 'zhang',\n  // 对象方法属性简写声明\n  sayHi() {\n    console.log(`Hello ${this.name} ${this.family}`);\n  }\n}\n\npeople.sayHi(); // Hello ouven zhang\n```\n**注意点**：为了代码便于维护和理解，建议尽量不将变量或对象作为对象的属性名。\n\n学习参考：\n[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)\n《现代前端技术解析》","slug":"ES6 核心向新特性（01）","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7l0004fr03xjiopuo2","content":"<h2 id=\"块级作用域变量声明关键字-let-、-const\"><a href=\"#块级作用域变量声明关键字-let-、-const\" class=\"headerlink\" title=\"块级作用域变量声明关键字 let 、 const\"></a>块级作用域变量声明关键字 let 、 const</h2><h3 id=\"let-、-const-与-var-的对比\"><a href=\"#let-、-const-与-var-的对比\" class=\"headerlink\" title=\"let 、 const 与 var 的对比\"></a>let 、 const 与 var 的对比</h3><ul>\n<li>不存在变量提升；<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"块级作用域变量声明关键字-let-、-const-1\"><a href=\"#块级作用域变量声明关键字-let-、-const-1\" class=\"headerlink\" title=\"块级作用域变量声明关键字 let 、 const\"></a>块级作用域变量声明关键字 let 、 const</h2><h3 id=\"let-、-const-与-var-的对比-1\"><a href=\"#let-、-const-与-var-的对比-1\" class=\"headerlink\" title=\"let 、 const 与 var 的对比\"></a>let 、 const 与 var 的对比</h3><ul>\n<li><p>不存在变量提升；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">b = <span class=\"string\">'world'</span>; <span class=\"comment\">// Uncaught TyperError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.a || global.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.A || global.A); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用 let 、 const 赋值语句的执行速度比使用 var 快约65%；</p>\n</li>\n</ul>\n<h3 id=\"使用场景的区分\"><a href=\"#使用场景的区分\" class=\"headerlink\" title=\"使用场景的区分\"></a>使用场景的区分</h3><p>模块内不变的引用和常量，使用<code>const</code>定义；可变的变量或引用使用<code>let</code>声明；<code>var</code>仅用于声明函数整个作用域内需要使用的变量。</p>\n<h2 id=\"字符串模板\"><a href=\"#字符串模板\" class=\"headerlink\" title=\"字符串模板\"></a>字符串模板</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"Bob\"</span>, time = <span class=\"string\">\"today\"</span>;</span><br><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>, how are you <span class=\"subst\">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁</li>\n<li>字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出</li>\n</ul>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。</p>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p>▼ <strong>变量的赋值</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">11</span>, <span class=\"number\">22</span>];</span><br><span class=\"line\">a <span class=\"comment\">// 11</span></span><br><span class=\"line\">b <span class=\"comment\">// 22</span></span><br><span class=\"line\">c <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">head <span class=\"comment\">// 1</span></span><br><span class=\"line\">tail <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, [b], d] = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>];</span><br><span class=\"line\">a <span class=\"comment\">// 1</span></span><br><span class=\"line\">b <span class=\"comment\">// 2</span></span><br><span class=\"line\">d <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>指定默认值</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [foo = <span class=\"literal\">true</span>] = [];</span><br><span class=\"line\">foo <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h3><p>▼ <strong>变量的赋值</strong>（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>指定默认值</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组的新特性\"><a href=\"#数组的新特性\" class=\"headerlink\" title=\"数组的新特性\"></a>数组的新特性</h2><h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符(...)\"></a>扩展运算符(<code>...</code>)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr =[<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArr = [...arr]; <span class=\"comment\">// ['hello', 'world']</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>： <code>...</code>进行的数组复制是浅拷贝</p>\n<h3 id=\"扩展API\"><a href=\"#扩展API\" class=\"headerlink\" title=\"扩展API\"></a>扩展API</h3><ul>\n<li><p><code>Array.from</code>: 用于将数组对象转化为真正的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.of</code>: 将传入的一组参数转换为数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.prototype.copyWithin</code>: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用<code>copyWithin</code>方法会修改当前数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">colors.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>); <span class=\"comment\">// ['green', 'blue', 'green', 'green']</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.prototype.fill</code>: 使用给定值，填充一个数组，会改变原来的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colors.fill(<span class=\"string\">'black'</span>); <span class=\"comment\">// ['black', black', black', black']</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Arrau.prototype.find</code>: 用于找出第一个符合条件的数组元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colors.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(color === <span class=\"string\">'green'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// green</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.prototype.findIndex</code>: 用来返回某个特定数组元素在数组中的位置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colors.findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(color === <span class=\"string\">'green'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"新的数组迭代方式\"><a href=\"#新的数组迭代方式\" class=\"headerlink\" title=\"新的数组迭代方式\"></a>新的数组迭代方式</h3><p><code>entries()</code>、<code>keys()</code>和<code>values()</code>，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用<code>for...of</code>循环进行遍历，区别是<code>keys()</code>是对数组键名进行遍历，<code>values()</code>是对数组键值进行遍历，<code>entries()</code>是对数组中键值对进行遍历。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 'a'</span></span><br><span class=\"line\"><span class=\"comment\">// 'b'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 \"a\"</span></span><br><span class=\"line\"><span class=\"comment\">// 1 \"b\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"增强函数\"><a href=\"#增强函数\" class=\"headerlink\" title=\"增强函数\"></a>增强函数</h2><h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>ES6 对函数参数的改进主要是添加了默认参数、不定参数和拓展参数</p>\n<p>▼ <strong>默认参数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">name = <span class=\"string\">'ouven'</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi(); <span class=\"comment\">// Hello ouven</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>不定参数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">...name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name.reduce(<span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> <span class=\"string\">`Hello <span class=\"subst\">$&#123;a&#125;</span> <span class=\"subst\">$&#123;b&#125;</span>`</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi(<span class=\"string\">'oven'</span>, <span class=\"string\">'zhang'</span>); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>扩展参数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = [<span class=\"string\">'oven'</span>, <span class=\"string\">'zhang'</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">name1, name2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name1&#125;</span> <span class=\"subst\">$&#123;name2&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHello(...name); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure></p>\n<p>其中不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数将多个参数映射到一个数组。<br>▼ <strong>不定参数与 arguments 的对比</strong><br>不定参数和<code>arguments</code>都可以使用函数的形参来表示所有的参数组成的列表，但是<code>arguments</code>不是真正的数组，所有使用数组的方法必须使用<code>Array.prototype.slice.call</code>先将其转换成数组，所有使用起来不定参数更加的方便。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>：箭头函数没有完整的执行上下文，因为其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链， 没有 this 值。</p>\n<h2 id=\"增强对象\"><a href=\"#增强对象\" class=\"headerlink\" title=\"增强对象\"></a>增强对象</h2><p>es6 中，对象的使用更加方便。在定义对象时通过属性简写、变量作为属性名或省略对象函数属性的书写等方式可以提高编码的效率。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'onven'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKey</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> people = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性简写</span></span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"comment\">// 返回变量或对象作为属性名</span></span><br><span class=\"line\">  [getKey(<span class=\"string\">'family'</span>)]: <span class=\"string\">'zhang'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 对象方法属性简写声明</span></span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.family&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">people.sayHi(); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意点</strong>：为了代码便于维护和理解，建议尽量不将变量或对象作为对象的属性名。</p>\n<p>学习参考：<br><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门——阮一峰</a><br>《现代前端技术解析》</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"块级作用域变量声明关键字-let-、-const\"><a href=\"#块级作用域变量声明关键字-let-、-const\" class=\"headerlink\" title=\"块级作用域变量声明关键字 let 、 const\"></a>块级作用域变量声明关键字 let 、 const</h2><h3 id=\"let-、-const-与-var-的对比\"><a href=\"#let-、-const-与-var-的对比\" class=\"headerlink\" title=\"let 、 const 与 var 的对比\"></a>let 、 const 与 var 的对比</h3><ul>\n<li>不存在变量提升；<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<h2 id=\"块级作用域变量声明关键字-let-、-const-1\"><a href=\"#块级作用域变量声明关键字-let-、-const-1\" class=\"headerlink\" title=\"块级作用域变量声明关键字 let 、 const\"></a>块级作用域变量声明关键字 let 、 const</h2><h3 id=\"let-、-const-与-var-的对比-1\"><a href=\"#let-、-const-与-var-的对比-1\" class=\"headerlink\" title=\"let 、 const 与 var 的对比\"></a>let 、 const 与 var 的对比</h3><ul>\n<li><p>不存在变量提升；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>暂时性死区（在代码块内，使用let命令声明变量之前，该变量都是不可用的）；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>let 和 const 都只能作为块级作用域变量的声明，且只能在块级作用域内生效，块内声明的变量无法在块级外层引用；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行第二次修改；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">b = <span class=\"string\">'world'</span>; <span class=\"comment\">// Uncaught TyperError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 let 、 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.a || global.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.A || global.A); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用 let 、 const 赋值语句的执行速度比使用 var 快约65%；</p>\n</li>\n</ul>\n<h3 id=\"使用场景的区分\"><a href=\"#使用场景的区分\" class=\"headerlink\" title=\"使用场景的区分\"></a>使用场景的区分</h3><p>模块内不变的引用和常量，使用<code>const</code>定义；可变的变量或引用使用<code>let</code>声明；<code>var</code>仅用于声明函数整个作用域内需要使用的变量。</p>\n<h2 id=\"字符串模板\"><a href=\"#字符串模板\" class=\"headerlink\" title=\"字符串模板\"></a>字符串模板</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"Bob\"</span>, time = <span class=\"string\">\"today\"</span>;</span><br><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>, how are you <span class=\"subst\">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字符串模板可以在有字符串内容和变量混合连接的场景中，使得代码书写更高效与整洁</li>\n<li>字符串模板不会压缩内部的换行和空格，而是按照原有的格式输出</li>\n</ul>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>解决了赋值的编码荣宇和模块按需导出的问题。主要分为数组解构和对象解构。</p>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p>▼ <strong>变量的赋值</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">11</span>, <span class=\"number\">22</span>];</span><br><span class=\"line\">a <span class=\"comment\">// 11</span></span><br><span class=\"line\">b <span class=\"comment\">// 22</span></span><br><span class=\"line\">c <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">head <span class=\"comment\">// 1</span></span><br><span class=\"line\">tail <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, [b], d] = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>];</span><br><span class=\"line\">a <span class=\"comment\">// 1</span></span><br><span class=\"line\">b <span class=\"comment\">// 2</span></span><br><span class=\"line\">d <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>指定默认值</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [foo = <span class=\"literal\">true</span>] = [];</span><br><span class=\"line\">foo <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h3><p>▼ <strong>变量的赋值</strong>（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>指定默认值</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组的新特性\"><a href=\"#数组的新特性\" class=\"headerlink\" title=\"数组的新特性\"></a>数组的新特性</h2><h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符(...)\"></a>扩展运算符(<code>...</code>)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr =[<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArr = [...arr]; <span class=\"comment\">// ['hello', 'world']</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>： <code>...</code>进行的数组复制是浅拷贝</p>\n<h3 id=\"扩展API\"><a href=\"#扩展API\" class=\"headerlink\" title=\"扩展API\"></a>扩展API</h3><ul>\n<li><p><code>Array.from</code>: 用于将数组对象转化为真正的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.of</code>: 将传入的一组参数转换为数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.prototype.copyWithin</code>: 可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用<code>copyWithin</code>方法会修改当前数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">colors.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>); <span class=\"comment\">// ['green', 'blue', 'green', 'green']</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.prototype.fill</code>: 使用给定值，填充一个数组，会改变原来的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colors.fill(<span class=\"string\">'black'</span>); <span class=\"comment\">// ['black', black', black', black']</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Arrau.prototype.find</code>: 用于找出第一个符合条件的数组元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colors.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(color === <span class=\"string\">'green'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// green</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.prototype.findIndex</code>: 用来返回某个特定数组元素在数组中的位置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colors.findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(color === <span class=\"string\">'green'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"新的数组迭代方式\"><a href=\"#新的数组迭代方式\" class=\"headerlink\" title=\"新的数组迭代方式\"></a>新的数组迭代方式</h3><p><code>entries()</code>、<code>keys()</code>和<code>values()</code>，均可以用来遍历数组。它们都返回一个迭代器对象，也可以用<code>for...of</code>循环进行遍历，区别是<code>keys()</code>是对数组键名进行遍历，<code>values()</code>是对数组键值进行遍历，<code>entries()</code>是对数组中键值对进行遍历。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 'a'</span></span><br><span class=\"line\"><span class=\"comment\">// 'b'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 \"a\"</span></span><br><span class=\"line\"><span class=\"comment\">// 1 \"b\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"增强函数\"><a href=\"#增强函数\" class=\"headerlink\" title=\"增强函数\"></a>增强函数</h2><h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>ES6 对函数参数的改进主要是添加了默认参数、不定参数和拓展参数</p>\n<p>▼ <strong>默认参数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">name = <span class=\"string\">'ouven'</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi(); <span class=\"comment\">// Hello ouven</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>不定参数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">...name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name.reduce(<span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> <span class=\"string\">`Hello <span class=\"subst\">$&#123;a&#125;</span> <span class=\"subst\">$&#123;b&#125;</span>`</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi(<span class=\"string\">'oven'</span>, <span class=\"string\">'zhang'</span>); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>扩展参数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = [<span class=\"string\">'oven'</span>, <span class=\"string\">'zhang'</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">name1, name2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name1&#125;</span> <span class=\"subst\">$&#123;name2&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHello(...name); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure></p>\n<p>其中不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数将多个参数映射到一个数组。<br>▼ <strong>不定参数与 arguments 的对比</strong><br>不定参数和<code>arguments</code>都可以使用函数的形参来表示所有的参数组成的列表，但是<code>arguments</code>不是真正的数组，所有使用数组的方法必须使用<code>Array.prototype.slice.call</code>先将其转换成数组，所有使用起来不定参数更加的方便。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>：箭头函数没有完整的执行上下文，因为其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链， 没有 this 值。</p>\n<h2 id=\"增强对象\"><a href=\"#增强对象\" class=\"headerlink\" title=\"增强对象\"></a>增强对象</h2><p>es6 中，对象的使用更加方便。在定义对象时通过属性简写、变量作为属性名或省略对象函数属性的书写等方式可以提高编码的效率。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'onven'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKey</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> people = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性简写</span></span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"comment\">// 返回变量或对象作为属性名</span></span><br><span class=\"line\">  [getKey(<span class=\"string\">'family'</span>)]: <span class=\"string\">'zhang'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 对象方法属性简写声明</span></span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.family&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">people.sayHi(); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意点</strong>：为了代码便于维护和理解，建议尽量不将变量或对象作为对象的属性名。</p>\n<p>学习参考：<br><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门——阮一峰</a><br>《现代前端技术解析》</p>"},{"title":"ES6 核心向新特性（03）","date":"2018-03-09T10:11:10.000Z","_content":"## Promise\nPromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。\n\n<!-- more -->\n\n## Promise\nPromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。\n\n### 基本用法\n通常 Promise 的状态有三种：Fulfilled 状态表示执行成功；Rejected 状态表示执行失败；Pending 状态表示正在执行中。\n```js\nlet status = 1;\nlet promise = new Promise(function(resolve, reject) {\n  if(status === 1) {\n    resolve('Fulfilled');\n  } else {\n    reject('Rejected');\n  }\n});\nPromise.then(function(msg) {\n  console.log('success1:' + msg);\n  return msg;\n}, function(msg) {\n  console.log('fail1:' + msg);\n  return msg;\n}).then(function(msg) {\n  console.log('success2:' + msg);\n}, function(msg) {\n  console.log('fail2:' + msg);\n});\n// success1: Fulfilled\n// success2: Fulfilled\n```\npromise 的 then 方法接受两个处理函数，当 status 为 1 时执行 Fulfilled 成功调用，否则 Rejected 失败调用。返回的状态给第二个 then 方法处理。then 方法可以将传入参数的返回值一直传递下去，如果是异步的场景，就可以用这种方式来解决多层回调嵌套的问题了。\n### 用 promise 处理异步场景\n```js\n// 希望它依次异步输出 A B C D\nlet promise = new Promise(function(resolve) {\n  setTimeout(function() {\n    console.log('A');\n    resolve();\n  }, 3000); // 延迟3秒打印A\n});\n// 使用 then 来链式处理流程\npromise.then(function() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      console.log('B');\n      resolve();\n    }, 2000); // 延迟2秒打印B\n  });\n}).then(function() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      console.log('C');\n      resolve();\n    }, 1000); // 延迟1秒打印C\n  });\n}).then(function() {\n  return new Promise(function(resolve, reject) {\n    console.log('D');  // 不延迟打印D\n  });\n});\n```\n通过在不同的 then 处理方法中返回一个新的 promise 来解决。返回新的 promise 里面具有`resolve()`和`reject()`方法，只有当它的 resolve 或 reject 被调用时，promise 方法才会继续执行，进入下一个 then 方法中操作。设置在异步函数完成的最后调用`resolve()`就可以有效控制 promise 进入下一个 then 方法执行。\n## Symbol\nSymbol 是除布尔值、数值等六种数据类型外的第七种数据类型。属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n```js\nlet object = {};\nlet name = Symbol();\nlet family = Symbol();\n\nobject[name] = 'ouven';\nobject[family] = 'zhang';\n\nconsole.log(object);\n// {\n//   Symbol(): 'ouven',\n//   Symbol(): 'zhang',\n// }\nconsole.log(typeof name); // symbol\n```\n## Proxy\nProxy 可以用来拦截某个对象的属性访问方法，然后重载对象的`.`运算符。\n```js\nlet object = new Proxy({}, {\n  get: function(target, key, receiver) {\n    console.log(`getting ${key}`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    console.log(`setting ${key}`);\n    return Reflect.set(target, key, value, receiver);\n  }\n});\n\n// 赋值或定义值都会输出\n// getting value\n// setting value\nobject['value'] = 3;\n```\n上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。 \n▼ **基本用法**\n```js\nvar proxy = new Proxy(target, handler);\n```\n`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。\n* `get(target, propKey, receiver)`: 拦截对象属性的读取，如`proxy.foo`和`proxy['foo']`\n* `set(target, proKey, value, receiver)`: 拦截对象属性的设置，如`proxy.foo = v`和`proxy['foo'] = v`\n* ......\n\n## 统一码\nes6 字符串支持新的 Unicode 文本形式，同时也增加了新的正则表达式修饰符`u`来处理统一码。尽管如此，在实际的开发中，这样处理仍会降低程序可读性和处理速度，所以目前不建议使用。\n\n## 进制数支持\nes6 增加了对二进制（b）和八进制（o）数字面量的支持。\n```js\n0b111110111 === 503 // true\n0o767 === 503 // true\n```\n\n## Reflect\nReflect 可以理解为原有对象上的一个引用代理，它用于对原有对象进行赋值或取值操作，但不会触发对象属性的 getter 或 setter 调用，而直接使用 = 对对象进行赋值或取值操作会自动触发 getter 或 setter 方法。\n\n## tail calls 尾调用\ntail calls 尾调用保证了函数尾部调用时调用栈有一定的长度限制，这使得递归函数即使在没有限制输入时也能保证安全性而避免发生错误。\n```js\nfunction factorial(n, start = 1) {\n  if(n < = 1) {\n    return start;    \n  }\n  return factorial(n - 1, n * start);\n}\n// 默认情况下会发生栈溢出，但是在 es6 中是可以安全执行的\nfactorial(100000);\n```\n▼ **基本概念**\n尾调用是指某个函数的最后一步是调用另一个函数。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生\"栈溢出\"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误。\n▼ **注意点**\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。\n\n学习参考：\n[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)\n[尾调用优化](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)\n《现代前端技术解析》","source":"_posts/ES6 核心向新特性（03）.md","raw":"---\ntitle: ES6 核心向新特性（03）\ndate: 2018-03-09 18:11:10\ncategories: JS相关\ntags: \n  - JavaScript\n  - ES6\n---\n## Promise\nPromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。\n\n<!-- more -->\n\n## Promise\nPromise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。\n\n### 基本用法\n通常 Promise 的状态有三种：Fulfilled 状态表示执行成功；Rejected 状态表示执行失败；Pending 状态表示正在执行中。\n```js\nlet status = 1;\nlet promise = new Promise(function(resolve, reject) {\n  if(status === 1) {\n    resolve('Fulfilled');\n  } else {\n    reject('Rejected');\n  }\n});\nPromise.then(function(msg) {\n  console.log('success1:' + msg);\n  return msg;\n}, function(msg) {\n  console.log('fail1:' + msg);\n  return msg;\n}).then(function(msg) {\n  console.log('success2:' + msg);\n}, function(msg) {\n  console.log('fail2:' + msg);\n});\n// success1: Fulfilled\n// success2: Fulfilled\n```\npromise 的 then 方法接受两个处理函数，当 status 为 1 时执行 Fulfilled 成功调用，否则 Rejected 失败调用。返回的状态给第二个 then 方法处理。then 方法可以将传入参数的返回值一直传递下去，如果是异步的场景，就可以用这种方式来解决多层回调嵌套的问题了。\n### 用 promise 处理异步场景\n```js\n// 希望它依次异步输出 A B C D\nlet promise = new Promise(function(resolve) {\n  setTimeout(function() {\n    console.log('A');\n    resolve();\n  }, 3000); // 延迟3秒打印A\n});\n// 使用 then 来链式处理流程\npromise.then(function() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      console.log('B');\n      resolve();\n    }, 2000); // 延迟2秒打印B\n  });\n}).then(function() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      console.log('C');\n      resolve();\n    }, 1000); // 延迟1秒打印C\n  });\n}).then(function() {\n  return new Promise(function(resolve, reject) {\n    console.log('D');  // 不延迟打印D\n  });\n});\n```\n通过在不同的 then 处理方法中返回一个新的 promise 来解决。返回新的 promise 里面具有`resolve()`和`reject()`方法，只有当它的 resolve 或 reject 被调用时，promise 方法才会继续执行，进入下一个 then 方法中操作。设置在异步函数完成的最后调用`resolve()`就可以有效控制 promise 进入下一个 then 方法执行。\n## Symbol\nSymbol 是除布尔值、数值等六种数据类型外的第七种数据类型。属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n```js\nlet object = {};\nlet name = Symbol();\nlet family = Symbol();\n\nobject[name] = 'ouven';\nobject[family] = 'zhang';\n\nconsole.log(object);\n// {\n//   Symbol(): 'ouven',\n//   Symbol(): 'zhang',\n// }\nconsole.log(typeof name); // symbol\n```\n## Proxy\nProxy 可以用来拦截某个对象的属性访问方法，然后重载对象的`.`运算符。\n```js\nlet object = new Proxy({}, {\n  get: function(target, key, receiver) {\n    console.log(`getting ${key}`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    console.log(`setting ${key}`);\n    return Reflect.set(target, key, value, receiver);\n  }\n});\n\n// 赋值或定义值都会输出\n// getting value\n// setting value\nobject['value'] = 3;\n```\n上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。 \n▼ **基本用法**\n```js\nvar proxy = new Proxy(target, handler);\n```\n`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。\n* `get(target, propKey, receiver)`: 拦截对象属性的读取，如`proxy.foo`和`proxy['foo']`\n* `set(target, proKey, value, receiver)`: 拦截对象属性的设置，如`proxy.foo = v`和`proxy['foo'] = v`\n* ......\n\n## 统一码\nes6 字符串支持新的 Unicode 文本形式，同时也增加了新的正则表达式修饰符`u`来处理统一码。尽管如此，在实际的开发中，这样处理仍会降低程序可读性和处理速度，所以目前不建议使用。\n\n## 进制数支持\nes6 增加了对二进制（b）和八进制（o）数字面量的支持。\n```js\n0b111110111 === 503 // true\n0o767 === 503 // true\n```\n\n## Reflect\nReflect 可以理解为原有对象上的一个引用代理，它用于对原有对象进行赋值或取值操作，但不会触发对象属性的 getter 或 setter 调用，而直接使用 = 对对象进行赋值或取值操作会自动触发 getter 或 setter 方法。\n\n## tail calls 尾调用\ntail calls 尾调用保证了函数尾部调用时调用栈有一定的长度限制，这使得递归函数即使在没有限制输入时也能保证安全性而避免发生错误。\n```js\nfunction factorial(n, start = 1) {\n  if(n < = 1) {\n    return start;    \n  }\n  return factorial(n - 1, n * start);\n}\n// 默认情况下会发生栈溢出，但是在 es6 中是可以安全执行的\nfactorial(100000);\n```\n▼ **基本概念**\n尾调用是指某个函数的最后一步是调用另一个函数。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生\"栈溢出\"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误。\n▼ **注意点**\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。\n\n学习参考：\n[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)\n[尾调用优化](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)\n《现代前端技术解析》","slug":"ES6 核心向新特性（03）","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7m0005fr031ym6cs58","content":"<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"Promise-1\"><a href=\"#Promise-1\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>通常 Promise 的状态有三种：Fulfilled 状态表示执行成功；Rejected 状态表示执行失败；Pending 状态表示正在执行中。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> status = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(status === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Fulfilled'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'Rejected'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'success1:'</span> + msg);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fail1:'</span> + msg);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'success2:'</span> + msg);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fail2:'</span> + msg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// success1: Fulfilled</span></span><br><span class=\"line\"><span class=\"comment\">// success2: Fulfilled</span></span><br></pre></td></tr></table></figure></p>\n<p>promise 的 then 方法接受两个处理函数，当 status 为 1 时执行 Fulfilled 成功调用，否则 Rejected 失败调用。返回的状态给第二个 then 方法处理。then 方法可以将传入参数的返回值一直传递下去，如果是异步的场景，就可以用这种方式来解决多层回调嵌套的问题了。</p>\n<h3 id=\"用-promise-处理异步场景\"><a href=\"#用-promise-处理异步场景\" class=\"headerlink\" title=\"用 promise 处理异步场景\"></a>用 promise 处理异步场景</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 希望它依次异步输出 A B C D</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">  &#125;, <span class=\"number\">3000</span>); <span class=\"comment\">// 延迟3秒打印A</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 使用 then 来链式处理流程</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>);</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>); <span class=\"comment\">// 延迟2秒打印B</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'C'</span>);</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>); <span class=\"comment\">// 延迟1秒打印C</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'D'</span>);  <span class=\"comment\">// 不延迟打印D</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过在不同的 then 处理方法中返回一个新的 promise 来解决。返回新的 promise 里面具有<code>resolve()</code>和<code>reject()</code>方法，只有当它的 resolve 或 reject 被调用时，promise 方法才会继续执行，进入下一个 then 方法中操作。设置在异步函数完成的最后调用<code>resolve()</code>就可以有效控制 promise 进入下一个 then 方法执行。</p>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>Symbol 是除布尔值、数值等六种数据类型外的第七种数据类型。属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> object = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> family = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">object[name] = <span class=\"string\">'ouven'</span>;</span><br><span class=\"line\">object[family] = <span class=\"string\">'zhang'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(object);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   Symbol(): 'ouven',</span></span><br><span class=\"line\"><span class=\"comment\">//   Symbol(): 'zhang',</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> name); <span class=\"comment\">// symbol</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><p>Proxy 可以用来拦截某个对象的属性访问方法，然后重载对象的<code>.</code>运算符。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> object = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, value, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 赋值或定义值都会输出</span></span><br><span class=\"line\"><span class=\"comment\">// getting value</span></span><br><span class=\"line\"><span class=\"comment\">// setting value</span></span><br><span class=\"line\">object[<span class=\"string\">'value'</span>] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。<br>▼ <strong>基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure></p>\n<p><code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>\n<ul>\n<li><code>get(target, propKey, receiver)</code>: 拦截对象属性的读取，如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code></li>\n<li><code>set(target, proKey, value, receiver)</code>: 拦截对象属性的设置，如<code>proxy.foo = v</code>和<code>proxy[&#39;foo&#39;] = v</code></li>\n<li>……</li>\n</ul>\n<h2 id=\"统一码\"><a href=\"#统一码\" class=\"headerlink\" title=\"统一码\"></a>统一码</h2><p>es6 字符串支持新的 Unicode 文本形式，同时也增加了新的正则表达式修饰符<code>u</code>来处理统一码。尽管如此，在实际的开发中，这样处理仍会降低程序可读性和处理速度，所以目前不建议使用。</p>\n<h2 id=\"进制数支持\"><a href=\"#进制数支持\" class=\"headerlink\" title=\"进制数支持\"></a>进制数支持</h2><p>es6 增加了对二进制（b）和八进制（o）数字面量的支持。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0b111110111</span> === <span class=\"number\">503</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0o767</span> === <span class=\"number\">503</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><p>Reflect 可以理解为原有对象上的一个引用代理，它用于对原有对象进行赋值或取值操作，但不会触发对象属性的 getter 或 setter 调用，而直接使用 = 对对象进行赋值或取值操作会自动触发 getter 或 setter 方法。</p>\n<h2 id=\"tail-calls-尾调用\"><a href=\"#tail-calls-尾调用\" class=\"headerlink\" title=\"tail calls 尾调用\"></a>tail calls 尾调用</h2><p>tail calls 尾调用保证了函数尾部调用时调用栈有一定的长度限制，这使得递归函数即使在没有限制输入时也能保证安全性而避免发生错误。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, start = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n &lt; = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> start;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * start);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下会发生栈溢出，但是在 es6 中是可以安全执行的</span></span><br><span class=\"line\">factorial(<span class=\"number\">100000</span>);</span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>基本概念</strong><br>尾调用是指某个函数的最后一步是调用另一个函数。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<br>▼ <strong>注意点</strong><br>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>\n<p>学习参考：<br><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门——阮一峰</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/04/tail-call.html\" target=\"_blank\" rel=\"noopener\">尾调用优化</a><br>《现代前端技术解析》</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。</p>","more":"<h2 id=\"Promise-1\"><a href=\"#Promise-1\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，用来避免异步操作函数里的多层嵌套回调（callback）问题。Promise 代表一个异步操作的执行返回状态，这个执行回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>通常 Promise 的状态有三种：Fulfilled 状态表示执行成功；Rejected 状态表示执行失败；Pending 状态表示正在执行中。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> status = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(status === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Fulfilled'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'Rejected'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'success1:'</span> + msg);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fail1:'</span> + msg);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'success2:'</span> + msg);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fail2:'</span> + msg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// success1: Fulfilled</span></span><br><span class=\"line\"><span class=\"comment\">// success2: Fulfilled</span></span><br></pre></td></tr></table></figure></p>\n<p>promise 的 then 方法接受两个处理函数，当 status 为 1 时执行 Fulfilled 成功调用，否则 Rejected 失败调用。返回的状态给第二个 then 方法处理。then 方法可以将传入参数的返回值一直传递下去，如果是异步的场景，就可以用这种方式来解决多层回调嵌套的问题了。</p>\n<h3 id=\"用-promise-处理异步场景\"><a href=\"#用-promise-处理异步场景\" class=\"headerlink\" title=\"用 promise 处理异步场景\"></a>用 promise 处理异步场景</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 希望它依次异步输出 A B C D</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">  &#125;, <span class=\"number\">3000</span>); <span class=\"comment\">// 延迟3秒打印A</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 使用 then 来链式处理流程</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>);</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>); <span class=\"comment\">// 延迟2秒打印B</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'C'</span>);</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>); <span class=\"comment\">// 延迟1秒打印C</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'D'</span>);  <span class=\"comment\">// 不延迟打印D</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过在不同的 then 处理方法中返回一个新的 promise 来解决。返回新的 promise 里面具有<code>resolve()</code>和<code>reject()</code>方法，只有当它的 resolve 或 reject 被调用时，promise 方法才会继续执行，进入下一个 then 方法中操作。设置在异步函数完成的最后调用<code>resolve()</code>就可以有效控制 promise 进入下一个 then 方法执行。</p>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>Symbol 是除布尔值、数值等六种数据类型外的第七种数据类型。属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> object = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> family = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">object[name] = <span class=\"string\">'ouven'</span>;</span><br><span class=\"line\">object[family] = <span class=\"string\">'zhang'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(object);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   Symbol(): 'ouven',</span></span><br><span class=\"line\"><span class=\"comment\">//   Symbol(): 'zhang',</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> name); <span class=\"comment\">// symbol</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><p>Proxy 可以用来拦截某个对象的属性访问方法，然后重载对象的<code>.</code>运算符。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> object = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, value, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 赋值或定义值都会输出</span></span><br><span class=\"line\"><span class=\"comment\">// getting value</span></span><br><span class=\"line\"><span class=\"comment\">// setting value</span></span><br><span class=\"line\">object[<span class=\"string\">'value'</span>] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。<br>▼ <strong>基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure></p>\n<p><code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>\n<ul>\n<li><code>get(target, propKey, receiver)</code>: 拦截对象属性的读取，如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code></li>\n<li><code>set(target, proKey, value, receiver)</code>: 拦截对象属性的设置，如<code>proxy.foo = v</code>和<code>proxy[&#39;foo&#39;] = v</code></li>\n<li>……</li>\n</ul>\n<h2 id=\"统一码\"><a href=\"#统一码\" class=\"headerlink\" title=\"统一码\"></a>统一码</h2><p>es6 字符串支持新的 Unicode 文本形式，同时也增加了新的正则表达式修饰符<code>u</code>来处理统一码。尽管如此，在实际的开发中，这样处理仍会降低程序可读性和处理速度，所以目前不建议使用。</p>\n<h2 id=\"进制数支持\"><a href=\"#进制数支持\" class=\"headerlink\" title=\"进制数支持\"></a>进制数支持</h2><p>es6 增加了对二进制（b）和八进制（o）数字面量的支持。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0b111110111</span> === <span class=\"number\">503</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0o767</span> === <span class=\"number\">503</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><p>Reflect 可以理解为原有对象上的一个引用代理，它用于对原有对象进行赋值或取值操作，但不会触发对象属性的 getter 或 setter 调用，而直接使用 = 对对象进行赋值或取值操作会自动触发 getter 或 setter 方法。</p>\n<h2 id=\"tail-calls-尾调用\"><a href=\"#tail-calls-尾调用\" class=\"headerlink\" title=\"tail calls 尾调用\"></a>tail calls 尾调用</h2><p>tail calls 尾调用保证了函数尾部调用时调用栈有一定的长度限制，这使得递归函数即使在没有限制输入时也能保证安全性而避免发生错误。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, start = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n &lt; = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> start;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * start);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下会发生栈溢出，但是在 es6 中是可以安全执行的</span></span><br><span class=\"line\">factorial(<span class=\"number\">100000</span>);</span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>基本概念</strong><br>尾调用是指某个函数的最后一步是调用另一个函数。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<br>▼ <strong>注意点</strong><br>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>\n<p>学习参考：<br><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门——阮一峰</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/04/tail-call.html\" target=\"_blank\" rel=\"noopener\">尾调用优化</a><br>《现代前端技术解析》</p>"},{"title":"JSON学习笔记","date":"2017-03-21T10:16:43.000Z","_content":"> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","source":"_posts/JSON学习笔记.md","raw":"---\ntitle: JSON学习笔记\ndate: 2017-03-21 18:16:43\ncategories: 知识碎片\ntags: \n  - JSON\n---\n> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","slug":"JSON学习笔记","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7n0006fr034kdtecrb","content":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>\n<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</span><br><span class=\"line\"><span class=\"comment\">//解析完毕</span></span><br><span class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</span><br><span class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>","more":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>\n<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</span><br><span class=\"line\"><span class=\"comment\">//解析完毕</span></span><br><span class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</span><br><span class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"JS之this指针笔记","date":"2017-07-08T05:48:43.000Z","_content":"## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!-- more -->\n\n## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n  this.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n  alert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n  test: function () {\n    this.x = 1;\n  } //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n  test: function () {\n    //在构造函数的时候也会调用其他的函数，所以this的指向就会变\n    $(this.xx).on(\"click\",function(){\n      //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n    })\n  } \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n  name: \"小明\",\n  sex: \"男\",\n  age: \"18\",\n  say: function() {\n    alert(this.name + \",\" + this.sex + \",\" + this.age);\n  }\n}\n\nvar xh = {\n  name: \"小红\",\n  sex: \"女\",\n  age: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n  this.txt = \"这是一个对象属性\";\n  $(\"div\").click($.proxy(this.myClick,this));\n  //本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n  alert(this.txt);\n  alert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","source":"_posts/JS之this指针笔记.md","raw":"---\ntitle: JS之this指针笔记\ndate: 2017-07-08 13:48:43\ncategories: JS相关\ntags: \n  - JavaScript\n---\n## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!-- more -->\n\n## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n  this.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n  alert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n  test: function () {\n    this.x = 1;\n  } //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n  test: function () {\n    //在构造函数的时候也会调用其他的函数，所以this的指向就会变\n    $(this.xx).on(\"click\",function(){\n      //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n    })\n  } \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n  name: \"小明\",\n  sex: \"男\",\n  age: \"18\",\n  say: function() {\n    alert(this.name + \",\" + this.sex + \",\" + this.age);\n  }\n}\n\nvar xh = {\n  name: \"小红\",\n  sex: \"女\",\n  age: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n  this.txt = \"这是一个对象属性\";\n  $(\"div\").click($.proxy(this.myClick,this));\n  //本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n  alert(this.txt);\n  alert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","slug":"JS之this指针笔记","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7n0007fr03gcx4i283","content":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"this指针-1\"><a href=\"#this指针-1\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>\n<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">o.m = test;</span><br><span class=\"line\">o.m(); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  test: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  test: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></span><br><span class=\"line\">    $(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"小明\"</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">\"男\"</span>,</span><br><span class=\"line\">  age: <span class=\"string\">\"18\"</span>,</span><br><span class=\"line\">  say: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"小红\"</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">\"女\"</span>,</span><br><span class=\"line\">  age: <span class=\"string\">\"20\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</span><br><span class=\"line\">  $(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.txt);</span><br><span class=\"line\">  alert(event.currentTarget.nodeName);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>","more":"<h2 id=\"this指针-1\"><a href=\"#this指针-1\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>\n<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">o.m = test;</span><br><span class=\"line\">o.m(); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  test: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  test: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></span><br><span class=\"line\">    $(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"小明\"</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">\"男\"</span>,</span><br><span class=\"line\">  age: <span class=\"string\">\"18\"</span>,</span><br><span class=\"line\">  say: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"小红\"</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">\"女\"</span>,</span><br><span class=\"line\">  age: <span class=\"string\">\"20\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</span><br><span class=\"line\">  $(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.txt);</span><br><span class=\"line\">  alert(event.currentTarget.nodeName);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"JS变量计算","date":"2017-08-24T12:53:29.000Z","_content":"## typeof 运算符\n\n```javascript\ntypeof undefined // undefined\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof {} // object\ntypeof [] // object\ntypeof null // object\ntypeof console.log // function\n```\n\n<!-- more -->\n\n## typeof 运算符\n\n```javascript\ntypeof undefined // undefined\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof {} // object\ntypeof [] // object\ntypeof null // object\ntypeof console.log // function\n```\n\n## 变量运算 - 强制类型转换\n\n### 字符串拼接\n\n```javascript\nvar a = 100 + 10 // 110\nvar b = 100 + '10' // '10010'\n```\n当使用减运算时：\n```javascript\nvar c = '100' - 10 // 90\n```\n\n### == 运算符\n\n```javascript\n100 == '100' // true\n0 == '' // true\nnull == undefined // true\n```\n`==`与`===`的区别：`===`是严格等于，只有类型完全相同才会返回`true`\n```javascript\nnull === null\nundefined === undefined\nnull === undefined // false\nNaN === NaN // false\n```\n什么时候用`==`什么时候用`===`：jQuery源码中推荐写法，只有下述情况才用`==`，其他时候都用`===`。\n```javascript\nif(a == null) {\n  // 这里相当于 a === null || a === undefined\n}\n```\n\n### if语句\n\n```javascript\nvar a = true;\nif(a) { //... } \n\nvar b = 100; // true\nif(b) { //... }\n\nvar c = ''; // false\nif(c) { //... }\n```\n`if`中被判定为`false`的几个值：`0`,`NaN`,`''`,`null`,`undefined`\n\n### 逻辑运算\n\n```javascript\nconsole.log(10 && 0) // 0\nconsole.log('' || 'abc') // 'abc'\nconsole.log(!window.abc) // true\n\n// 判断一个变量会被当做 true 还是 false\nvar a = 100;\nconsole.log(!!a) //true\n```","source":"_posts/JS变量计算.md","raw":"---\ntitle: JS变量计算\ndate: 2017-08-24 20:53:29\ncategories: JS相关\ntags: \n  - JavaScript\n---\n## typeof 运算符\n\n```javascript\ntypeof undefined // undefined\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof {} // object\ntypeof [] // object\ntypeof null // object\ntypeof console.log // function\n```\n\n<!-- more -->\n\n## typeof 运算符\n\n```javascript\ntypeof undefined // undefined\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof {} // object\ntypeof [] // object\ntypeof null // object\ntypeof console.log // function\n```\n\n## 变量运算 - 强制类型转换\n\n### 字符串拼接\n\n```javascript\nvar a = 100 + 10 // 110\nvar b = 100 + '10' // '10010'\n```\n当使用减运算时：\n```javascript\nvar c = '100' - 10 // 90\n```\n\n### == 运算符\n\n```javascript\n100 == '100' // true\n0 == '' // true\nnull == undefined // true\n```\n`==`与`===`的区别：`===`是严格等于，只有类型完全相同才会返回`true`\n```javascript\nnull === null\nundefined === undefined\nnull === undefined // false\nNaN === NaN // false\n```\n什么时候用`==`什么时候用`===`：jQuery源码中推荐写法，只有下述情况才用`==`，其他时候都用`===`。\n```javascript\nif(a == null) {\n  // 这里相当于 a === null || a === undefined\n}\n```\n\n### if语句\n\n```javascript\nvar a = true;\nif(a) { //... } \n\nvar b = 100; // true\nif(b) { //... }\n\nvar c = ''; // false\nif(c) { //... }\n```\n`if`中被判定为`false`的几个值：`0`,`NaN`,`''`,`null`,`undefined`\n\n### 逻辑运算\n\n```javascript\nconsole.log(10 && 0) // 0\nconsole.log('' || 'abc') // 'abc'\nconsole.log(!window.abc) // true\n\n// 判断一个变量会被当做 true 还是 false\nvar a = 100;\nconsole.log(!!a) //true\n```","slug":"JS变量计算","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7s0008fr03mbp4hzdk","content":"<h2 id=\"typeof-运算符\"><a href=\"#typeof-运算符\" class=\"headerlink\" title=\"typeof 运算符\"></a>typeof 运算符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'abc'</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"typeof-运算符-1\"><a href=\"#typeof-运算符-1\" class=\"headerlink\" title=\"typeof 运算符\"></a>typeof 运算符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'abc'</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"变量运算-强制类型转换\"><a href=\"#变量运算-强制类型转换\" class=\"headerlink\" title=\"变量运算 - 强制类型转换\"></a>变量运算 - 强制类型转换</h2><h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span> + <span class=\"number\">10</span> <span class=\"comment\">// 110</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span> + <span class=\"string\">'10'</span> <span class=\"comment\">// '10010'</span></span><br></pre></td></tr></table></figure>\n<p>当使用减运算时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">'100'</span> - <span class=\"number\">10</span> <span class=\"comment\">// 90</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"== 运算符\"></a>== 运算符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span> == <span class=\"string\">'100'</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">''</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>==</code>与<code>===</code>的区别：<code>===</code>是严格等于，只有类型完全相同才会返回<code>true</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>什么时候用<code>==</code>什么时候用<code>===</code>：jQuery源码中推荐写法，只有下述情况才用<code>==</code>，其他时候都用<code>===</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(a == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里相当于 a === null || a === undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a) &#123; <span class=\"comment\">//... &#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(b) &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">''</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(c) &#123; <span class=\"comment\">//... &#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>if</code>中被判定为<code>false</code>的几个值：<code>0</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>null</code>,<code>undefined</code></p>\n<h3 id=\"逻辑运算\"><a href=\"#逻辑运算\" class=\"headerlink\" title=\"逻辑运算\"></a>逻辑运算</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">10</span> &amp;&amp; <span class=\"number\">0</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">''</span> || <span class=\"string\">'abc'</span>) <span class=\"comment\">// 'abc'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(!<span class=\"built_in\">window</span>.abc) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断一个变量会被当做 true 还是 false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(!!a) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"typeof-运算符\"><a href=\"#typeof-运算符\" class=\"headerlink\" title=\"typeof 运算符\"></a>typeof 运算符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'abc'</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"typeof-运算符-1\"><a href=\"#typeof-运算符-1\" class=\"headerlink\" title=\"typeof 运算符\"></a>typeof 运算符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'abc'</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"变量运算-强制类型转换\"><a href=\"#变量运算-强制类型转换\" class=\"headerlink\" title=\"变量运算 - 强制类型转换\"></a>变量运算 - 强制类型转换</h2><h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span> + <span class=\"number\">10</span> <span class=\"comment\">// 110</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span> + <span class=\"string\">'10'</span> <span class=\"comment\">// '10010'</span></span><br></pre></td></tr></table></figure>\n<p>当使用减运算时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">'100'</span> - <span class=\"number\">10</span> <span class=\"comment\">// 90</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"== 运算符\"></a>== 运算符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span> == <span class=\"string\">'100'</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">''</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>==</code>与<code>===</code>的区别：<code>===</code>是严格等于，只有类型完全相同才会返回<code>true</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>什么时候用<code>==</code>什么时候用<code>===</code>：jQuery源码中推荐写法，只有下述情况才用<code>==</code>，其他时候都用<code>===</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(a == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里相当于 a === null || a === undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a) &#123; <span class=\"comment\">//... &#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(b) &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">''</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(c) &#123; <span class=\"comment\">//... &#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>if</code>中被判定为<code>false</code>的几个值：<code>0</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>null</code>,<code>undefined</code></p>\n<h3 id=\"逻辑运算\"><a href=\"#逻辑运算\" class=\"headerlink\" title=\"逻辑运算\"></a>逻辑运算</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">10</span> &amp;&amp; <span class=\"number\">0</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">''</span> || <span class=\"string\">'abc'</span>) <span class=\"comment\">// 'abc'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(!<span class=\"built_in\">window</span>.abc) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断一个变量会被当做 true 还是 false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(!!a) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>"},{"title":"JS继承笔记","date":"2017-07-07T14:02:11.000Z","_content":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n<!-- more -->\n\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","source":"_posts/JS继承笔记.md","raw":"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\ncategories: JS相关\ntags: \n  - JavaScript\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n<!-- more -->\n\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","slug":"JS继承笔记","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7s0009fr03xfwgdzix","content":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<a id=\"more\"></a>\n<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//现有两个构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</span><br><span class=\"line\">  Animal.apply(<span class=\"keyword\">this</span>.arguments);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</span><br><span class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></span><br><span class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</span><br><span class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funtion Animal() &#123;&#125;</span><br><span class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype = Animal.prototype;</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">F.prototype = Animal.prototype;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  temp.prototype = parent.prototype;</span><br><span class=\"line\">  child.prototype = <span class=\"keyword\">new</span> temp();</span><br><span class=\"line\">  child.prototype.constructor = child;</span><br><span class=\"line\">  child.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>","more":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//现有两个构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</span><br><span class=\"line\">  Animal.apply(<span class=\"keyword\">this</span>.arguments);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</span><br><span class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></span><br><span class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</span><br><span class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funtion Animal() &#123;&#125;</span><br><span class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype = Animal.prototype;</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">F.prototype = Animal.prototype;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  temp.prototype = parent.prototype;</span><br><span class=\"line\">  child.prototype = <span class=\"keyword\">new</span> temp();</span><br><span class=\"line\">  child.prototype.constructor = child;</span><br><span class=\"line\">  child.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt></p>"},{"title":"JS面向对象学习笔记","date":"2017-08-16T13:20:29.000Z","_content":"## 面向对象（OOP）的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n\n<!-- more -->\n\n## 面向对象（OOP）的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n\n**对象有哪些特性？**\n* **封装性：**通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。\n* **继承：**很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。\n* **多态：**多态指的不同类的对象对同一消息作出不同的响应。\n\n**面向对象的优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。\n\nJavaScript作为一门面向对象的语言，却并不是通过**类**来实现面向对象的，而是通过**原型（prototype）**。那么这两者实现面向对象究竟有什么区别呢？\n\n### 基于类vs基于原型\n\n基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。\n* **类（class）：**定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。\n* **实例（instance）：**类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。\n\n\n```java\n//定义类\npublic class Person {\n  String name;\n  int age;\n  void walking() {\n  }\n  void sleeping() {\n  }\n  Person(x,y) {\n    name = x;\n    age = y;\n  }//类的构造函数\n}\n//实例化\nPerson xm = new Person('xm',18);\n```\n\n其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。\n而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar xm = new Person('xm',18);\n```\n### new操作符\n\n在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。\n在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的**两个步骤**\n* 将实例的`._proto_`指向构造函数的`prototype`属性。\n* 调用构造函数来初始化实例对象。（`call`、`apply`）\n\n### 原型对象\n\n对象不仅仅有自己独特的属性，例如`Person`，每个`Person`的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。\n\n在Java中，共用的方法会采用静态的方式用`static`修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。\n\n而在JS中，则引入了原型对象。原型对象就是构造函数的`prototype`属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个`constructor`属性来指向该原型实例的构造函数。\n\n## 原型链\n\n由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的`_proto_`属性，`constructor`属性和`prototype`属性，它们相互指来指去，就形成了一条原型链。\n\n以`Person`这个构造函数为例，我们创建了它的实例`xm`，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中`_proto_`其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png)\n\n### 属性查找\n\n当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回`undefined`。\n\n## 创建对象\n\n* 基于Object对象创建\n\n```javascript\nvar person = new Object();\nperson.name = 'xm';\nperson.age = 18;\nperson.getName = function() {\n  return this.name;\n}\n```\n* 字面量的方式：清晰的查找对象包含的属性和方法\n\n```javascript\nvar person = {\n  name: 'xm',\n  age: 18,\n  getName: function() {\n    return this.name;\n  }\n}\n```\n* 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。\n\n```javascript\nfunctioni createPerson(name,age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.getName = function() {\n    return this.name;\n  }\n  return o;\n}\nvar person = createPerson('xm',18);\n```\n* 构造函数模式\n\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n  this.getName = function() {\n    return this.name;\n  }\n}\nvar person = new Person('xm',18);\n```\n* `Object.create(prototype, descriptors)`：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数`prototype`。\n参数说明：\n`prototype`：必需。要用作原型的对象，可以为`null`。\n`descriptors`：可选。包含一个或多个属性描述符的JavaScript对象。\n\n```javascript\nvar var obj = Object.create({x:1});\nobj.hasOwnProperty('x');//false\n```","source":"_posts/JS面向对象学习笔记.md","raw":"---\ntitle: JS面向对象学习笔记\ndate: 2017-08-16 21:20:29\ncategories: JS相关\ntags: \n  - JavaScript\n---\n## 面向对象（OOP）的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n\n<!-- more -->\n\n## 面向对象（OOP）的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n\n**对象有哪些特性？**\n* **封装性：**通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。\n* **继承：**很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。\n* **多态：**多态指的不同类的对象对同一消息作出不同的响应。\n\n**面向对象的优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。\n\nJavaScript作为一门面向对象的语言，却并不是通过**类**来实现面向对象的，而是通过**原型（prototype）**。那么这两者实现面向对象究竟有什么区别呢？\n\n### 基于类vs基于原型\n\n基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。\n* **类（class）：**定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。\n* **实例（instance）：**类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。\n\n\n```java\n//定义类\npublic class Person {\n  String name;\n  int age;\n  void walking() {\n  }\n  void sleeping() {\n  }\n  Person(x,y) {\n    name = x;\n    age = y;\n  }//类的构造函数\n}\n//实例化\nPerson xm = new Person('xm',18);\n```\n\n其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。\n而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar xm = new Person('xm',18);\n```\n### new操作符\n\n在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。\n在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的**两个步骤**\n* 将实例的`._proto_`指向构造函数的`prototype`属性。\n* 调用构造函数来初始化实例对象。（`call`、`apply`）\n\n### 原型对象\n\n对象不仅仅有自己独特的属性，例如`Person`，每个`Person`的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。\n\n在Java中，共用的方法会采用静态的方式用`static`修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。\n\n而在JS中，则引入了原型对象。原型对象就是构造函数的`prototype`属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个`constructor`属性来指向该原型实例的构造函数。\n\n## 原型链\n\n由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的`_proto_`属性，`constructor`属性和`prototype`属性，它们相互指来指去，就形成了一条原型链。\n\n以`Person`这个构造函数为例，我们创建了它的实例`xm`，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中`_proto_`其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png)\n\n### 属性查找\n\n当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回`undefined`。\n\n## 创建对象\n\n* 基于Object对象创建\n\n```javascript\nvar person = new Object();\nperson.name = 'xm';\nperson.age = 18;\nperson.getName = function() {\n  return this.name;\n}\n```\n* 字面量的方式：清晰的查找对象包含的属性和方法\n\n```javascript\nvar person = {\n  name: 'xm',\n  age: 18,\n  getName: function() {\n    return this.name;\n  }\n}\n```\n* 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。\n\n```javascript\nfunctioni createPerson(name,age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.getName = function() {\n    return this.name;\n  }\n  return o;\n}\nvar person = createPerson('xm',18);\n```\n* 构造函数模式\n\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n  this.getName = function() {\n    return this.name;\n  }\n}\nvar person = new Person('xm',18);\n```\n* `Object.create(prototype, descriptors)`：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数`prototype`。\n参数说明：\n`prototype`：必需。要用作原型的对象，可以为`null`。\n`descriptors`：可选。包含一个或多个属性描述符的JavaScript对象。\n\n```javascript\nvar var obj = Object.create({x:1});\nobj.hasOwnProperty('x');//false\n```","slug":"JS面向对象学习笔记","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7t000afr03ffn075nk","content":"<h2 id=\"面向对象（OOP）的概念\"><a href=\"#面向对象（OOP）的概念\" class=\"headerlink\" title=\"面向对象（OOP）的概念\"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"面向对象（OOP）的概念-1\"><a href=\"#面向对象（OOP）的概念-1\" class=\"headerlink\" title=\"面向对象（OOP）的概念\"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>\n</ul>\n<p><strong>对象有哪些特性？</strong></p>\n<ul>\n<li><strong>封装性：</strong>通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。</li>\n<li><strong>继承：</strong>很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。</li>\n<li><strong>多态：</strong>多态指的不同类的对象对同一消息作出不同的响应。</li>\n</ul>\n<p><strong>面向对象的优点：</strong>易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。</p>\n<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>\n<h3 id=\"基于类vs基于原型\"><a href=\"#基于类vs基于原型\" class=\"headerlink\" title=\"基于类vs基于原型\"></a>基于类vs基于原型</h3><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>\n<ul>\n<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>\n<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  String name;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">walking</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleeping</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Person(x,y) &#123;</span><br><span class=\"line\">    name = x;</span><br><span class=\"line\">    age = y;</span><br><span class=\"line\">  &#125;<span class=\"comment\">//类的构造函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实例化</span></span><br><span class=\"line\">Person xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h3><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>\n<ul>\n<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>\n<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>\n</ul>\n<h3 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h3><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>\n<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>\n<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>\n<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png\" alt></p>\n<h3 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h3><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li>基于Object对象创建</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">person.name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">person.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">person.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>字面量的方式：清晰的查找对象包含的属性和方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xm'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functioni createPerson(name,age) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  o.name = name;</span><br><span class=\"line\">  o.age = age;</span><br><span class=\"line\">  o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = createPerson(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">obj.hasOwnProperty(<span class=\"string\">'x'</span>);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"面向对象（OOP）的概念\"><a href=\"#面向对象（OOP）的概念\" class=\"headerlink\" title=\"面向对象（OOP）的概念\"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>\n</ul>","more":"<h2 id=\"面向对象（OOP）的概念-1\"><a href=\"#面向对象（OOP）的概念-1\" class=\"headerlink\" title=\"面向对象（OOP）的概念\"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>\n</ul>\n<p><strong>对象有哪些特性？</strong></p>\n<ul>\n<li><strong>封装性：</strong>通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。</li>\n<li><strong>继承：</strong>很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。</li>\n<li><strong>多态：</strong>多态指的不同类的对象对同一消息作出不同的响应。</li>\n</ul>\n<p><strong>面向对象的优点：</strong>易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。</p>\n<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>\n<h3 id=\"基于类vs基于原型\"><a href=\"#基于类vs基于原型\" class=\"headerlink\" title=\"基于类vs基于原型\"></a>基于类vs基于原型</h3><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>\n<ul>\n<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>\n<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  String name;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">walking</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleeping</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Person(x,y) &#123;</span><br><span class=\"line\">    name = x;</span><br><span class=\"line\">    age = y;</span><br><span class=\"line\">  &#125;<span class=\"comment\">//类的构造函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实例化</span></span><br><span class=\"line\">Person xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h3><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>\n<ul>\n<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>\n<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>\n</ul>\n<h3 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h3><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>\n<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>\n<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>\n<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png\" alt></p>\n<h3 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h3><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li>基于Object对象创建</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">person.name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">person.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">person.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>字面量的方式：清晰的查找对象包含的属性和方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xm'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functioni createPerson(name,age) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  o.name = name;</span><br><span class=\"line\">  o.age = age;</span><br><span class=\"line\">  o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = createPerson(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">obj.hasOwnProperty(<span class=\"string\">'x'</span>);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>"},{"title":"JS定时器与单线程","date":"2017-09-25T13:28:25.000Z","_content":"## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n<!-- more -->\n\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","source":"_posts/JavaScript单线程.md","raw":"---\ntitle: JS定时器与单线程\ndate: 2017-09-25 21:28:25\ncategories: JS相关\ntags: \n  - JavaScript\n---\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n<!-- more -->\n\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","slug":"JavaScript单线程","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7u000bfr036gornyks","content":"<h2 id=\"JavaScript单线程\"><a href=\"#JavaScript单线程\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>\n<a id=\"more\"></a>\n<h2 id=\"JavaScript单线程-1\"><a href=\"#JavaScript单线程-1\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>\n<p>这里有个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"comment\">//打印才进入时的时间</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'first time: '</span> + date.getTime());</span><br><span class=\"line\"><span class=\"comment\">//一秒后打印setTimeout里匿名函数的时间</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> date1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'second time: '</span> + date1.getTime() );</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( date1.getTime() - date.getTime() );</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//重复操作</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span> ; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>setTimeout</code>是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。</p>\n<p>其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以<code>setTimeout</code>只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。</p>\n<p>但是这里仍然有一个疑问，假设<code>setTimeout</code>后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那<code>setTimeout</code>会在紧跟着的第一个函数执行完就插队执行吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hellow world\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - startTime &lt; <span class=\"number\">1000</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"wait\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是并不会，<code>setTimeout</code>只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出<code>hellow world</code>。</p>\n<h2 id=\"JavaScript运行机制\"><a href=\"#JavaScript运行机制\" class=\"headerlink\" title=\"JavaScript运行机制\"></a>JavaScript运行机制</h2><p>我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<p>所以当一段代码有异步操作时，执行过程是这样的：</p>\n<ul>\n<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>\n<li>主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。</li>\n<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。</li>\n<li>主线程不断重复上面的第三步。</li>\n</ul>\n<p>所以，<strong>只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。</strong></p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>\n<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p>\n<p>主线程不断从“任务队列”中读取事件的过程又称为<strong>Event Loop</strong>。</p>\n<h2 id=\"setTimeout与setInterval\"><a href=\"#setTimeout与setInterval\" class=\"headerlink\" title=\"setTimeout与setInterval\"></a>setTimeout与setInterval</h2><h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><p>关于<code>setTimeout</code>在上述已经说的蛮清楚了，还有一点是关于<code>setTimeout(func,0)</code>。<br>当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，<code>setTimeout(func,0)</code>相当于插了队。</p>\n<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3><p><code>setInterval</code>是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他<strong>代码实例</strong>时，才能将定时器代码添加到任务队列中。</p>\n<p>假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时<code>setInterval</code>的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now - startTime &lt; <span class=\"number\">350</span>) &#123;&#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">200</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now() - startTime &lt; <span class=\"number\">300</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png\" alt></p>\n<p>在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。</p>\n<p>所以在使用setInterval做动画时要注意两个问题：</p>\n<ul>\n<li>不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间</li>\n<li>如果主进程运行时间过长，会出现跳帧的现象</li>\n</ul>\n<p>为了避免setInterval的两个缺点，可以使用链式<code>setTimeout()</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;     //其他处理</span><br><span class=\"line\">  setTimeout(arguments.callee, interval); &#125;, interval);</span><br></pre></td></tr></table></figure></p>\n<p>文章参考：<br><a href=\"https://yq.aliyun.com/wenji/1646\" target=\"_blank\" rel=\"noopener\">Javascript定时器学习笔记</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">阮一峰 —— JavaScript 运行机制详解：再谈Event Loop</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"JavaScript单线程\"><a href=\"#JavaScript单线程\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>","more":"<h2 id=\"JavaScript单线程-1\"><a href=\"#JavaScript单线程-1\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>\n<p>这里有个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"comment\">//打印才进入时的时间</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'first time: '</span> + date.getTime());</span><br><span class=\"line\"><span class=\"comment\">//一秒后打印setTimeout里匿名函数的时间</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> date1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'second time: '</span> + date1.getTime() );</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( date1.getTime() - date.getTime() );</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//重复操作</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span> ; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>setTimeout</code>是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。</p>\n<p>其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以<code>setTimeout</code>只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。</p>\n<p>但是这里仍然有一个疑问，假设<code>setTimeout</code>后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那<code>setTimeout</code>会在紧跟着的第一个函数执行完就插队执行吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hellow world\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - startTime &lt; <span class=\"number\">1000</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"wait\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是并不会，<code>setTimeout</code>只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出<code>hellow world</code>。</p>\n<h2 id=\"JavaScript运行机制\"><a href=\"#JavaScript运行机制\" class=\"headerlink\" title=\"JavaScript运行机制\"></a>JavaScript运行机制</h2><p>我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<p>所以当一段代码有异步操作时，执行过程是这样的：</p>\n<ul>\n<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>\n<li>主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。</li>\n<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。</li>\n<li>主线程不断重复上面的第三步。</li>\n</ul>\n<p>所以，<strong>只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。</strong></p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>\n<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p>\n<p>主线程不断从“任务队列”中读取事件的过程又称为<strong>Event Loop</strong>。</p>\n<h2 id=\"setTimeout与setInterval\"><a href=\"#setTimeout与setInterval\" class=\"headerlink\" title=\"setTimeout与setInterval\"></a>setTimeout与setInterval</h2><h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><p>关于<code>setTimeout</code>在上述已经说的蛮清楚了，还有一点是关于<code>setTimeout(func,0)</code>。<br>当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，<code>setTimeout(func,0)</code>相当于插了队。</p>\n<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3><p><code>setInterval</code>是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他<strong>代码实例</strong>时，才能将定时器代码添加到任务队列中。</p>\n<p>假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时<code>setInterval</code>的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now - startTime &lt; <span class=\"number\">350</span>) &#123;&#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">200</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now() - startTime &lt; <span class=\"number\">300</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png\" alt></p>\n<p>在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。</p>\n<p>所以在使用setInterval做动画时要注意两个问题：</p>\n<ul>\n<li>不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间</li>\n<li>如果主进程运行时间过长，会出现跳帧的现象</li>\n</ul>\n<p>为了避免setInterval的两个缺点，可以使用链式<code>setTimeout()</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;     //其他处理</span><br><span class=\"line\">  setTimeout(arguments.callee, interval); &#125;, interval);</span><br></pre></td></tr></table></figure></p>\n<p>文章参考：<br><a href=\"https://yq.aliyun.com/wenji/1646\" target=\"_blank\" rel=\"noopener\">Javascript定时器学习笔记</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">阮一峰 —— JavaScript 运行机制详解：再谈Event Loop</a></p>"},{"title":"JavaScript正则表达式","date":"2017-04-21T07:22:18.000Z","_content":">正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n<!-- more -->\n\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","source":"_posts/JavaScript正则表达式.md","raw":"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\ncategories: JS相关\ntags: \n  - JavaScript\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n<!-- more -->\n\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","slug":"JavaScript正则表达式","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7u000cfr03b80u8tr0","content":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<h2 id=\"正则表达式的定义-1\"><a href=\"#正则表达式的定义-1\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\0\t匹配null字符(\\u0000)</span><br><span class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</span><br><span class=\"line\">\\t  \t匹配制表符tab(\\u0009)</span><br><span class=\"line\">\\n  \t匹配换行符(\\u000A)</span><br><span class=\"line\">\\v      匹配垂直制表符(\\u000B)</span><br><span class=\"line\">\\f\t匹配换页符(\\u000C)</span><br><span class=\"line\">\\r\t匹配回车键(\\u000D)</span><br><span class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</span><br><span class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</span><br><span class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]   匹配方括号内的任意字符</span><br><span class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</span><br><span class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</span><br><span class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</span><br><span class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</span><br><span class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</span><br><span class=\"line\">\\s \t任何Unicode空白符</span><br><span class=\"line\">\\S\t任何非Unicode空白符的字符</span><br><span class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</span><br><span class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</span><br></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</span><br><span class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</span><br><span class=\"line\">&#123;n&#125; \t匹配前一项n次</span><br><span class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</span><br><span class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</span><br><span class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</span><br><span class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</span><br><span class=\"line\">(...) \t把单独的项组合成子表达式</span><br><span class=\"line\">\\n\t引用第n个带括号的子表达式</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></span><br><span class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</span><br><span class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</span><br><span class=\"line\">\\b \t匹配一个单词的边界</span><br><span class=\"line\">\\B \t匹配非单词边界的位置</span><br><span class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</span><br><span class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</span><br></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i \t执行不区分大小写的匹配</span><br><span class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</span><br><span class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</span><br><span class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第二个参数：</span><br><span class=\"line\">$`\t指代匹配结果前面的文本</span><br><span class=\"line\">$&apos;\t指代匹配结果后面的文本</span><br><span class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</span><br><span class=\"line\">$$ \t指代美元符号$</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></span><br></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>","more":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<h2 id=\"正则表达式的定义-1\"><a href=\"#正则表达式的定义-1\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\0\t匹配null字符(\\u0000)</span><br><span class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</span><br><span class=\"line\">\\t  \t匹配制表符tab(\\u0009)</span><br><span class=\"line\">\\n  \t匹配换行符(\\u000A)</span><br><span class=\"line\">\\v      匹配垂直制表符(\\u000B)</span><br><span class=\"line\">\\f\t匹配换页符(\\u000C)</span><br><span class=\"line\">\\r\t匹配回车键(\\u000D)</span><br><span class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</span><br><span class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</span><br><span class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]   匹配方括号内的任意字符</span><br><span class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</span><br><span class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</span><br><span class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</span><br><span class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</span><br><span class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</span><br><span class=\"line\">\\s \t任何Unicode空白符</span><br><span class=\"line\">\\S\t任何非Unicode空白符的字符</span><br><span class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</span><br><span class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</span><br></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</span><br><span class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</span><br><span class=\"line\">&#123;n&#125; \t匹配前一项n次</span><br><span class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</span><br><span class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</span><br><span class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</span><br><span class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</span><br><span class=\"line\">(...) \t把单独的项组合成子表达式</span><br><span class=\"line\">\\n\t引用第n个带括号的子表达式</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></span><br><span class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</span><br><span class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</span><br><span class=\"line\">\\b \t匹配一个单词的边界</span><br><span class=\"line\">\\B \t匹配非单词边界的位置</span><br><span class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</span><br><span class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</span><br></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i \t执行不区分大小写的匹配</span><br><span class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</span><br><span class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</span><br><span class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第二个参数：</span><br><span class=\"line\">$`\t指代匹配结果前面的文本</span><br><span class=\"line\">$&apos;\t指代匹配结果后面的文本</span><br><span class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</span><br><span class=\"line\">$$ \t指代美元符号$</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></span><br></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>"},{"title":"Promise详解","date":"2019-12-03T09:23:22.000Z","_content":"","source":"_posts/Promise详解.md","raw":"---\ntitle: Promise详解\ndate: 2019-12-03 17:23:22\ntags:\n---\n","slug":"Promise详解","published":1,"updated":"2020-01-08T14:07:11.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7v000dfr03pz6xx33j","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"TypeScript学习笔记（基础）","date":"2019-05-26T06:35:02.000Z","_content":"\n## TS 是什么\n\n> TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。\n\n<!-- more -->\n\n## TS 是什么\n\n> TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。\n\n▼ **TS与JS相比，有什么优势**\n* TS 与 JS 对比，最主要是增加了静态类型，这样就能在调试的时候做到类型检查，越界检查，在构建的时候就可以发现问题，可以减少潜在的BUG\n* 提供了类、模块和接口，更有利于构建组件\n\n对比TS，其实ES6也已经对JS做了一些类、模块之类的改进，那么为什么还要学习TS呢？其实由TS的名字就可以感受到，它的重点：`Type`，JS本身与大部分其他语言的不同之处就在于弱类型，声明一个变量，它就可以是任何类型，这就给代码的管理上造成了隐患。强类型的本意就在于用规则约束自己的代码，有了这些规则，自然而然的就能够避免一些低级的BUG。当然，BUG是永远不可能消失滴。\n\nTS能够更好的帮助管理大型工程，也可以减少代码中一堆isxxx的类型判断。并且TS提供了定义对象类型的接口（Interfaces），对于开发，我们只需要在接口处标明类型，其它的内部过程交由 ts 推理就好，这也减少了许多额外的工作。\n\n## TS 中的类型\n\n### 基础类型\n\n```ts\nlet isDone: boolean = false // 布尔值\nlet num: number = 100 // 数值\nlet str: string = 'Hello' // 字符串（支持模板字符串${}）\n\nfunction alertName(): void { // 空值，表示没有任何返回值的函数\n  alert('My name is Tom') // 变量声明为void并没有什么用，因为只能是null 或 undefined\n}\n\nlet u: undefined = undefined // undefined\nlet n: null = null // null\n// 与 void 区别在与其他类型可以赋值为 undefined 或 null 而不报错，但是不能赋值为 void\n\nlet anyThing: any = 'hello' // 任意值\n// 在任意值上访问任何属性都是允许的\nconsole.log(anyThing.myName)\nconsole.log(anyThing.myName.firstName)\n// 也允许调用任何方法\nanyThing.setName('Jerry')\nanyThing.setName('Jerry').sayHello()\nanyThing.myName.setFirstName('Cat')\n// 对它的任何操作，返回的内容的类型都是任意值\n```\n\n### 联合类型\n\n```ts\n// 声明一个变量时，可以指定它为多种类型\n//因为不确定是哪种类型，只能访问联合类型共有的属性和方法\nlet myFavoriteNumber: string | number\nmyFavoriteNumber = 'seven'\nmyFavoriteNumber =  7\n```\n\n### 数组与函数\n\n```ts\n// 定义后数组内只能存在这种类型的值\nlet fibonacci: number[] = [1,  1,  2,  3,  5]\n\n// 限定输入类型和输出类型，及参数的个数\nfunction sum (x: number, y: number): number {\n  return x + y\n}\nsum(1, 2)\n```\n\n## TS 中的接口\n\n```ts\n// 用于定义对象的类型\n// 定义好后，指定的变量多一个类型或少一个类型都不可以\ninterface Person = {\n  name: string,\n  age: number\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25\n}\n\n// 用可选类型和任意属性来灵活拓展，只读属性来设定不可修改\ninterface Person {\n  readonly id: number\n  name: string\n  age?: number\n  [propName: string]: any\n}\n\nlet tom: Person = {\n  id: 89757, // 创建时赋值后便不可修改\n  name: 'Tom',\n  gender: 'male'\n}\n\n// 定义数组接口和函数接口\ninterface Eg {\n  [index: number]: number, // 数组类型\n  (x: number, y: number): number// 函数类型\n}\n```\n\n## TS 中的类\n\n### ES6 的类\n```ts\nclass Human{\n  constructor (name) {\n    this.name = name\n  }\n  sayHi () {\n    return `My name is ${this.name}`\n  }\n  get name () { // 存取器\n    return 'Jack'\n  }\n  set name (value) {\n    console.log('setter:' + value)\n  }\n  static isHuman (a) { // 静态方法\n    return a instanceof Human\n  }\n}\n\nlet a = new Human('Tom')\na.sayHi() // My name is Tome\nHuman.isHuman(a) // true\n\n// 继承\nclass Chinese extend Human {\n  constructor (name) {\n    super(name) // 调用父类的 constructor(name)\n  }\n  sayHi()  {\n    return 'China,' + super.sayHi() // 调用父类的 sayHi()\n  }\n}\n```\n\n### ES7 的类\n```ts\n// 支持在构造函数外定义变量\nclass Human{\n  name: 'Tom'\n  constructor () {\n    // ...\n  }\n}\n\n// 支持定义静态变量\nclass Human{\n  static name = 'Tom'\n  constructor () {\n    // ...\n  }\n}\n\nHuman.name // Tom\n```\n\n### TS 的类\n* 支持ES6、ES7的类定义\n* 增加三种修饰符`public`、`private`、`protected`，对，和当年学 C++ 一模一样\n* 支持抽象类（过于抽象，还不知道如何使用）\n* 支持定义类型（和接口类似）\n\n```ts\nclass Human{\n  public name: string\n  public constructor (name: string) {\n    this.name = name\n  }\n  private sayHi (): string {\n    return `My name is ${this.name}`\n  }\n}\n```\n","source":"_posts/TypeScript学习笔记（基础）.md","raw":"---\ntitle: TypeScript学习笔记（基础）\ndate: 2019-05-26 14:35:02\ncategories: TS相关\ntags:\n  - TypeScript\n---\n\n## TS 是什么\n\n> TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。\n\n<!-- more -->\n\n## TS 是什么\n\n> TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。\n\n▼ **TS与JS相比，有什么优势**\n* TS 与 JS 对比，最主要是增加了静态类型，这样就能在调试的时候做到类型检查，越界检查，在构建的时候就可以发现问题，可以减少潜在的BUG\n* 提供了类、模块和接口，更有利于构建组件\n\n对比TS，其实ES6也已经对JS做了一些类、模块之类的改进，那么为什么还要学习TS呢？其实由TS的名字就可以感受到，它的重点：`Type`，JS本身与大部分其他语言的不同之处就在于弱类型，声明一个变量，它就可以是任何类型，这就给代码的管理上造成了隐患。强类型的本意就在于用规则约束自己的代码，有了这些规则，自然而然的就能够避免一些低级的BUG。当然，BUG是永远不可能消失滴。\n\nTS能够更好的帮助管理大型工程，也可以减少代码中一堆isxxx的类型判断。并且TS提供了定义对象类型的接口（Interfaces），对于开发，我们只需要在接口处标明类型，其它的内部过程交由 ts 推理就好，这也减少了许多额外的工作。\n\n## TS 中的类型\n\n### 基础类型\n\n```ts\nlet isDone: boolean = false // 布尔值\nlet num: number = 100 // 数值\nlet str: string = 'Hello' // 字符串（支持模板字符串${}）\n\nfunction alertName(): void { // 空值，表示没有任何返回值的函数\n  alert('My name is Tom') // 变量声明为void并没有什么用，因为只能是null 或 undefined\n}\n\nlet u: undefined = undefined // undefined\nlet n: null = null // null\n// 与 void 区别在与其他类型可以赋值为 undefined 或 null 而不报错，但是不能赋值为 void\n\nlet anyThing: any = 'hello' // 任意值\n// 在任意值上访问任何属性都是允许的\nconsole.log(anyThing.myName)\nconsole.log(anyThing.myName.firstName)\n// 也允许调用任何方法\nanyThing.setName('Jerry')\nanyThing.setName('Jerry').sayHello()\nanyThing.myName.setFirstName('Cat')\n// 对它的任何操作，返回的内容的类型都是任意值\n```\n\n### 联合类型\n\n```ts\n// 声明一个变量时，可以指定它为多种类型\n//因为不确定是哪种类型，只能访问联合类型共有的属性和方法\nlet myFavoriteNumber: string | number\nmyFavoriteNumber = 'seven'\nmyFavoriteNumber =  7\n```\n\n### 数组与函数\n\n```ts\n// 定义后数组内只能存在这种类型的值\nlet fibonacci: number[] = [1,  1,  2,  3,  5]\n\n// 限定输入类型和输出类型，及参数的个数\nfunction sum (x: number, y: number): number {\n  return x + y\n}\nsum(1, 2)\n```\n\n## TS 中的接口\n\n```ts\n// 用于定义对象的类型\n// 定义好后，指定的变量多一个类型或少一个类型都不可以\ninterface Person = {\n  name: string,\n  age: number\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25\n}\n\n// 用可选类型和任意属性来灵活拓展，只读属性来设定不可修改\ninterface Person {\n  readonly id: number\n  name: string\n  age?: number\n  [propName: string]: any\n}\n\nlet tom: Person = {\n  id: 89757, // 创建时赋值后便不可修改\n  name: 'Tom',\n  gender: 'male'\n}\n\n// 定义数组接口和函数接口\ninterface Eg {\n  [index: number]: number, // 数组类型\n  (x: number, y: number): number// 函数类型\n}\n```\n\n## TS 中的类\n\n### ES6 的类\n```ts\nclass Human{\n  constructor (name) {\n    this.name = name\n  }\n  sayHi () {\n    return `My name is ${this.name}`\n  }\n  get name () { // 存取器\n    return 'Jack'\n  }\n  set name (value) {\n    console.log('setter:' + value)\n  }\n  static isHuman (a) { // 静态方法\n    return a instanceof Human\n  }\n}\n\nlet a = new Human('Tom')\na.sayHi() // My name is Tome\nHuman.isHuman(a) // true\n\n// 继承\nclass Chinese extend Human {\n  constructor (name) {\n    super(name) // 调用父类的 constructor(name)\n  }\n  sayHi()  {\n    return 'China,' + super.sayHi() // 调用父类的 sayHi()\n  }\n}\n```\n\n### ES7 的类\n```ts\n// 支持在构造函数外定义变量\nclass Human{\n  name: 'Tom'\n  constructor () {\n    // ...\n  }\n}\n\n// 支持定义静态变量\nclass Human{\n  static name = 'Tom'\n  constructor () {\n    // ...\n  }\n}\n\nHuman.name // Tom\n```\n\n### TS 的类\n* 支持ES6、ES7的类定义\n* 增加三种修饰符`public`、`private`、`protected`，对，和当年学 C++ 一模一样\n* 支持抽象类（过于抽象，还不知道如何使用）\n* 支持定义类型（和接口类似）\n\n```ts\nclass Human{\n  public name: string\n  public constructor (name: string) {\n    this.name = name\n  }\n  private sayHi (): string {\n    return `My name is ${this.name}`\n  }\n}\n```\n","slug":"TypeScript学习笔记（基础）","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7w000efr03s8jr80dr","content":"<h2 id=\"TS-是什么\"><a href=\"#TS-是什么\" class=\"headerlink\" title=\"TS 是什么\"></a>TS 是什么</h2><blockquote>\n<p>TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"TS-是什么-1\"><a href=\"#TS-是什么-1\" class=\"headerlink\" title=\"TS 是什么\"></a>TS 是什么</h2><blockquote>\n<p>TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。</p>\n</blockquote>\n<p>▼ <strong>TS与JS相比，有什么优势</strong></p>\n<ul>\n<li>TS 与 JS 对比，最主要是增加了静态类型，这样就能在调试的时候做到类型检查，越界检查，在构建的时候就可以发现问题，可以减少潜在的BUG</li>\n<li>提供了类、模块和接口，更有利于构建组件</li>\n</ul>\n<p>对比TS，其实ES6也已经对JS做了一些类、模块之类的改进，那么为什么还要学习TS呢？其实由TS的名字就可以感受到，它的重点：<code>Type</code>，JS本身与大部分其他语言的不同之处就在于弱类型，声明一个变量，它就可以是任何类型，这就给代码的管理上造成了隐患。强类型的本意就在于用规则约束自己的代码，有了这些规则，自然而然的就能够避免一些低级的BUG。当然，BUG是永远不可能消失滴。</p>\n<p>TS能够更好的帮助管理大型工程，也可以减少代码中一堆isxxx的类型判断。并且TS提供了定义对象类型的接口（Interfaces），对于开发，我们只需要在接口处标明类型，其它的内部过程交由 ts 推理就好，这也减少了许多额外的工作。</p>\n<h2 id=\"TS-中的类型\"><a href=\"#TS-中的类型\" class=\"headerlink\" title=\"TS 中的类型\"></a>TS 中的类型</h2><h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span> <span class=\"comment\">// 布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">100</span> <span class=\"comment\">// 数值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello'</span> <span class=\"comment\">// 字符串（支持模板字符串$&#123;&#125;）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">alertName</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123; <span class=\"comment\">// 空值，表示没有任何返回值的函数</span></span><br><span class=\"line\">  alert(<span class=\"string\">'My name is Tom'</span>) <span class=\"comment\">// 变量声明为void并没有什么用，因为只能是null 或 undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span> <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"comment\">// 与 void 区别在与其他类型可以赋值为 undefined 或 null 而不报错，但是不能赋值为 void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> anyThing: <span class=\"built_in\">any</span> = <span class=\"string\">'hello'</span> <span class=\"comment\">// 任意值</span></span><br><span class=\"line\"><span class=\"comment\">// 在任意值上访问任何属性都是允许的</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(anyThing.myName)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(anyThing.myName.firstName)</span><br><span class=\"line\"><span class=\"comment\">// 也允许调用任何方法</span></span><br><span class=\"line\">anyThing.setName(<span class=\"string\">'Jerry'</span>)</span><br><span class=\"line\">anyThing.setName(<span class=\"string\">'Jerry'</span>).sayHello()</span><br><span class=\"line\">anyThing.myName.setFirstName(<span class=\"string\">'Cat'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 对它的任何操作，返回的内容的类型都是任意值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个变量时，可以指定它为多种类型</span></span><br><span class=\"line\"><span class=\"comment\">//因为不确定是哪种类型，只能访问联合类型共有的属性和方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myFavoriteNumber: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span><br><span class=\"line\">myFavoriteNumber = <span class=\"string\">'seven'</span></span><br><span class=\"line\">myFavoriteNumber =  <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组与函数\"><a href=\"#数组与函数\" class=\"headerlink\" title=\"数组与函数\"></a>数组与函数</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义后数组内只能存在这种类型的值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fibonacci: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>,  <span class=\"number\">3</span>,  <span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 限定输入类型和输出类型，及参数的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"TS-中的接口\"><a href=\"#TS-中的接口\" class=\"headerlink\" title=\"TS 中的接口\"></a>TS 中的接口</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于定义对象的类型</span></span><br><span class=\"line\"><span class=\"comment\">// 定义好后，指定的变量多一个类型或少一个类型都不可以</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person = &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用可选类型和任意属性来灵活拓展，只读属性来设定不可修改</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  readonly id: <span class=\"built_in\">number</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  age?: <span class=\"built_in\">number</span></span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Person = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">89757</span>, <span class=\"comment\">// 创建时赋值后便不可修改</span></span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  gender: <span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义数组接口和函数接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Eg &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">number</span>, <span class=\"comment\">// 数组类型</span></span><br><span class=\"line\">  (x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span><span class=\"comment\">// 函数类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"TS-中的类\"><a href=\"#TS-中的类\" class=\"headerlink\" title=\"TS 中的类\"></a>TS 中的类</h2><h3 id=\"ES6-的类\"><a href=\"#ES6-的类\" class=\"headerlink\" title=\"ES6 的类\"></a>ES6 的类</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`My name is <span class=\"subst\">$&#123;this.name&#125;</span>`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> name () &#123; <span class=\"comment\">// 存取器</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Jack'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> name (value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter:'</span> + value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> isHuman (a) &#123; <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a <span class=\"keyword\">instanceof</span> Human</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Human(<span class=\"string\">'Tom'</span>)</span><br><span class=\"line\">a.sayHi() <span class=\"comment\">// My name is Tome</span></span><br><span class=\"line\">Human.isHuman(a) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Chinese extend Human &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name) <span class=\"comment\">// 调用父类的 constructor(name)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi()  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'China,'</span> + <span class=\"keyword\">super</span>.sayHi() <span class=\"comment\">// 调用父类的 sayHi()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES7-的类\"><a href=\"#ES7-的类\" class=\"headerlink\" title=\"ES7 的类\"></a>ES7 的类</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 支持在构造函数外定义变量</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持定义静态变量</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> name = <span class=\"string\">'Tom'</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Human.name <span class=\"comment\">// Tom</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TS-的类\"><a href=\"#TS-的类\" class=\"headerlink\" title=\"TS 的类\"></a>TS 的类</h3><ul>\n<li>支持ES6、ES7的类定义</li>\n<li>增加三种修饰符<code>public</code>、<code>private</code>、<code>protected</code>，对，和当年学 C++ 一模一样</li>\n<li>支持抽象类（过于抽象，还不知道如何使用）</li>\n<li>支持定义类型（和接口类似）</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span> (<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> sayHi (): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`My name is <span class=\"subst\">$&#123;this.name&#125;</span>`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"TS-是什么\"><a href=\"#TS-是什么\" class=\"headerlink\" title=\"TS 是什么\"></a>TS 是什么</h2><blockquote>\n<p>TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。</p>\n</blockquote>","more":"<h2 id=\"TS-是什么-1\"><a href=\"#TS-是什么-1\" class=\"headerlink\" title=\"TS 是什么\"></a>TS 是什么</h2><blockquote>\n<p>TS是一个应用程序级的JavaScript开发语言，是JavaScript的超集，可以编译成纯JavaScript，并遵循JavaScript的语法和语义。</p>\n</blockquote>\n<p>▼ <strong>TS与JS相比，有什么优势</strong></p>\n<ul>\n<li>TS 与 JS 对比，最主要是增加了静态类型，这样就能在调试的时候做到类型检查，越界检查，在构建的时候就可以发现问题，可以减少潜在的BUG</li>\n<li>提供了类、模块和接口，更有利于构建组件</li>\n</ul>\n<p>对比TS，其实ES6也已经对JS做了一些类、模块之类的改进，那么为什么还要学习TS呢？其实由TS的名字就可以感受到，它的重点：<code>Type</code>，JS本身与大部分其他语言的不同之处就在于弱类型，声明一个变量，它就可以是任何类型，这就给代码的管理上造成了隐患。强类型的本意就在于用规则约束自己的代码，有了这些规则，自然而然的就能够避免一些低级的BUG。当然，BUG是永远不可能消失滴。</p>\n<p>TS能够更好的帮助管理大型工程，也可以减少代码中一堆isxxx的类型判断。并且TS提供了定义对象类型的接口（Interfaces），对于开发，我们只需要在接口处标明类型，其它的内部过程交由 ts 推理就好，这也减少了许多额外的工作。</p>\n<h2 id=\"TS-中的类型\"><a href=\"#TS-中的类型\" class=\"headerlink\" title=\"TS 中的类型\"></a>TS 中的类型</h2><h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span> <span class=\"comment\">// 布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">100</span> <span class=\"comment\">// 数值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello'</span> <span class=\"comment\">// 字符串（支持模板字符串$&#123;&#125;）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">alertName</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123; <span class=\"comment\">// 空值，表示没有任何返回值的函数</span></span><br><span class=\"line\">  alert(<span class=\"string\">'My name is Tom'</span>) <span class=\"comment\">// 变量声明为void并没有什么用，因为只能是null 或 undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span> <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"comment\">// 与 void 区别在与其他类型可以赋值为 undefined 或 null 而不报错，但是不能赋值为 void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> anyThing: <span class=\"built_in\">any</span> = <span class=\"string\">'hello'</span> <span class=\"comment\">// 任意值</span></span><br><span class=\"line\"><span class=\"comment\">// 在任意值上访问任何属性都是允许的</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(anyThing.myName)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(anyThing.myName.firstName)</span><br><span class=\"line\"><span class=\"comment\">// 也允许调用任何方法</span></span><br><span class=\"line\">anyThing.setName(<span class=\"string\">'Jerry'</span>)</span><br><span class=\"line\">anyThing.setName(<span class=\"string\">'Jerry'</span>).sayHello()</span><br><span class=\"line\">anyThing.myName.setFirstName(<span class=\"string\">'Cat'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 对它的任何操作，返回的内容的类型都是任意值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个变量时，可以指定它为多种类型</span></span><br><span class=\"line\"><span class=\"comment\">//因为不确定是哪种类型，只能访问联合类型共有的属性和方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myFavoriteNumber: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span><br><span class=\"line\">myFavoriteNumber = <span class=\"string\">'seven'</span></span><br><span class=\"line\">myFavoriteNumber =  <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组与函数\"><a href=\"#数组与函数\" class=\"headerlink\" title=\"数组与函数\"></a>数组与函数</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义后数组内只能存在这种类型的值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fibonacci: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>,  <span class=\"number\">3</span>,  <span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 限定输入类型和输出类型，及参数的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"TS-中的接口\"><a href=\"#TS-中的接口\" class=\"headerlink\" title=\"TS 中的接口\"></a>TS 中的接口</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于定义对象的类型</span></span><br><span class=\"line\"><span class=\"comment\">// 定义好后，指定的变量多一个类型或少一个类型都不可以</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person = &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用可选类型和任意属性来灵活拓展，只读属性来设定不可修改</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  readonly id: <span class=\"built_in\">number</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  age?: <span class=\"built_in\">number</span></span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Person = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">89757</span>, <span class=\"comment\">// 创建时赋值后便不可修改</span></span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  gender: <span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义数组接口和函数接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Eg &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">number</span>, <span class=\"comment\">// 数组类型</span></span><br><span class=\"line\">  (x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span><span class=\"comment\">// 函数类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"TS-中的类\"><a href=\"#TS-中的类\" class=\"headerlink\" title=\"TS 中的类\"></a>TS 中的类</h2><h3 id=\"ES6-的类\"><a href=\"#ES6-的类\" class=\"headerlink\" title=\"ES6 的类\"></a>ES6 的类</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`My name is <span class=\"subst\">$&#123;this.name&#125;</span>`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> name () &#123; <span class=\"comment\">// 存取器</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Jack'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> name (value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter:'</span> + value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> isHuman (a) &#123; <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a <span class=\"keyword\">instanceof</span> Human</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Human(<span class=\"string\">'Tom'</span>)</span><br><span class=\"line\">a.sayHi() <span class=\"comment\">// My name is Tome</span></span><br><span class=\"line\">Human.isHuman(a) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Chinese extend Human &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name) <span class=\"comment\">// 调用父类的 constructor(name)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi()  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'China,'</span> + <span class=\"keyword\">super</span>.sayHi() <span class=\"comment\">// 调用父类的 sayHi()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES7-的类\"><a href=\"#ES7-的类\" class=\"headerlink\" title=\"ES7 的类\"></a>ES7 的类</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 支持在构造函数外定义变量</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持定义静态变量</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> name = <span class=\"string\">'Tom'</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Human.name <span class=\"comment\">// Tom</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TS-的类\"><a href=\"#TS-的类\" class=\"headerlink\" title=\"TS 的类\"></a>TS 的类</h3><ul>\n<li>支持ES6、ES7的类定义</li>\n<li>增加三种修饰符<code>public</code>、<code>private</code>、<code>protected</code>，对，和当年学 C++ 一模一样</li>\n<li>支持抽象类（过于抽象，还不知道如何使用）</li>\n<li>支持定义类型（和接口类似）</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Human&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span> (<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> sayHi (): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`My name is <span class=\"subst\">$&#123;this.name&#125;</span>`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Vue.js学习笔记（01）","date":"2017-10-19T13:25:58.000Z","_content":"> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。\n\n▼ **什么是MVVM：**\nMVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。\n\n<!-- more -->\n\n> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。\n\n▼ **什么是MVVM：**\nMVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。\n* **Model**\n代表我们整个webapp所需要的数据模型，一个典型的例子就是用户信息Model,它应该含有(姓名，年龄等属性)。Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。\n* **View**\nView这个词出现频率最多的地方应该是MVC。在MVC设计中，View是唯一与用户交互的地方，或者说它是Model变化后的直观反映。在MVVM中，View被认为是主动的而非被动的。一个被动的View时只它只能任由“他人”（Controller）摆布，自己却不能改变任何东西，如利用Jquery操作DOM。而MVVM中View是具有主动性的，因为它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自己身的行为（展示），而还会将自身的变化同步到ViewModel中。\n* **ViewModel**\nViewModel可以被看作是MVC中的Controller,它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。\n\n## MVC 和 MVVM 的比较\n\n刚发现了一篇关于几个模型的博文[从Script到Code Blocks、Code Behind到MVC、MVP、MVVM](http://www.cnblogs.com/indream/p/3602348.html)\n在这里，简单的对这两个比较常见的设计模型进行一些比较：\n\n### MVC结构图\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvc.png)\n\n### MVVM结构图\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvvm.png)\n\n### MVC的优点\n\n由于前端的发展，出现了多页应用和Web App这种东西，使得前端不仅仅做的是简单的数据展示了。使用MVC，有下列一些优点：\n* 简化代码\n* 减少重复\n* 集中精神编写业务逻辑\n* 易于扩充\n* 数据触发事件\n* 面向数据编程\n\n### MVC缺点\n\nMVC虽然将需求和UI的相关工作分化成了三份，但是由于它们三者的三角关系使得维护很成问题。**在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。**\n\nMVVM与MVC最大的区别在于，MVVM切断了View层和Model层的联系，让View层只和ViewModel层交互，而ViewModel再和Model层交互。在MVVM中，**View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。**\n\n随着HTML5的发展，Web App的应用越来越广泛，甚至能媲美Nativ eApp（大部分安卓或IOS应用），但随之也暴露出了三个痛点问题：\n* 开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。\n* 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n* 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。\n\n### MVVM优点\n\n在MVVM中，ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，这就完美的解决了以上的问题。\n\n## Vue.js的MVVM应用\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/vuejs.png)\n\n* **Observer**：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现；\n* **Compile**：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数；\n* **Watcher**：订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数；\n* **Dep**：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法\n\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`：放在项目根目录下，是项目的入口\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- app为一个组件，默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`：注册组件app\n```javascript\n//import表示导入组件，ES6语法\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n```\n\n`src/App.vue`：组件的主要代码，包括`template`、`script`、`style`\n```html\n<template>\n  <div id=\"app\">\n    <img src=\"./assets/logo.png\">\n    <router-view/>\n    <!-- 渲染路径匹配到的视图组件，方便渲染你指定路由对应的组件 -->\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app'\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\n`router/index.js`： 创建路由并配置路由映射 ，并通过export输出router到main.js文件中\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld' \n// 在这里引入另一个名为HelloWorld的组件\n// 即components目录下的HelloWorld.vue\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: HelloWorld\n    }\n  ]\n})\n```","source":"_posts/Vue.js学习笔记（01）.md","raw":"---\ntitle: Vue.js学习笔记（01）\ndate: 2017-10-19 21:25:58\ncategories: Vue相关\ntags: \n  - Vue\n  - MVC\n  - MVVM\n---\n> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。\n\n▼ **什么是MVVM：**\nMVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。\n\n<!-- more -->\n\n> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。\n\n▼ **什么是MVVM：**\nMVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。\n* **Model**\n代表我们整个webapp所需要的数据模型，一个典型的例子就是用户信息Model,它应该含有(姓名，年龄等属性)。Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。\n* **View**\nView这个词出现频率最多的地方应该是MVC。在MVC设计中，View是唯一与用户交互的地方，或者说它是Model变化后的直观反映。在MVVM中，View被认为是主动的而非被动的。一个被动的View时只它只能任由“他人”（Controller）摆布，自己却不能改变任何东西，如利用Jquery操作DOM。而MVVM中View是具有主动性的，因为它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自己身的行为（展示），而还会将自身的变化同步到ViewModel中。\n* **ViewModel**\nViewModel可以被看作是MVC中的Controller,它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。\n\n## MVC 和 MVVM 的比较\n\n刚发现了一篇关于几个模型的博文[从Script到Code Blocks、Code Behind到MVC、MVP、MVVM](http://www.cnblogs.com/indream/p/3602348.html)\n在这里，简单的对这两个比较常见的设计模型进行一些比较：\n\n### MVC结构图\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvc.png)\n\n### MVVM结构图\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvvm.png)\n\n### MVC的优点\n\n由于前端的发展，出现了多页应用和Web App这种东西，使得前端不仅仅做的是简单的数据展示了。使用MVC，有下列一些优点：\n* 简化代码\n* 减少重复\n* 集中精神编写业务逻辑\n* 易于扩充\n* 数据触发事件\n* 面向数据编程\n\n### MVC缺点\n\nMVC虽然将需求和UI的相关工作分化成了三份，但是由于它们三者的三角关系使得维护很成问题。**在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。**\n\nMVVM与MVC最大的区别在于，MVVM切断了View层和Model层的联系，让View层只和ViewModel层交互，而ViewModel再和Model层交互。在MVVM中，**View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。**\n\n随着HTML5的发展，Web App的应用越来越广泛，甚至能媲美Nativ eApp（大部分安卓或IOS应用），但随之也暴露出了三个痛点问题：\n* 开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。\n* 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n* 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。\n\n### MVVM优点\n\n在MVVM中，ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，这就完美的解决了以上的问题。\n\n## Vue.js的MVVM应用\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/vuejs.png)\n\n* **Observer**：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现；\n* **Compile**：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数；\n* **Watcher**：订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数；\n* **Dep**：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法\n\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`：放在项目根目录下，是项目的入口\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- app为一个组件，默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`：注册组件app\n```javascript\n//import表示导入组件，ES6语法\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n```\n\n`src/App.vue`：组件的主要代码，包括`template`、`script`、`style`\n```html\n<template>\n  <div id=\"app\">\n    <img src=\"./assets/logo.png\">\n    <router-view/>\n    <!-- 渲染路径匹配到的视图组件，方便渲染你指定路由对应的组件 -->\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app'\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\n`router/index.js`： 创建路由并配置路由映射 ，并通过export输出router到main.js文件中\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld' \n// 在这里引入另一个名为HelloWorld的组件\n// 即components目录下的HelloWorld.vue\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: HelloWorld\n    }\n  ]\n})\n```","slug":"Vue.js学习笔记（01）","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7w000ffr03hrxw8hb2","content":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。</p>\n</blockquote>\n<p>▼ <strong>什么是MVVM：</strong><br>MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。</p>\n</blockquote>\n<p>▼ <strong>什么是MVVM：</strong><br>MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。</p>\n<ul>\n<li><strong>Model</strong><br>代表我们整个webapp所需要的数据模型，一个典型的例子就是用户信息Model,它应该含有(姓名，年龄等属性)。Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。</li>\n<li><strong>View</strong><br>View这个词出现频率最多的地方应该是MVC。在MVC设计中，View是唯一与用户交互的地方，或者说它是Model变化后的直观反映。在MVVM中，View被认为是主动的而非被动的。一个被动的View时只它只能任由“他人”（Controller）摆布，自己却不能改变任何东西，如利用Jquery操作DOM。而MVVM中View是具有主动性的，因为它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自己身的行为（展示），而还会将自身的变化同步到ViewModel中。</li>\n<li><strong>ViewModel</strong><br>ViewModel可以被看作是MVC中的Controller,它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。</li>\n</ul>\n<h2 id=\"MVC-和-MVVM-的比较\"><a href=\"#MVC-和-MVVM-的比较\" class=\"headerlink\" title=\"MVC 和 MVVM 的比较\"></a>MVC 和 MVVM 的比较</h2><p>刚发现了一篇关于几个模型的博文<a href=\"http://www.cnblogs.com/indream/p/3602348.html\" target=\"_blank\" rel=\"noopener\">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a><br>在这里，简单的对这两个比较常见的设计模型进行一些比较：</p>\n<h3 id=\"MVC结构图\"><a href=\"#MVC结构图\" class=\"headerlink\" title=\"MVC结构图\"></a>MVC结构图</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvc.png\" alt></p>\n<h3 id=\"MVVM结构图\"><a href=\"#MVVM结构图\" class=\"headerlink\" title=\"MVVM结构图\"></a>MVVM结构图</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvvm.png\" alt></p>\n<h3 id=\"MVC的优点\"><a href=\"#MVC的优点\" class=\"headerlink\" title=\"MVC的优点\"></a>MVC的优点</h3><p>由于前端的发展，出现了多页应用和Web App这种东西，使得前端不仅仅做的是简单的数据展示了。使用MVC，有下列一些优点：</p>\n<ul>\n<li>简化代码</li>\n<li>减少重复</li>\n<li>集中精神编写业务逻辑</li>\n<li>易于扩充</li>\n<li>数据触发事件</li>\n<li>面向数据编程</li>\n</ul>\n<h3 id=\"MVC缺点\"><a href=\"#MVC缺点\" class=\"headerlink\" title=\"MVC缺点\"></a>MVC缺点</h3><p>MVC虽然将需求和UI的相关工作分化成了三份，但是由于它们三者的三角关系使得维护很成问题。<strong>在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。</strong></p>\n<p>MVVM与MVC最大的区别在于，MVVM切断了View层和Model层的联系，让View层只和ViewModel层交互，而ViewModel再和Model层交互。在MVVM中，<strong>View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。</strong></p>\n<p>随着HTML5的发展，Web App的应用越来越广泛，甚至能媲美Nativ eApp（大部分安卓或IOS应用），但随之也暴露出了三个痛点问题：</p>\n<ul>\n<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>\n<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>\n<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>\n</ul>\n<h3 id=\"MVVM优点\"><a href=\"#MVVM优点\" class=\"headerlink\" title=\"MVVM优点\"></a>MVVM优点</h3><p>在MVVM中，ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，这就完美的解决了以上的问题。</p>\n<h2 id=\"Vue-js的MVVM应用\"><a href=\"#Vue-js的MVVM应用\" class=\"headerlink\" title=\"Vue.js的MVVM应用\"></a>Vue.js的MVVM应用</h2><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/vuejs.png\" alt></p>\n<ul>\n<li><strong>Observer</strong>：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现；</li>\n<li><strong>Compile</strong>：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数；</li>\n<li><strong>Watcher</strong>：订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数；</li>\n<li><strong>Dep</strong>：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li>\n</ul>\n<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装vue-cli</span></span><br><span class=\"line\">$ cnpm install -g vue-cli</span><br><span class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></span><br><span class=\"line\">$ vue init webpack my-project</span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">$ cd my-project</span><br><span class=\"line\">$ cnmp install</span><br><span class=\"line\"><span class=\"comment\"># 开启项目</span></span><br><span class=\"line\">$ npm run dev</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code>：放在项目根目录下，是项目的入口<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- app为一个组件，默认调用src里的main.js --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code>：注册组件app<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//import表示导入组件，ES6语法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable no-new */</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span>,</span><br><span class=\"line\">  components: &#123; App &#125;  <span class=\"comment\">//注册一个app</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>src/App.vue</code>：组件的主要代码，包括<code>template</code>、<code>script</code>、<code>style</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./assets/logo.png\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 渲染路径匹配到的视图组件，方便渲染你指定路由对应的组件 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'app'</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">#app &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class=\"line\"><span class=\"undefined\">  -webkit-font-smoothing: antialiased;</span></span><br><span class=\"line\"><span class=\"undefined\">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class=\"line\"><span class=\"undefined\">  text-align: center;</span></span><br><span class=\"line\"><span class=\"undefined\">  color: #2c3e50;</span></span><br><span class=\"line\"><span class=\"undefined\">  margin-top: 60px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>router/index.js</code>： 创建路由并配置路由映射 ，并通过export输出router到main.js文件中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">'@/components/HelloWorld'</span> </span><br><span class=\"line\"><span class=\"comment\">// 在这里引入另一个名为HelloWorld的组件</span></span><br><span class=\"line\"><span class=\"comment\">// 即components目录下的HelloWorld.vue</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">      component: HelloWorld</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。</p>\n</blockquote>\n<p>▼ <strong>什么是MVVM：</strong><br>MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。</p>","more":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。</p>\n</blockquote>\n<p>▼ <strong>什么是MVVM：</strong><br>MVVM(Model View ViewModel)是一种基于MVC的设计，开发人员在HTML上写一些Bindings,利用一些指令绑定，就能在Model和ViewModel保持不变的情况下，很方便的将UI设计与业务逻辑分离，从而大大的减少繁琐的DOM操作。</p>\n<ul>\n<li><strong>Model</strong><br>代表我们整个webapp所需要的数据模型，一个典型的例子就是用户信息Model,它应该含有(姓名，年龄等属性)。Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。</li>\n<li><strong>View</strong><br>View这个词出现频率最多的地方应该是MVC。在MVC设计中，View是唯一与用户交互的地方，或者说它是Model变化后的直观反映。在MVVM中，View被认为是主动的而非被动的。一个被动的View时只它只能任由“他人”（Controller）摆布，自己却不能改变任何东西，如利用Jquery操作DOM。而MVVM中View是具有主动性的，因为它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自己身的行为（展示），而还会将自身的变化同步到ViewModel中。</li>\n<li><strong>ViewModel</strong><br>ViewModel可以被看作是MVC中的Controller,它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。</li>\n</ul>\n<h2 id=\"MVC-和-MVVM-的比较\"><a href=\"#MVC-和-MVVM-的比较\" class=\"headerlink\" title=\"MVC 和 MVVM 的比较\"></a>MVC 和 MVVM 的比较</h2><p>刚发现了一篇关于几个模型的博文<a href=\"http://www.cnblogs.com/indream/p/3602348.html\" target=\"_blank\" rel=\"noopener\">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a><br>在这里，简单的对这两个比较常见的设计模型进行一些比较：</p>\n<h3 id=\"MVC结构图\"><a href=\"#MVC结构图\" class=\"headerlink\" title=\"MVC结构图\"></a>MVC结构图</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvc.png\" alt></p>\n<h3 id=\"MVVM结构图\"><a href=\"#MVVM结构图\" class=\"headerlink\" title=\"MVVM结构图\"></a>MVVM结构图</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/mvvm.png\" alt></p>\n<h3 id=\"MVC的优点\"><a href=\"#MVC的优点\" class=\"headerlink\" title=\"MVC的优点\"></a>MVC的优点</h3><p>由于前端的发展，出现了多页应用和Web App这种东西，使得前端不仅仅做的是简单的数据展示了。使用MVC，有下列一些优点：</p>\n<ul>\n<li>简化代码</li>\n<li>减少重复</li>\n<li>集中精神编写业务逻辑</li>\n<li>易于扩充</li>\n<li>数据触发事件</li>\n<li>面向数据编程</li>\n</ul>\n<h3 id=\"MVC缺点\"><a href=\"#MVC缺点\" class=\"headerlink\" title=\"MVC缺点\"></a>MVC缺点</h3><p>MVC虽然将需求和UI的相关工作分化成了三份，但是由于它们三者的三角关系使得维护很成问题。<strong>在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。</strong></p>\n<p>MVVM与MVC最大的区别在于，MVVM切断了View层和Model层的联系，让View层只和ViewModel层交互，而ViewModel再和Model层交互。在MVVM中，<strong>View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。</strong></p>\n<p>随着HTML5的发展，Web App的应用越来越广泛，甚至能媲美Nativ eApp（大部分安卓或IOS应用），但随之也暴露出了三个痛点问题：</p>\n<ul>\n<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>\n<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>\n<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>\n</ul>\n<h3 id=\"MVVM优点\"><a href=\"#MVVM优点\" class=\"headerlink\" title=\"MVVM优点\"></a>MVVM优点</h3><p>在MVVM中，ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，这就完美的解决了以上的问题。</p>\n<h2 id=\"Vue-js的MVVM应用\"><a href=\"#Vue-js的MVVM应用\" class=\"headerlink\" title=\"Vue.js的MVVM应用\"></a>Vue.js的MVVM应用</h2><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/vuejs.png\" alt></p>\n<ul>\n<li><strong>Observer</strong>：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现；</li>\n<li><strong>Compile</strong>：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数；</li>\n<li><strong>Watcher</strong>：订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数；</li>\n<li><strong>Dep</strong>：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li>\n</ul>\n<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装vue-cli</span></span><br><span class=\"line\">$ cnpm install -g vue-cli</span><br><span class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></span><br><span class=\"line\">$ vue init webpack my-project</span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">$ cd my-project</span><br><span class=\"line\">$ cnmp install</span><br><span class=\"line\"><span class=\"comment\"># 开启项目</span></span><br><span class=\"line\">$ npm run dev</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code>：放在项目根目录下，是项目的入口<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- app为一个组件，默认调用src里的main.js --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code>：注册组件app<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//import表示导入组件，ES6语法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable no-new */</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span>,</span><br><span class=\"line\">  components: &#123; App &#125;  <span class=\"comment\">//注册一个app</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>src/App.vue</code>：组件的主要代码，包括<code>template</code>、<code>script</code>、<code>style</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./assets/logo.png\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 渲染路径匹配到的视图组件，方便渲染你指定路由对应的组件 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'app'</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">#app &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class=\"line\"><span class=\"undefined\">  -webkit-font-smoothing: antialiased;</span></span><br><span class=\"line\"><span class=\"undefined\">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class=\"line\"><span class=\"undefined\">  text-align: center;</span></span><br><span class=\"line\"><span class=\"undefined\">  color: #2c3e50;</span></span><br><span class=\"line\"><span class=\"undefined\">  margin-top: 60px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>router/index.js</code>： 创建路由并配置路由映射 ，并通过export输出router到main.js文件中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">'@/components/HelloWorld'</span> </span><br><span class=\"line\"><span class=\"comment\">// 在这里引入另一个名为HelloWorld的组件</span></span><br><span class=\"line\"><span class=\"comment\">// 即components目录下的HelloWorld.vue</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">      component: HelloWorld</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>"},{"title":"Vue.js学习笔记（02）","date":"2018-07-25T12:13:45.000Z","_content":"## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n<!-- more -->\n\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n\n```html\n<template>\n  <div id=\"app\">hello, {{ name }}</div>\n</template>\n```\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    name: 'xiaoming'\n  }\n})\n```\n\n### props\n\n**作用：**用于接受来自父组件的数据，对象允许配置高级选项，如类型检测`type`，自定义校验`require validator`，默认值`default`\n```html\n<blog-post title=\"my Vue\"></blog-post>\n```\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式\n```\n▼ **设置默认和校验**\n```js\nVue.component('bkog-post', {\n  props: {\n    title: {\n      type: String,\n      default: 'title',\n      required: true,\n      validator: function (value) {\n        return value != 'abc'\n      }\n    }\n  }\n})\n```\n\n### propsData\n\n**作用：**创建实例时传递`props`，主要作用是方便测试。基本上，没有用过\n\n### computed\n\n**作用：**用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aDouble () {\n      return this.a * 2\n    }\n  }\n})\n```\n\n### methods\n\n**作用：**用来定义实例的一些处理方法，如绑定的事件等。**注意，在`methods`不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus () {\n      this.a ++\n    }\n  }\n})\n```\n\n### watch\n\n**作用：**用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。**同样，不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1, b: 2， c: 3 },\n  watch: {\n    a (curVal, oldVal) {\n      console.log(`new: %s, old: %s`, curVal, oldVal)\n    },\n    b: 'someMethod', // 这里的someMehod是对应的处理函数的名字\n    c: {\n      handler: function (curVal, oldVal) { /*...*/ },\n      deep: true, //深度 watcher，为了发现对象内部值的变化\n      immediate: true // 立即以表达式的当前值触发回调\n    }\n  }\n})\n```\n\n## Vue的生命周期\n\n每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：\n![](https://cn.vuejs.org/images/lifecycle.png)\n\n## 生命周期钩子函数\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeCreate**</span> 实例创建前，此时无法访问到`el`属性和`data`属性\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **created**</span> 实例创建完成，属性已经绑定，但是DOM还未生成，`el`属性还无法访问\n\n▼ **关于属性**\n不仅仅是`data`属性，还有`props`和`method`都在`created`的时候绑定完成\n\n---\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeMount**</span> 模板编译/挂在之前，**只有绑定了`el`属性，才会执行到这里，否则到`created`就已经停止生命周期**\n\n▼ **关于模板编译的顺序**\n* 当实例对象中有`template`参数的时候，则将其作为模板编译成`render`函数\n* 如果没有`template`参数时，则将外部HTML作为模板编译\n* 在Vue对象中还有一个`render`函数，它是以`createElement`作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于`template`与`outer HTML`\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **mounted**</span> 模板编译/挂在之后，**此时data数据绑定在页面上是以虚拟DOM的形式存在的**\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeUpdate && updated**</span> data数据更新之前 && 更新之后，组件重新渲染\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeDestroy && destroyed**</span> 实例销毁之前 && 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁","source":"_posts/Vue.js学习笔记（02）.md","raw":"---\ntitle: Vue.js学习笔记（02）\ndate: 2018-07-25 20:13:45\ncategories: Vue相关\ntags: \n  - Vue\n  - Vue生命周期\n---\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n<!-- more -->\n\n## Vue实例化输入的选项对象[基本介绍](https://cn.vuejs.org/v2/api/#data)\n\n当我们`new`一个Vue实例的时候，包含了如下几个基本的属性：\n\n### data\n\n**作用：**声明双向绑定的数据，可以是对象或者函数，**当定义组件的时候，`data`只能是函数**\n\n\n```html\n<template>\n  <div id=\"app\">hello, {{ name }}</div>\n</template>\n```\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    name: 'xiaoming'\n  }\n})\n```\n\n### props\n\n**作用：**用于接受来自父组件的数据，对象允许配置高级选项，如类型检测`type`，自定义校验`require validator`，默认值`default`\n```html\n<blog-post title=\"my Vue\"></blog-post>\n```\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式\n```\n▼ **设置默认和校验**\n```js\nVue.component('bkog-post', {\n  props: {\n    title: {\n      type: String,\n      default: 'title',\n      required: true,\n      validator: function (value) {\n        return value != 'abc'\n      }\n    }\n  }\n})\n```\n\n### propsData\n\n**作用：**创建实例时传递`props`，主要作用是方便测试。基本上，没有用过\n\n### computed\n\n**作用：**用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aDouble () {\n      return this.a * 2\n    }\n  }\n})\n```\n\n### methods\n\n**作用：**用来定义实例的一些处理方法，如绑定的事件等。**注意，在`methods`不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus () {\n      this.a ++\n    }\n  }\n})\n```\n\n### watch\n\n**作用：**用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。**同样，不能使用箭头函数来定义函数**\n```js\nvar vm = new Vue({\n  data: { a: 1, b: 2， c: 3 },\n  watch: {\n    a (curVal, oldVal) {\n      console.log(`new: %s, old: %s`, curVal, oldVal)\n    },\n    b: 'someMethod', // 这里的someMehod是对应的处理函数的名字\n    c: {\n      handler: function (curVal, oldVal) { /*...*/ },\n      deep: true, //深度 watcher，为了发现对象内部值的变化\n      immediate: true // 立即以表达式的当前值触发回调\n    }\n  }\n})\n```\n\n## Vue的生命周期\n\n每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：\n![](https://cn.vuejs.org/images/lifecycle.png)\n\n## 生命周期钩子函数\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeCreate**</span> 实例创建前，此时无法访问到`el`属性和`data`属性\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **created**</span> 实例创建完成，属性已经绑定，但是DOM还未生成，`el`属性还无法访问\n\n▼ **关于属性**\n不仅仅是`data`属性，还有`props`和`method`都在`created`的时候绑定完成\n\n---\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeMount**</span> 模板编译/挂在之前，**只有绑定了`el`属性，才会执行到这里，否则到`created`就已经停止生命周期**\n\n▼ **关于模板编译的顺序**\n* 当实例对象中有`template`参数的时候，则将其作为模板编译成`render`函数\n* 如果没有`template`参数时，则将外部HTML作为模板编译\n* 在Vue对象中还有一个`render`函数，它是以`createElement`作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于`template`与`outer HTML`\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **mounted**</span> 模板编译/挂在之后，**此时data数据绑定在页面上是以虚拟DOM的形式存在的**\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeUpdate && updated**</span> data数据更新之前 && 更新之后，组件重新渲染\n\n---\n\n<span style=\"font-size: 20px; color: #199475;\">▶ **beforeDestroy && destroyed**</span> 实例销毁之前 && 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁","slug":"Vue.js学习笔记（02）","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7x000gfr03utgl7t1s","content":"<h2 id=\"Vue实例化输入的选项对象基本介绍\"><a href=\"#Vue实例化输入的选项对象基本介绍\" class=\"headerlink\" title=\"Vue实例化输入的选项对象基本介绍\"></a>Vue实例化输入的选项对象<a href=\"https://cn.vuejs.org/v2/api/#data\" target=\"_blank\" rel=\"noopener\">基本介绍</a></h2><p>当我们<code>new</code>一个Vue实例的时候，包含了如下几个基本的属性：</p>\n<h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><p><strong>作用：</strong>声明双向绑定的数据，可以是对象或者函数，<strong>当定义组件的时候，<code>data</code>只能是函数</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"Vue实例化输入的选项对象基本介绍-1\"><a href=\"#Vue实例化输入的选项对象基本介绍-1\" class=\"headerlink\" title=\"Vue实例化输入的选项对象基本介绍\"></a>Vue实例化输入的选项对象<a href=\"https://cn.vuejs.org/v2/api/#data\" target=\"_blank\" rel=\"noopener\">基本介绍</a></h2><p>当我们<code>new</code>一个Vue实例的时候，包含了如下几个基本的属性：</p>\n<h3 id=\"data-1\"><a href=\"#data-1\" class=\"headerlink\" title=\"data\"></a>data</h3><p><strong>作用：</strong>声明双向绑定的数据，可以是对象或者函数，<strong>当定义组件的时候，<code>data</code>只能是函数</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span>hello, &#123;&#123; name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'xiaoming'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><p><strong>作用：</strong>用于接受来自父组件的数据，对象允许配置高级选项，如类型检测<code>type</code>，自定义校验<code>require validator</code>，默认值<code>default</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"my Vue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'blog-post'</span>, &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'title'</span>],</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式</span></span><br></pre></td></tr></table></figure>\n<p>▼ <strong>设置默认和校验</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'bkog-post'</span>, &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'title'</span>,</span><br><span class=\"line\">      required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      validator: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value != <span class=\"string\">'abc'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><p><strong>作用：</strong>创建实例时传递<code>props</code>，主要作用是方便测试。基本上，没有用过</p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><p><strong>作用：</strong>用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    aDouble () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><p><strong>作用：</strong>用来定义实例的一些处理方法，如绑定的事件等。<strong>注意，在<code>methods</code>不能使用箭头函数来定义函数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    plus () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.a ++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><p><strong>作用：</strong>用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。<strong>同样，不能使用箭头函数来定义函数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>， c: <span class=\"number\">3</span> &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    a (curVal, oldVal) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`new: %s, old: %s`</span>, curVal, oldVal)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    b: <span class=\"string\">'someMethod'</span>, <span class=\"comment\">// 这里的someMehod是对应的处理函数的名字</span></span><br><span class=\"line\">    c: &#123;</span><br><span class=\"line\">      handler: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">curVal, oldVal</span>) </span>&#123; <span class=\"comment\">/*...*/</span> &#125;,</span><br><span class=\"line\">      deep: <span class=\"literal\">true</span>, <span class=\"comment\">//深度 watcher，为了发现对象内部值的变化</span></span><br><span class=\"line\">      immediate: <span class=\"literal\">true</span> <span class=\"comment\">// 立即以表达式的当前值触发回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vue的生命周期\"><a href=\"#Vue的生命周期\" class=\"headerlink\" title=\"Vue的生命周期\"></a>Vue的生命周期</h2><p>每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：<br><img src=\"https://cn.vuejs.org/images/lifecycle.png\" alt></p>\n<h2 id=\"生命周期钩子函数\"><a href=\"#生命周期钩子函数\" class=\"headerlink\" title=\"生命周期钩子函数\"></a>生命周期钩子函数</h2><p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeCreate</strong></span> 实例创建前，此时无法访问到<code>el</code>属性和<code>data</code>属性</p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>created</strong></span> 实例创建完成，属性已经绑定，但是DOM还未生成，<code>el</code>属性还无法访问</p>\n<p>▼ <strong>关于属性</strong><br>不仅仅是<code>data</code>属性，还有<code>props</code>和<code>method</code>都在<code>created</code>的时候绑定完成</p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeMount</strong></span> 模板编译/挂在之前，<strong>只有绑定了<code>el</code>属性，才会执行到这里，否则到<code>created</code>就已经停止生命周期</strong></p>\n<p>▼ <strong>关于模板编译的顺序</strong></p>\n<ul>\n<li>当实例对象中有<code>template</code>参数的时候，则将其作为模板编译成<code>render</code>函数</li>\n<li>如果没有<code>template</code>参数时，则将外部HTML作为模板编译</li>\n<li>在Vue对象中还有一个<code>render</code>函数，它是以<code>createElement</code>作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于<code>template</code>与<code>outer HTML</code></li>\n</ul>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>mounted</strong></span> 模板编译/挂在之后，<strong>此时data数据绑定在页面上是以虚拟DOM的形式存在的</strong></p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeUpdate &amp;&amp; updated</strong></span> data数据更新之前 &amp;&amp; 更新之后，组件重新渲染</p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeDestroy &amp;&amp; destroyed</strong></span> 实例销毁之前 &amp;&amp; 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Vue实例化输入的选项对象基本介绍\"><a href=\"#Vue实例化输入的选项对象基本介绍\" class=\"headerlink\" title=\"Vue实例化输入的选项对象基本介绍\"></a>Vue实例化输入的选项对象<a href=\"https://cn.vuejs.org/v2/api/#data\" target=\"_blank\" rel=\"noopener\">基本介绍</a></h2><p>当我们<code>new</code>一个Vue实例的时候，包含了如下几个基本的属性：</p>\n<h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><p><strong>作用：</strong>声明双向绑定的数据，可以是对象或者函数，<strong>当定义组件的时候，<code>data</code>只能是函数</strong></p>","more":"<h2 id=\"Vue实例化输入的选项对象基本介绍-1\"><a href=\"#Vue实例化输入的选项对象基本介绍-1\" class=\"headerlink\" title=\"Vue实例化输入的选项对象基本介绍\"></a>Vue实例化输入的选项对象<a href=\"https://cn.vuejs.org/v2/api/#data\" target=\"_blank\" rel=\"noopener\">基本介绍</a></h2><p>当我们<code>new</code>一个Vue实例的时候，包含了如下几个基本的属性：</p>\n<h3 id=\"data-1\"><a href=\"#data-1\" class=\"headerlink\" title=\"data\"></a>data</h3><p><strong>作用：</strong>声明双向绑定的数据，可以是对象或者函数，<strong>当定义组件的时候，<code>data</code>只能是函数</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span>hello, &#123;&#123; name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'xiaoming'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><p><strong>作用：</strong>用于接受来自父组件的数据，对象允许配置高级选项，如类型检测<code>type</code>，自定义校验<code>require validator</code>，默认值<code>default</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"my Vue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'blog-post'</span>, &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'title'</span>],</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 比较简单的组件示例，在项目中并不会这样使用组件，而是通过路由的方式</span></span><br></pre></td></tr></table></figure>\n<p>▼ <strong>设置默认和校验</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'bkog-post'</span>, &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'title'</span>,</span><br><span class=\"line\">      required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      validator: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value != <span class=\"string\">'abc'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><p><strong>作用：</strong>创建实例时传递<code>props</code>，主要作用是方便测试。基本上，没有用过</p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><p><strong>作用：</strong>用来定义一些需要计算得到的数据，计算的结果会被缓存，除非依赖的响应式属性变化才会重新计算<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    aDouble () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><p><strong>作用：</strong>用来定义实例的一些处理方法，如绑定的事件等。<strong>注意，在<code>methods</code>不能使用箭头函数来定义函数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    plus () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.a ++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><p><strong>作用：</strong>用来观察实例中数据的变化。数据类型可以是字符串、函数、对象和数组。<strong>同样，不能使用箭头函数来定义函数</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>， c: <span class=\"number\">3</span> &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    a (curVal, oldVal) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`new: %s, old: %s`</span>, curVal, oldVal)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    b: <span class=\"string\">'someMethod'</span>, <span class=\"comment\">// 这里的someMehod是对应的处理函数的名字</span></span><br><span class=\"line\">    c: &#123;</span><br><span class=\"line\">      handler: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">curVal, oldVal</span>) </span>&#123; <span class=\"comment\">/*...*/</span> &#125;,</span><br><span class=\"line\">      deep: <span class=\"literal\">true</span>, <span class=\"comment\">//深度 watcher，为了发现对象内部值的变化</span></span><br><span class=\"line\">      immediate: <span class=\"literal\">true</span> <span class=\"comment\">// 立即以表达式的当前值触发回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vue的生命周期\"><a href=\"#Vue的生命周期\" class=\"headerlink\" title=\"Vue的生命周期\"></a>Vue的生命周期</h2><p>每个Vue实例被创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行相应的操作，下图即是官网上的生命周期图示：<br><img src=\"https://cn.vuejs.org/images/lifecycle.png\" alt></p>\n<h2 id=\"生命周期钩子函数\"><a href=\"#生命周期钩子函数\" class=\"headerlink\" title=\"生命周期钩子函数\"></a>生命周期钩子函数</h2><p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeCreate</strong></span> 实例创建前，此时无法访问到<code>el</code>属性和<code>data</code>属性</p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>created</strong></span> 实例创建完成，属性已经绑定，但是DOM还未生成，<code>el</code>属性还无法访问</p>\n<p>▼ <strong>关于属性</strong><br>不仅仅是<code>data</code>属性，还有<code>props</code>和<code>method</code>都在<code>created</code>的时候绑定完成</p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeMount</strong></span> 模板编译/挂在之前，<strong>只有绑定了<code>el</code>属性，才会执行到这里，否则到<code>created</code>就已经停止生命周期</strong></p>\n<p>▼ <strong>关于模板编译的顺序</strong></p>\n<ul>\n<li>当实例对象中有<code>template</code>参数的时候，则将其作为模板编译成<code>render</code>函数</li>\n<li>如果没有<code>template</code>参数时，则将外部HTML作为模板编译</li>\n<li>在Vue对象中还有一个<code>render</code>函数，它是以<code>createElement</code>作为参数，然后做渲染操作，可以直接嵌入JSX，它的执行优先级高于<code>template</code>与<code>outer HTML</code></li>\n</ul>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>mounted</strong></span> 模板编译/挂在之后，<strong>此时data数据绑定在页面上是以虚拟DOM的形式存在的</strong></p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeUpdate &amp;&amp; updated</strong></span> data数据更新之前 &amp;&amp; 更新之后，组件重新渲染</p>\n<hr>\n<p><span style=\"font-size: 20px; color: #199475;\">▶ <strong>beforeDestroy &amp;&amp; destroyed</strong></span> 实例销毁之前 &amp;&amp; 销毁之后，销毁之后所有的绑定都会被解除，事件监听也会被移除，同时子实例也同时被销毁</p>"},{"title":"Vue.js学习笔记（03）","date":"2018-08-19T05:32:38.000Z","_content":"\n## 指令\n\n一个.vue文件包含着三个部分，`template`、`script`和`style`，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：\n\n* 更新元素内容的指令：v-text、v-html\n* 模板渲染：v-show、v-if、v-else、v-else-if、v-for\n* 事件绑定：v-on\n* 绑定属性或class与style：v-bind\n* 绑定表单控件：v-model\n* 特殊：v-pre、v-cloak、v-once\n\n<!-- more -->\n\n## 指令\n\n一个.vue文件包含着三个部分，`template`、`script`和`style`，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：\n\n* 更新元素内容的指令：v-text、v-html\n* 模板渲染：v-show、v-if、v-else、v-else-if、v-for\n* 事件绑定：v-on\n* 绑定属性或class与style：v-bind\n* 绑定表单控件：v-model\n* 特殊：v-pre、v-cloak、v-once\n","source":"_posts/Vue.js学习笔记（03）.md","raw":"---\ntitle: Vue.js学习笔记（03）\ndate: 2018-08-19 13:32:38\ncategories: Vue相关\ntags: \n  - Vue\n  - Vue指令\n  - Vue事件\n---\n\n## 指令\n\n一个.vue文件包含着三个部分，`template`、`script`和`style`，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：\n\n* 更新元素内容的指令：v-text、v-html\n* 模板渲染：v-show、v-if、v-else、v-else-if、v-for\n* 事件绑定：v-on\n* 绑定属性或class与style：v-bind\n* 绑定表单控件：v-model\n* 特殊：v-pre、v-cloak、v-once\n\n<!-- more -->\n\n## 指令\n\n一个.vue文件包含着三个部分，`template`、`script`和`style`，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：\n\n* 更新元素内容的指令：v-text、v-html\n* 模板渲染：v-show、v-if、v-else、v-else-if、v-for\n* 事件绑定：v-on\n* 绑定属性或class与style：v-bind\n* 绑定表单控件：v-model\n* 特殊：v-pre、v-cloak、v-once\n","slug":"Vue.js学习笔记（03）","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7x000hfr03ih582gy6","content":"<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>一个.vue文件包含着三个部分，<code>template</code>、<code>script</code>和<code>style</code>，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：</p>\n<ul>\n<li>更新元素内容的指令：v-text、v-html</li>\n<li>模板渲染：v-show、v-if、v-else、v-else-if、v-for</li>\n<li>事件绑定：v-on</li>\n<li>绑定属性或class与style：v-bind</li>\n<li>绑定表单控件：v-model</li>\n<li>特殊：v-pre、v-cloak、v-once</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"指令-1\"><a href=\"#指令-1\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>一个.vue文件包含着三个部分，<code>template</code>、<code>script</code>和<code>style</code>，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：</p>\n<ul>\n<li>更新元素内容的指令：v-text、v-html</li>\n<li>模板渲染：v-show、v-if、v-else、v-else-if、v-for</li>\n<li>事件绑定：v-on</li>\n<li>绑定属性或class与style：v-bind</li>\n<li>绑定表单控件：v-model</li>\n<li>特殊：v-pre、v-cloak、v-once</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>一个.vue文件包含着三个部分，<code>template</code>、<code>script</code>和<code>style</code>，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：</p>\n<ul>\n<li>更新元素内容的指令：v-text、v-html</li>\n<li>模板渲染：v-show、v-if、v-else、v-else-if、v-for</li>\n<li>事件绑定：v-on</li>\n<li>绑定属性或class与style：v-bind</li>\n<li>绑定表单控件：v-model</li>\n<li>特殊：v-pre、v-cloak、v-once</li>\n</ul>","more":"<h2 id=\"指令-1\"><a href=\"#指令-1\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>一个.vue文件包含着三个部分，<code>template</code>、<code>script</code>和<code>style</code>，其中指令的作用就是为了模板的渲染，Vue的指令包含了一下几种：</p>\n<ul>\n<li>更新元素内容的指令：v-text、v-html</li>\n<li>模板渲染：v-show、v-if、v-else、v-else-if、v-for</li>\n<li>事件绑定：v-on</li>\n<li>绑定属性或class与style：v-bind</li>\n<li>绑定表单控件：v-model</li>\n<li>特殊：v-pre、v-cloak、v-once</li>\n</ul>"},{"title":"Webpack学习笔记","date":"2018-01-15T06:13:32.000Z","_content":"## Webpack 基本介绍\n\n▼ **什么是Webpack：**\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\n我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。\n\n<!-- more -->\n\n## Webpack 基本介绍\n\n▼ **什么是Webpack：**\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\n我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。\n▼ **为什那么要使用Webpack：**\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：\n* **模块化**，让我们可以把复杂的程序细化为小的文件；\n* 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\n* Scss，less等CSS预处理器；\n* ...\n\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为Webpack类的工具的出现提供了需求。\n\n## Webpack 的使用\n\n### 安装\n我们常规直接使用 npm 的形式来安装（全局安装）：\n```\n$ npm install webpack -g\n```\n如果常规项目还是把依赖写入 package.json 包更人性化（局部安装）：\n```\n$ npm init // 生成package.json文件，写入一些如作者、版本等基本信息\n$ npm install webpack --save-dev\n```\n\n### 配置\n每个项目下都必须配置有一个 webpack.config.js，就是一个配置项，告诉 webpack 它需要做什么。\n```js\nvar webpack = require('webpack');\nvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n\nmodule.exports = {\n  //插件项\n  plugins: [commonsPlugin],\n  //页面入口文件配置\n  entry: {\n    index : './src/js/page/index.js'\n  },\n  //入口文件输出配置\n  output: {\n    path: 'dist/js/page',\n    filename: '[name].js'\n  },\n  module: {\n    //加载器配置\n    loaders: [\n      { test: /\\.css$/, loader: 'style-loader!css-loader' },\n      { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n      { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n      { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n    ]\n  },\n  //其它解决方案配置\n  resolve: {\n    root: 'E:/github/flux-example/src', //绝对路径\n    extensions: ['', '.js', '.json', '.scss'],\n    alias: {\n      AppStore : 'js/stores/AppStores.js',\n      ActionType : 'js/actions/ActionType.js',\n      AppAction : 'js/actions/AppAction.js'\n    }\n  }\n};\n```\n▼ **plugins：**\n插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。\n▼ **entry：**\n页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：\n```js\n{\n  entry: {\n    page1: \"./page1\",\n    //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出\n    page2: [\"./entry1\", \"./entry2\"]\n  },\n  output: {\n   path: \"dist/js/page\",\n   filename: \"[name].bundle.js\"\n  }\n}\n```\n该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。\n▼ **module.loaders：**\n告知 webpack 每一种文件都需要使用什么加载器来处理：\n```js\nmodule: {\n  //加载器配置\n  loaders: [\n    //.css 文件使用 style-loader 和 css-loader 来处理\n    { test: /\\.css$/, loader: 'style-loader!css-loader' },\n    //.js 文件使用 jsx-loader 来编译处理\n    { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n    //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理\n    { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n    //图片文件使用 url-loader 来处理，小于8kb的直接转为base64\n    { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n  ]\n}\n```\n如上，\"-loader\"其实是可以省略不写的，多个loader之间用“!”连接起来。\n**所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。**\n如：url-loader，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：\n```\nnpm install url-loader -save-dev\n```\n配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。\n▼ **resolve：**\n其它解决方案配置\n```js\nresolve: {\n  //查找module的话从这里开始查找\n  root: 'E:/github/flux-example/src', //绝对路径\n  //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n  extensions: ['', '.js', '.json', '.scss'],\n  //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n  alias: {\n    AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n    ActionType : 'js/actions/ActionType.js',\n    AppAction : 'js/actions/AppAction.js'\n  }\n}\n```\n### 运行\n\n```\n$ webpack --display-error-details\n```\n后面的参数“--display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。\n其他主要的参数有：\n```\n$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包\n$ webpack --watch   //监听变动并自动打包\n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n## 实战应用\n\n项目文件夹结构如下图：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/webpack-1.png)\n\n* src目录下的文件夹存放源代码，dist目录下存放打包过后的代码\n```js\nvar path = require('path');\nvar webpack = require('webpack');\n\nmodule.exports = {\n  entry: './src/index.js', // 以index.js为入口\n  output: {\n    filename: 'js/canvas-filter.bundle.js', // 打包后生成的文件\n    path: path.resolve(__dirname,'./dist') // 使用绝对路径\n  },\n  module: {\n    rules: [\n      { // 使js中能够require css 文件的loader\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          { loader: 'css-loader', options: { importLoaders: 1 } },\n          'postcss-loader'\n        ]\n      },\n      { // 使得less文件能够解析成css的loader\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          { loader: 'css-loader', options: { importLoaders: 1 } },\n          'less-loader',\n          'postcss-loader'\n        ]\n      },\n      { // 使得能够正确引用图片文件路径的loader\n        test: /\\.(png|jpg|gif|svg)$/i,\n        loader: 'file-loader'\n      }\n    ]\n  },\n  plugins: [\n    // 再项目中使用jquery时所需要的配置\n    new webpack.ProvidePlugin({\n      $: 'jquery',\n      jQuery: 'jquery',\n      'window.jQuery': 'jquery',\n      'window.$': 'jquery'\n    }),\n    new webpack.HotModuleReplacementPlugin()\n  ],\n  devServer: {\n    // 使用webpack-dev-server，开启本地服务器\n    hot: true,\n    inline: true\n  }\n}\n```\n\n","source":"_posts/Webpack学习笔记.md","raw":"---\ntitle: Webpack学习笔记\ndate: 2018-01-15 14:13:32\ncategories: 项目自动化\ntags: \n  - Webpack\n---\n## Webpack 基本介绍\n\n▼ **什么是Webpack：**\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\n我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。\n\n<!-- more -->\n\n## Webpack 基本介绍\n\n▼ **什么是Webpack：**\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\n我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。\n▼ **为什那么要使用Webpack：**\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：\n* **模块化**，让我们可以把复杂的程序细化为小的文件；\n* 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\n* Scss，less等CSS预处理器；\n* ...\n\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为Webpack类的工具的出现提供了需求。\n\n## Webpack 的使用\n\n### 安装\n我们常规直接使用 npm 的形式来安装（全局安装）：\n```\n$ npm install webpack -g\n```\n如果常规项目还是把依赖写入 package.json 包更人性化（局部安装）：\n```\n$ npm init // 生成package.json文件，写入一些如作者、版本等基本信息\n$ npm install webpack --save-dev\n```\n\n### 配置\n每个项目下都必须配置有一个 webpack.config.js，就是一个配置项，告诉 webpack 它需要做什么。\n```js\nvar webpack = require('webpack');\nvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n\nmodule.exports = {\n  //插件项\n  plugins: [commonsPlugin],\n  //页面入口文件配置\n  entry: {\n    index : './src/js/page/index.js'\n  },\n  //入口文件输出配置\n  output: {\n    path: 'dist/js/page',\n    filename: '[name].js'\n  },\n  module: {\n    //加载器配置\n    loaders: [\n      { test: /\\.css$/, loader: 'style-loader!css-loader' },\n      { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n      { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n      { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n    ]\n  },\n  //其它解决方案配置\n  resolve: {\n    root: 'E:/github/flux-example/src', //绝对路径\n    extensions: ['', '.js', '.json', '.scss'],\n    alias: {\n      AppStore : 'js/stores/AppStores.js',\n      ActionType : 'js/actions/ActionType.js',\n      AppAction : 'js/actions/AppAction.js'\n    }\n  }\n};\n```\n▼ **plugins：**\n插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。\n▼ **entry：**\n页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：\n```js\n{\n  entry: {\n    page1: \"./page1\",\n    //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出\n    page2: [\"./entry1\", \"./entry2\"]\n  },\n  output: {\n   path: \"dist/js/page\",\n   filename: \"[name].bundle.js\"\n  }\n}\n```\n该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。\n▼ **module.loaders：**\n告知 webpack 每一种文件都需要使用什么加载器来处理：\n```js\nmodule: {\n  //加载器配置\n  loaders: [\n    //.css 文件使用 style-loader 和 css-loader 来处理\n    { test: /\\.css$/, loader: 'style-loader!css-loader' },\n    //.js 文件使用 jsx-loader 来编译处理\n    { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n    //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理\n    { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n    //图片文件使用 url-loader 来处理，小于8kb的直接转为base64\n    { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n  ]\n}\n```\n如上，\"-loader\"其实是可以省略不写的，多个loader之间用“!”连接起来。\n**所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。**\n如：url-loader，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：\n```\nnpm install url-loader -save-dev\n```\n配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。\n▼ **resolve：**\n其它解决方案配置\n```js\nresolve: {\n  //查找module的话从这里开始查找\n  root: 'E:/github/flux-example/src', //绝对路径\n  //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n  extensions: ['', '.js', '.json', '.scss'],\n  //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n  alias: {\n    AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n    ActionType : 'js/actions/ActionType.js',\n    AppAction : 'js/actions/AppAction.js'\n  }\n}\n```\n### 运行\n\n```\n$ webpack --display-error-details\n```\n后面的参数“--display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。\n其他主要的参数有：\n```\n$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包\n$ webpack --watch   //监听变动并自动打包\n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n## 实战应用\n\n项目文件夹结构如下图：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/webpack-1.png)\n\n* src目录下的文件夹存放源代码，dist目录下存放打包过后的代码\n```js\nvar path = require('path');\nvar webpack = require('webpack');\n\nmodule.exports = {\n  entry: './src/index.js', // 以index.js为入口\n  output: {\n    filename: 'js/canvas-filter.bundle.js', // 打包后生成的文件\n    path: path.resolve(__dirname,'./dist') // 使用绝对路径\n  },\n  module: {\n    rules: [\n      { // 使js中能够require css 文件的loader\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          { loader: 'css-loader', options: { importLoaders: 1 } },\n          'postcss-loader'\n        ]\n      },\n      { // 使得less文件能够解析成css的loader\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          { loader: 'css-loader', options: { importLoaders: 1 } },\n          'less-loader',\n          'postcss-loader'\n        ]\n      },\n      { // 使得能够正确引用图片文件路径的loader\n        test: /\\.(png|jpg|gif|svg)$/i,\n        loader: 'file-loader'\n      }\n    ]\n  },\n  plugins: [\n    // 再项目中使用jquery时所需要的配置\n    new webpack.ProvidePlugin({\n      $: 'jquery',\n      jQuery: 'jquery',\n      'window.jQuery': 'jquery',\n      'window.$': 'jquery'\n    }),\n    new webpack.HotModuleReplacementPlugin()\n  ],\n  devServer: {\n    // 使用webpack-dev-server，开启本地服务器\n    hot: true,\n    inline: true\n  }\n}\n```\n\n","slug":"Webpack学习笔记","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7y000ifr03f0z5lzwl","content":"<h2 id=\"Webpack-基本介绍\"><a href=\"#Webpack-基本介绍\" class=\"headerlink\" title=\"Webpack 基本介绍\"></a>Webpack 基本介绍</h2><p>▼ <strong>什么是Webpack：</strong><br>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。</p>\n<a id=\"more\"></a>\n<h2 id=\"Webpack-基本介绍-1\"><a href=\"#Webpack-基本介绍-1\" class=\"headerlink\" title=\"Webpack 基本介绍\"></a>Webpack 基本介绍</h2><p>▼ <strong>什么是Webpack：</strong><br>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。<br>▼ <strong>为什那么要使用Webpack：</strong><br>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：</p>\n<ul>\n<li><strong>模块化</strong>，让我们可以把复杂的程序细化为小的文件；</li>\n<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</li>\n<li>Scss，less等CSS预处理器；</li>\n<li>…</li>\n</ul>\n<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为Webpack类的工具的出现提供了需求。</p>\n<h2 id=\"Webpack-的使用\"><a href=\"#Webpack-的使用\" class=\"headerlink\" title=\"Webpack 的使用\"></a>Webpack 的使用</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>我们常规直接使用 npm 的形式来安装（全局安装）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p>\n<p>如果常规项目还是把依赖写入 package.json 包更人性化（局部安装）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init // 生成package.json文件，写入一些如作者、版本等基本信息</span><br><span class=\"line\">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>每个项目下都必须配置有一个 webpack.config.js，就是一个配置项，告诉 webpack 它需要做什么。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> commonsPlugin = <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'common.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//插件项</span></span><br><span class=\"line\">  plugins: [commonsPlugin],</span><br><span class=\"line\">  <span class=\"comment\">//页面入口文件配置</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    index : <span class=\"string\">'./src/js/page/index.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//入口文件输出配置</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: <span class=\"string\">'dist/js/page'</span>,</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载器配置</span></span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//其它解决方案配置</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,</span><br><span class=\"line\">      ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</span><br><span class=\"line\">      AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>plugins：</strong><br>插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。<br>▼ <strong>entry：</strong><br>页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    page1: <span class=\"string\">\"./page1\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span></span><br><span class=\"line\">    page2: [<span class=\"string\">\"./entry1\"</span>, <span class=\"string\">\"./entry2\"</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">   path: <span class=\"string\">\"dist/js/page\"</span>,</span><br><span class=\"line\">   filename: <span class=\"string\">\"[name].bundle.js\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。<br>▼ <strong>module.loaders：</strong><br>告知 webpack 每一种文件都需要使用什么加载器来处理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"comment\">//加载器配置</span></span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    <span class=\"comment\">//.css 文件使用 style-loader 和 css-loader 来处理</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//.js 文件使用 jsx-loader 来编译处理</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</span><br><span class=\"line\">    <span class=\"comment\">//图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。<br><strong>所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。</strong><br>如：url-loader，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install url-loader -save-dev</span><br></pre></td></tr></table></figure></p>\n<p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。<br>▼ <strong>resolve：</strong><br>其它解决方案配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  <span class=\"comment\">//查找module的话从这里开始查找</span></span><br><span class=\"line\">  root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></span><br><span class=\"line\">  <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class=\"line\">  extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</span><br><span class=\"line\">  <span class=\"comment\">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></span><br><span class=\"line\">  alias: &#123;</span><br><span class=\"line\">    AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,<span class=\"comment\">//后续直接 require('AppStore') 即可</span></span><br><span class=\"line\">    ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</span><br><span class=\"line\">    AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --display-error-details</span><br></pre></td></tr></table></figure>\n<p>后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。<br>其他主要的参数有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</span><br><span class=\"line\">$ webpack --watch   //监听变动并自动打包</span><br><span class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实战应用\"><a href=\"#实战应用\" class=\"headerlink\" title=\"实战应用\"></a>实战应用</h2><p>项目文件夹结构如下图：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/webpack-1.png\" alt></p>\n<ul>\n<li>src目录下的文件夹存放源代码，dist目录下存放打包过后的代码<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>, <span class=\"comment\">// 以index.js为入口</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'js/canvas-filter.bundle.js'</span>, <span class=\"comment\">// 打包后生成的文件</span></span><br><span class=\"line\">    path: path.resolve(__dirname,<span class=\"string\">'./dist'</span>) <span class=\"comment\">// 使用绝对路径</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123; <span class=\"comment\">// 使js中能够require css 文件的loader</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'css-loader'</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">importLoaders</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">          <span class=\"string\">'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123; <span class=\"comment\">// 使得less文件能够解析成css的loader</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'css-loader'</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">importLoaders</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">          <span class=\"string\">'less-loader'</span>,</span><br><span class=\"line\">          <span class=\"string\">'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123; <span class=\"comment\">// 使得能够正确引用图片文件路径的loader</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif|svg)$/i</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 再项目中使用jquery时所需要的配置</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">      $: <span class=\"string\">'jquery'</span>,</span><br><span class=\"line\">      jQuery: <span class=\"string\">'jquery'</span>,</span><br><span class=\"line\">      <span class=\"string\">'window.jQuery'</span>: <span class=\"string\">'jquery'</span>,</span><br><span class=\"line\">      <span class=\"string\">'window.$'</span>: <span class=\"string\">'jquery'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用webpack-dev-server，开启本地服务器</span></span><br><span class=\"line\">    hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    inline: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Webpack-基本介绍\"><a href=\"#Webpack-基本介绍\" class=\"headerlink\" title=\"Webpack 基本介绍\"></a>Webpack 基本介绍</h2><p>▼ <strong>什么是Webpack：</strong><br>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。</p>","more":"<h2 id=\"Webpack-基本介绍-1\"><a href=\"#Webpack-基本介绍-1\" class=\"headerlink\" title=\"Webpack 基本介绍\"></a>Webpack 基本介绍</h2><p>▼ <strong>什么是Webpack：</strong><br>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。<br>▼ <strong>为什那么要使用Webpack：</strong><br>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：</p>\n<ul>\n<li><strong>模块化</strong>，让我们可以把复杂的程序细化为小的文件；</li>\n<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</li>\n<li>Scss，less等CSS预处理器；</li>\n<li>…</li>\n</ul>\n<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为Webpack类的工具的出现提供了需求。</p>\n<h2 id=\"Webpack-的使用\"><a href=\"#Webpack-的使用\" class=\"headerlink\" title=\"Webpack 的使用\"></a>Webpack 的使用</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>我们常规直接使用 npm 的形式来安装（全局安装）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p>\n<p>如果常规项目还是把依赖写入 package.json 包更人性化（局部安装）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init // 生成package.json文件，写入一些如作者、版本等基本信息</span><br><span class=\"line\">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>每个项目下都必须配置有一个 webpack.config.js，就是一个配置项，告诉 webpack 它需要做什么。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> commonsPlugin = <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'common.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//插件项</span></span><br><span class=\"line\">  plugins: [commonsPlugin],</span><br><span class=\"line\">  <span class=\"comment\">//页面入口文件配置</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    index : <span class=\"string\">'./src/js/page/index.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//入口文件输出配置</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: <span class=\"string\">'dist/js/page'</span>,</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载器配置</span></span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//其它解决方案配置</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,</span><br><span class=\"line\">      ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</span><br><span class=\"line\">      AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>plugins：</strong><br>插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。<br>▼ <strong>entry：</strong><br>页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    page1: <span class=\"string\">\"./page1\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span></span><br><span class=\"line\">    page2: [<span class=\"string\">\"./entry1\"</span>, <span class=\"string\">\"./entry2\"</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">   path: <span class=\"string\">\"dist/js/page\"</span>,</span><br><span class=\"line\">   filename: <span class=\"string\">\"[name].bundle.js\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。<br>▼ <strong>module.loaders：</strong><br>告知 webpack 每一种文件都需要使用什么加载器来处理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"comment\">//加载器配置</span></span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    <span class=\"comment\">//.css 文件使用 style-loader 和 css-loader 来处理</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//.js 文件使用 jsx-loader 来编译处理</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</span><br><span class=\"line\">    <span class=\"comment\">//图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。<br><strong>所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。</strong><br>如：url-loader，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install url-loader -save-dev</span><br></pre></td></tr></table></figure></p>\n<p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。<br>▼ <strong>resolve：</strong><br>其它解决方案配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  <span class=\"comment\">//查找module的话从这里开始查找</span></span><br><span class=\"line\">  root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></span><br><span class=\"line\">  <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class=\"line\">  extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</span><br><span class=\"line\">  <span class=\"comment\">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></span><br><span class=\"line\">  alias: &#123;</span><br><span class=\"line\">    AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,<span class=\"comment\">//后续直接 require('AppStore') 即可</span></span><br><span class=\"line\">    ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</span><br><span class=\"line\">    AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --display-error-details</span><br></pre></td></tr></table></figure>\n<p>后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。<br>其他主要的参数有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</span><br><span class=\"line\">$ webpack --watch   //监听变动并自动打包</span><br><span class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实战应用\"><a href=\"#实战应用\" class=\"headerlink\" title=\"实战应用\"></a>实战应用</h2><p>项目文件夹结构如下图：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/webpack-1.png\" alt></p>\n<ul>\n<li>src目录下的文件夹存放源代码，dist目录下存放打包过后的代码<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>, <span class=\"comment\">// 以index.js为入口</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'js/canvas-filter.bundle.js'</span>, <span class=\"comment\">// 打包后生成的文件</span></span><br><span class=\"line\">    path: path.resolve(__dirname,<span class=\"string\">'./dist'</span>) <span class=\"comment\">// 使用绝对路径</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123; <span class=\"comment\">// 使js中能够require css 文件的loader</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'css-loader'</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">importLoaders</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">          <span class=\"string\">'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123; <span class=\"comment\">// 使得less文件能够解析成css的loader</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'css-loader'</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">importLoaders</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">          <span class=\"string\">'less-loader'</span>,</span><br><span class=\"line\">          <span class=\"string\">'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123; <span class=\"comment\">// 使得能够正确引用图片文件路径的loader</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif|svg)$/i</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 再项目中使用jquery时所需要的配置</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">      $: <span class=\"string\">'jquery'</span>,</span><br><span class=\"line\">      jQuery: <span class=\"string\">'jquery'</span>,</span><br><span class=\"line\">      <span class=\"string\">'window.jQuery'</span>: <span class=\"string\">'jquery'</span>,</span><br><span class=\"line\">      <span class=\"string\">'window.$'</span>: <span class=\"string\">'jquery'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用webpack-dev-server，开启本地服务器</span></span><br><span class=\"line\">    hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    inline: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"cli工具之init","date":"2019-10-19T08:11:11.000Z","_content":"\n了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。\n\n<!--more-->\n\n了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。\n\n`init`命令通常都具备以下几个功能：\n\n* 可交互\n* 远程拉取项目到本地\n* 可修改package.json中的项目名版本号等信息\n\n那么，如何实现呢？\n\n## inquirer\n\n[inquirer](https://github.com/SBoudrias/Inquirer.js/#examples)是nodejs的交互式命令行工具，通过该插件我们可以完成终端上的交互。\n\n### 使用方法\n\n```js\ninquirer\n  .prompt([\n    {\n      type: 'input', // 交互方式，input、confirm等\n      name: 'projectName', // 用来存输入结果的字段名\n      message: 'project name:', // 提示输入信息\n      default: 'template' // 默认值\n    }\n  ])\n  .then((answers) => {\n    console.log(answers)\n  })\n```\n你将看到的交互效果：\n![](https://my-image-1300309047.cos.ap-chengdu.myqcloud.com/my_blog/cmd-4.png)\n\n## download-git-repo\n\n[download-git-repo](https://www.npmjs.com/package/download-git-repo)是将远程仓库（如GitHub, GitLab, Bitbucket）的项目下载到本地的命令行工具。\n\n### 使用方法\n\n```js\n// 从github下载\ndownload(repositoryName, projectName, function (err) {\n  console.log(err ? 'Error' : 'Success')\n})\n```\n\n## 修改package.json\n\n这里我们使用nodejs的fs模块所提供的方法来实现，代码如下：\n\n```js\nfunction edit (info, path) {\n  fs.readFile(path + '/package.json', function (err, data) {\n    if (err) {\n      console.log(err)\n      return\n    }\n    var data = JSON.parse(data)\n    data.name = info.projectName\n    data.author = info.author\n    data.version = info.version\n    var replaceData = JSON.stringify(data, null, 4)\n    fs.writeFile(path + '/package.json', replaceData, function (err) {\n      if (err) {\n        console.log(err)\n      }\n    })\n  })\n}\n```\n\n## 完整代码\n\n```js\nvar program = require('commander')\nvar ora = require('ora') //ora 一个命令行loading效果\nvar inquirer = require('inquirer') // 命令行交互\nvar download = require('download-git-repo') // github api用来下载github的模板\nvar fs = require('fs')\n\nprogram\n  .command('init [projectName]') // 设置指令\n  .description('init project')\n  .action(function (projectName, opts) { // 执行操作\n    var loading = ora('fetching template......')\n    inquirer\n      .prompt([\n        {\n          type: 'input',\n          name: 'projectName',\n          message: '项目名称',\n          default: projectName || 'template'\n        },\n        {\n          type: 'input',\n          name: 'author',\n          message: '作者'\n        },\n        {\n          type: 'input',\n          name: 'version',\n          message: '版本',\n          default: '0.1.0'\n        }\n      ])\n      .then(function (answers) {\n        var repository = 'Yx1aoq1/vue-template'\n        var project = answers.projectName\n        loading.start()\n        download(repository, project, function (err) {\n          if (err) {\n            console.log(err)\n            return\n          }\n          var path = process.cwd() + '\\/' + project\n          edit(answers, path)\n          console.log(path)\n          loading.succeed()\n        })\n      })\n  })\n\nfunction edit (info, path) {\n  fs.readFile(path + '/package.json', function (err, data) {\n    if (err) {\n      console.log(err)\n      return\n    }\n    var data = JSON.parse(data)\n    data.name = info.projectName\n    data.author = info.author\n    data.version = info.version\n    var replaceData = JSON.stringify(data, null, 4)\n    fs.writeFile(path + '/package.json', replaceData, function (err) {\n      if (err) {\n        console.log(err)\n      }\n    })\n  })\n}\n```\n\n","source":"_posts/cli工具之init.md","raw":"---\ntitle: cli工具之init\ndate: 2019-10-19 16:11:11\ncategories: node相关\ntags:\n  - node\n  - fet源码\n  - cli工具\n---\n\n了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。\n\n<!--more-->\n\n了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。\n\n`init`命令通常都具备以下几个功能：\n\n* 可交互\n* 远程拉取项目到本地\n* 可修改package.json中的项目名版本号等信息\n\n那么，如何实现呢？\n\n## inquirer\n\n[inquirer](https://github.com/SBoudrias/Inquirer.js/#examples)是nodejs的交互式命令行工具，通过该插件我们可以完成终端上的交互。\n\n### 使用方法\n\n```js\ninquirer\n  .prompt([\n    {\n      type: 'input', // 交互方式，input、confirm等\n      name: 'projectName', // 用来存输入结果的字段名\n      message: 'project name:', // 提示输入信息\n      default: 'template' // 默认值\n    }\n  ])\n  .then((answers) => {\n    console.log(answers)\n  })\n```\n你将看到的交互效果：\n![](https://my-image-1300309047.cos.ap-chengdu.myqcloud.com/my_blog/cmd-4.png)\n\n## download-git-repo\n\n[download-git-repo](https://www.npmjs.com/package/download-git-repo)是将远程仓库（如GitHub, GitLab, Bitbucket）的项目下载到本地的命令行工具。\n\n### 使用方法\n\n```js\n// 从github下载\ndownload(repositoryName, projectName, function (err) {\n  console.log(err ? 'Error' : 'Success')\n})\n```\n\n## 修改package.json\n\n这里我们使用nodejs的fs模块所提供的方法来实现，代码如下：\n\n```js\nfunction edit (info, path) {\n  fs.readFile(path + '/package.json', function (err, data) {\n    if (err) {\n      console.log(err)\n      return\n    }\n    var data = JSON.parse(data)\n    data.name = info.projectName\n    data.author = info.author\n    data.version = info.version\n    var replaceData = JSON.stringify(data, null, 4)\n    fs.writeFile(path + '/package.json', replaceData, function (err) {\n      if (err) {\n        console.log(err)\n      }\n    })\n  })\n}\n```\n\n## 完整代码\n\n```js\nvar program = require('commander')\nvar ora = require('ora') //ora 一个命令行loading效果\nvar inquirer = require('inquirer') // 命令行交互\nvar download = require('download-git-repo') // github api用来下载github的模板\nvar fs = require('fs')\n\nprogram\n  .command('init [projectName]') // 设置指令\n  .description('init project')\n  .action(function (projectName, opts) { // 执行操作\n    var loading = ora('fetching template......')\n    inquirer\n      .prompt([\n        {\n          type: 'input',\n          name: 'projectName',\n          message: '项目名称',\n          default: projectName || 'template'\n        },\n        {\n          type: 'input',\n          name: 'author',\n          message: '作者'\n        },\n        {\n          type: 'input',\n          name: 'version',\n          message: '版本',\n          default: '0.1.0'\n        }\n      ])\n      .then(function (answers) {\n        var repository = 'Yx1aoq1/vue-template'\n        var project = answers.projectName\n        loading.start()\n        download(repository, project, function (err) {\n          if (err) {\n            console.log(err)\n            return\n          }\n          var path = process.cwd() + '\\/' + project\n          edit(answers, path)\n          console.log(path)\n          loading.succeed()\n        })\n      })\n  })\n\nfunction edit (info, path) {\n  fs.readFile(path + '/package.json', function (err, data) {\n    if (err) {\n      console.log(err)\n      return\n    }\n    var data = JSON.parse(data)\n    data.name = info.projectName\n    data.author = info.author\n    data.version = info.version\n    var replaceData = JSON.stringify(data, null, 4)\n    fs.writeFile(path + '/package.json', replaceData, function (err) {\n      if (err) {\n        console.log(err)\n      }\n    })\n  })\n}\n```\n\n","slug":"cli工具之init","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7z000jfr038ax06hlq","content":"<p>了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。</p>\n<a id=\"more\"></a>\n<p>了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。</p>\n<p><code>init</code>命令通常都具备以下几个功能：</p>\n<ul>\n<li>可交互</li>\n<li>远程拉取项目到本地</li>\n<li>可修改package.json中的项目名版本号等信息</li>\n</ul>\n<p>那么，如何实现呢？</p>\n<h2 id=\"inquirer\"><a href=\"#inquirer\" class=\"headerlink\" title=\"inquirer\"></a>inquirer</h2><p><a href=\"https://github.com/SBoudrias/Inquirer.js/#examples\" target=\"_blank\" rel=\"noopener\">inquirer</a>是nodejs的交互式命令行工具，通过该插件我们可以完成终端上的交互。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inquirer</span><br><span class=\"line\">  .prompt([</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'input'</span>, <span class=\"comment\">// 交互方式，input、confirm等</span></span><br><span class=\"line\">      name: <span class=\"string\">'projectName'</span>, <span class=\"comment\">// 用来存输入结果的字段名</span></span><br><span class=\"line\">      message: <span class=\"string\">'project name:'</span>, <span class=\"comment\">// 提示输入信息</span></span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'template'</span> <span class=\"comment\">// 默认值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">answers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(answers)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>你将看到的交互效果：<br><img src=\"https://my-image-1300309047.cos.ap-chengdu.myqcloud.com/my_blog/cmd-4.png\" alt></p>\n<h2 id=\"download-git-repo\"><a href=\"#download-git-repo\" class=\"headerlink\" title=\"download-git-repo\"></a>download-git-repo</h2><p><a href=\"https://www.npmjs.com/package/download-git-repo\" target=\"_blank\" rel=\"noopener\">download-git-repo</a>是将远程仓库（如GitHub, GitLab, Bitbucket）的项目下载到本地的命令行工具。</p>\n<h3 id=\"使用方法-1\"><a href=\"#使用方法-1\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从github下载</span></span><br><span class=\"line\">download(repositoryName, projectName, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err ? <span class=\"string\">'Error'</span> : <span class=\"string\">'Success'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改package-json\"><a href=\"#修改package-json\" class=\"headerlink\" title=\"修改package.json\"></a>修改package.json</h2><p>这里我们使用nodejs的fs模块所提供的方法来实现，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">edit</span> (<span class=\"params\">info, path</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(path + <span class=\"string\">'/package.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data)</span><br><span class=\"line\">    data.name = info.projectName</span><br><span class=\"line\">    data.author = info.author</span><br><span class=\"line\">    data.version = info.version</span><br><span class=\"line\">    <span class=\"keyword\">var</span> replaceData = <span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    fs.writeFile(path + <span class=\"string\">'/package.json'</span>, replaceData, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> program = <span class=\"built_in\">require</span>(<span class=\"string\">'commander'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> ora = <span class=\"built_in\">require</span>(<span class=\"string\">'ora'</span>) <span class=\"comment\">//ora 一个命令行loading效果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> inquirer = <span class=\"built_in\">require</span>(<span class=\"string\">'inquirer'</span>) <span class=\"comment\">// 命令行交互</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> download = <span class=\"built_in\">require</span>(<span class=\"string\">'download-git-repo'</span>) <span class=\"comment\">// github api用来下载github的模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .command(<span class=\"string\">'init [projectName]'</span>) <span class=\"comment\">// 设置指令</span></span><br><span class=\"line\">  .description(<span class=\"string\">'init project'</span>)</span><br><span class=\"line\">  .action(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">projectName, opts</span>) </span>&#123; <span class=\"comment\">// 执行操作</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> loading = ora(<span class=\"string\">'fetching template......'</span>)</span><br><span class=\"line\">    inquirer</span><br><span class=\"line\">      .prompt([</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          type: <span class=\"string\">'input'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'projectName'</span>,</span><br><span class=\"line\">          message: <span class=\"string\">'项目名称'</span>,</span><br><span class=\"line\">          <span class=\"keyword\">default</span>: projectName || <span class=\"string\">'template'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          type: <span class=\"string\">'input'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'author'</span>,</span><br><span class=\"line\">          message: <span class=\"string\">'作者'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          type: <span class=\"string\">'input'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'version'</span>,</span><br><span class=\"line\">          message: <span class=\"string\">'版本'</span>,</span><br><span class=\"line\">          <span class=\"keyword\">default</span>: <span class=\"string\">'0.1.0'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ])</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">answers</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> repository = <span class=\"string\">'Yx1aoq1/vue-template'</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> project = answers.projectName</span><br><span class=\"line\">        loading.start()</span><br><span class=\"line\">        download(repository, project, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> path = process.cwd() + <span class=\"string\">'\\/'</span> + project</span><br><span class=\"line\">          edit(answers, path)</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(path)</span><br><span class=\"line\">          loading.succeed()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">edit</span> (<span class=\"params\">info, path</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(path + <span class=\"string\">'/package.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data)</span><br><span class=\"line\">    data.name = info.projectName</span><br><span class=\"line\">    data.author = info.author</span><br><span class=\"line\">    data.version = info.version</span><br><span class=\"line\">    <span class=\"keyword\">var</span> replaceData = <span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    fs.writeFile(path + <span class=\"string\">'/package.json'</span>, replaceData, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。</p>","more":"<p>了解了命令行工具开发的基本操作后，继续来逐一解析各个指令的实现方式。首先从最简单的init下手。</p>\n<p><code>init</code>命令通常都具备以下几个功能：</p>\n<ul>\n<li>可交互</li>\n<li>远程拉取项目到本地</li>\n<li>可修改package.json中的项目名版本号等信息</li>\n</ul>\n<p>那么，如何实现呢？</p>\n<h2 id=\"inquirer\"><a href=\"#inquirer\" class=\"headerlink\" title=\"inquirer\"></a>inquirer</h2><p><a href=\"https://github.com/SBoudrias/Inquirer.js/#examples\" target=\"_blank\" rel=\"noopener\">inquirer</a>是nodejs的交互式命令行工具，通过该插件我们可以完成终端上的交互。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inquirer</span><br><span class=\"line\">  .prompt([</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'input'</span>, <span class=\"comment\">// 交互方式，input、confirm等</span></span><br><span class=\"line\">      name: <span class=\"string\">'projectName'</span>, <span class=\"comment\">// 用来存输入结果的字段名</span></span><br><span class=\"line\">      message: <span class=\"string\">'project name:'</span>, <span class=\"comment\">// 提示输入信息</span></span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'template'</span> <span class=\"comment\">// 默认值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">answers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(answers)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>你将看到的交互效果：<br><img src=\"https://my-image-1300309047.cos.ap-chengdu.myqcloud.com/my_blog/cmd-4.png\" alt></p>\n<h2 id=\"download-git-repo\"><a href=\"#download-git-repo\" class=\"headerlink\" title=\"download-git-repo\"></a>download-git-repo</h2><p><a href=\"https://www.npmjs.com/package/download-git-repo\" target=\"_blank\" rel=\"noopener\">download-git-repo</a>是将远程仓库（如GitHub, GitLab, Bitbucket）的项目下载到本地的命令行工具。</p>\n<h3 id=\"使用方法-1\"><a href=\"#使用方法-1\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从github下载</span></span><br><span class=\"line\">download(repositoryName, projectName, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err ? <span class=\"string\">'Error'</span> : <span class=\"string\">'Success'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改package-json\"><a href=\"#修改package-json\" class=\"headerlink\" title=\"修改package.json\"></a>修改package.json</h2><p>这里我们使用nodejs的fs模块所提供的方法来实现，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">edit</span> (<span class=\"params\">info, path</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(path + <span class=\"string\">'/package.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data)</span><br><span class=\"line\">    data.name = info.projectName</span><br><span class=\"line\">    data.author = info.author</span><br><span class=\"line\">    data.version = info.version</span><br><span class=\"line\">    <span class=\"keyword\">var</span> replaceData = <span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    fs.writeFile(path + <span class=\"string\">'/package.json'</span>, replaceData, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> program = <span class=\"built_in\">require</span>(<span class=\"string\">'commander'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> ora = <span class=\"built_in\">require</span>(<span class=\"string\">'ora'</span>) <span class=\"comment\">//ora 一个命令行loading效果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> inquirer = <span class=\"built_in\">require</span>(<span class=\"string\">'inquirer'</span>) <span class=\"comment\">// 命令行交互</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> download = <span class=\"built_in\">require</span>(<span class=\"string\">'download-git-repo'</span>) <span class=\"comment\">// github api用来下载github的模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .command(<span class=\"string\">'init [projectName]'</span>) <span class=\"comment\">// 设置指令</span></span><br><span class=\"line\">  .description(<span class=\"string\">'init project'</span>)</span><br><span class=\"line\">  .action(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">projectName, opts</span>) </span>&#123; <span class=\"comment\">// 执行操作</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> loading = ora(<span class=\"string\">'fetching template......'</span>)</span><br><span class=\"line\">    inquirer</span><br><span class=\"line\">      .prompt([</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          type: <span class=\"string\">'input'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'projectName'</span>,</span><br><span class=\"line\">          message: <span class=\"string\">'项目名称'</span>,</span><br><span class=\"line\">          <span class=\"keyword\">default</span>: projectName || <span class=\"string\">'template'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          type: <span class=\"string\">'input'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'author'</span>,</span><br><span class=\"line\">          message: <span class=\"string\">'作者'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          type: <span class=\"string\">'input'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'version'</span>,</span><br><span class=\"line\">          message: <span class=\"string\">'版本'</span>,</span><br><span class=\"line\">          <span class=\"keyword\">default</span>: <span class=\"string\">'0.1.0'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ])</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">answers</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> repository = <span class=\"string\">'Yx1aoq1/vue-template'</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> project = answers.projectName</span><br><span class=\"line\">        loading.start()</span><br><span class=\"line\">        download(repository, project, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> path = process.cwd() + <span class=\"string\">'\\/'</span> + project</span><br><span class=\"line\">          edit(answers, path)</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(path)</span><br><span class=\"line\">          loading.succeed()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">edit</span> (<span class=\"params\">info, path</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(path + <span class=\"string\">'/package.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data)</span><br><span class=\"line\">    data.name = info.projectName</span><br><span class=\"line\">    data.author = info.author</span><br><span class=\"line\">    data.version = info.version</span><br><span class=\"line\">    <span class=\"keyword\">var</span> replaceData = <span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    fs.writeFile(path + <span class=\"string\">'/package.json'</span>, replaceData, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iconfont使用方法","date":"2017-03-26T01:12:56.000Z","_content":"实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","source":"_posts/iconfont使用方法.md","raw":"---\ntitle: iconfont使用方法\ndate: 2017-03-26 09:12:56\ncategories: 知识碎片\ntags:\n  - iconfont\n---\n实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","slug":"iconfont使用方法","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl7z000kfr03ydugt7n9","content":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt></p>\n<a id=\"more\"></a>\n<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt></p>\n<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </span><br><span class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>\n","site":{"data":{}},"excerpt":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt></p>","more":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt></p>\n<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </span><br><span class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>"},{"title":"vuex的学习整理","date":"2019-05-09T12:22:24.000Z","_content":"## Vuex是什么\n> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n<!-- more -->\n\n## Vuex是什么\n> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n上面是copy自官方的解释，在我的理解看来，vuex相当于复杂版的evenBus，管理项目中一些各个地方都需要使用到的数据，各个地方可能触发的事件。\n\n## 示例\n先写一个十分简单的vuex\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: 'todo one', done: true },\n      { id: 2, text: 'todo two', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  },\n  mutations: {\n    setTodoDone (state, index) {\n      state.todos[index].done = true\n    }\n  },\n  actions: {\n    setTodoDoneAfterTime (state, time) {\n      setTimeout(() => {\n        state.todos.map(todo => {\n          todo.done = true\n        })\n      }, time)\n    }\n  }\n})\n\nstore.commit('setTodoDone', 2) // 触发 mutations\nstore.dispatch('setTodoDoneAfterTime', 1000) // 触发 actions\n```\n\n## 核心概念\n### State\n存储状态数据，每次变化时可以触发vue的computed，并触发更新相关联的DOM\n```js\nexport default {\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n但是如果每次取值都要通过声明一个计算属性，那未免也太过麻烦了，所以vuex提供了一个简便的方法`mapState`\n```js\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组\n```js\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n```\n\n### Getter\n类似于vue中的computed，获取从store中派生出的一些状态，例如对列表进行过滤并计数，并且与computed一样可以缓存状态的变化\n同样，在获取getters时也有一个简便的方法`mapGetters`\n```js\nimport { mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```js\nmapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n### Mutation\n更改store中状态的唯一方法就是提交mutation，mutation其实就类似与事件的触发\n**注意点：**\n* 对象添加新属性时和vue中一样，必须使用set方法才能触发更新，或者使用新对象替换老对象\n\n```js\nstate.obj = {...state.obj, newProp: 123}\n```\n\n* 使用常量替代Mutation事件类型\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```js\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n* Mutation 必须是同步函数\n* 辅助函数 `mapMutations`\n\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n### Actions\nAction 类似于 mutation，不同在于：\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意异步操作。\n* `mapActions`\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n### Module\n对复杂的store对象进行模块的划分\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n**注意点：**\n* 默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。\n\n```js\n// 触发绑定命名空间的state mapGetters等函数时\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n","source":"_posts/vuex的学习整理.md","raw":"---\ntitle: vuex的学习整理\ndate: 2019-05-09 20:22:24\ncategories: Vue相关\ntags:\n  - Vuex\n---\n## Vuex是什么\n> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n<!-- more -->\n\n## Vuex是什么\n> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n上面是copy自官方的解释，在我的理解看来，vuex相当于复杂版的evenBus，管理项目中一些各个地方都需要使用到的数据，各个地方可能触发的事件。\n\n## 示例\n先写一个十分简单的vuex\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: 'todo one', done: true },\n      { id: 2, text: 'todo two', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  },\n  mutations: {\n    setTodoDone (state, index) {\n      state.todos[index].done = true\n    }\n  },\n  actions: {\n    setTodoDoneAfterTime (state, time) {\n      setTimeout(() => {\n        state.todos.map(todo => {\n          todo.done = true\n        })\n      }, time)\n    }\n  }\n})\n\nstore.commit('setTodoDone', 2) // 触发 mutations\nstore.dispatch('setTodoDoneAfterTime', 1000) // 触发 actions\n```\n\n## 核心概念\n### State\n存储状态数据，每次变化时可以触发vue的computed，并触发更新相关联的DOM\n```js\nexport default {\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n但是如果每次取值都要通过声明一个计算属性，那未免也太过麻烦了，所以vuex提供了一个简便的方法`mapState`\n```js\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组\n```js\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n```\n\n### Getter\n类似于vue中的computed，获取从store中派生出的一些状态，例如对列表进行过滤并计数，并且与computed一样可以缓存状态的变化\n同样，在获取getters时也有一个简便的方法`mapGetters`\n```js\nimport { mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```js\nmapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n### Mutation\n更改store中状态的唯一方法就是提交mutation，mutation其实就类似与事件的触发\n**注意点：**\n* 对象添加新属性时和vue中一样，必须使用set方法才能触发更新，或者使用新对象替换老对象\n\n```js\nstate.obj = {...state.obj, newProp: 123}\n```\n\n* 使用常量替代Mutation事件类型\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```js\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n* Mutation 必须是同步函数\n* 辅助函数 `mapMutations`\n\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n### Actions\nAction 类似于 mutation，不同在于：\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意异步操作。\n* `mapActions`\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n### Module\n对复杂的store对象进行模块的划分\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n**注意点：**\n* 默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。\n\n```js\n// 触发绑定命名空间的state mapGetters等函数时\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n","slug":"vuex的学习整理","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl80000lfr03qzvx8aor","content":"<h2 id=\"Vuex是什么\"><a href=\"#Vuex是什么\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h2><blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Vuex是什么-1\"><a href=\"#Vuex是什么-1\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h2><blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n</blockquote>\n<p>上面是copy自官方的解释，在我的理解看来，vuex相当于复杂版的evenBus，管理项目中一些各个地方都需要使用到的数据，各个地方可能触发的事件。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>先写一个十分简单的vuex<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'todo one'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'todo two'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    doneTodos: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    setTodoDone (state, index) &#123;</span><br><span class=\"line\">      state.todos[index].done = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    setTodoDoneAfterTime (state, time) &#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        state.todos.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> &#123;</span><br><span class=\"line\">          todo.done = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.commit(<span class=\"string\">'setTodoDone'</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 触发 mutations</span></span><br><span class=\"line\">store.dispatch(<span class=\"string\">'setTodoDoneAfterTime'</span>, <span class=\"number\">1000</span>) <span class=\"comment\">// 触发 actions</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>存储状态数据，每次变化时可以触发vue的computed，并触发更新相关联的DOM<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是如果每次取值都要通过声明一个计算属性，那未免也太过麻烦了，所以vuex提供了一个简便的方法<code>mapState</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可使代码更简练</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">    countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class=\"line\">    countPlusLocalState (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.count 为 store.state.count</span></span><br><span class=\"line\">  <span class=\"string\">'count'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h3><p>类似于vue中的computed，获取从store中派生出的一些状态，例如对列表进行过滤并计数，并且与computed一样可以缓存状态的变化<br>同样，在获取getters时也有一个简便的方法<code>mapGetters</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\">      <span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class=\"line\">  doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><p>更改store中状态的唯一方法就是提交mutation，mutation其实就类似与事件的触发<br><strong>注意点：</strong></p>\n<ul>\n<li>对象添加新属性时和vue中一样，必须使用set方法才能触发更新，或者使用新对象替换老对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state.obj = &#123;...state.obj, <span class=\"attr\">newProp</span>: <span class=\"number\">123</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用常量替代Mutation事件类型</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mutation-types.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SOME_MUTATION = <span class=\"string\">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; SOME_MUTATION &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mutation-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class=\"line\">    [SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// mutate state</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Mutation 必须是同步函数</li>\n<li>辅助函数 <code>mapMutations</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span>, <span class=\"comment\">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// `mapMutations` 也支持载荷：</span></span><br><span class=\"line\">      <span class=\"string\">'incrementBy'</span> <span class=\"comment\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n<li><code>mapActions</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span>, <span class=\"comment\">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// `mapActions` 也支持载荷：</span></span><br><span class=\"line\">      <span class=\"string\">'incrementBy'</span> <span class=\"comment\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>对复杂的store对象进行模块的划分<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意点：</strong></p>\n<ul>\n<li>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发绑定命名空间的state mapGetters等函数时</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  ...mapState(<span class=\"string\">'some/nested/module'</span>, &#123;</span><br><span class=\"line\">    a: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.a,</span><br><span class=\"line\">    b: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.b</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapActions(<span class=\"string\">'some/nested/module'</span>, [</span><br><span class=\"line\">    <span class=\"string\">'foo'</span>, <span class=\"comment\">// -&gt; this.foo()</span></span><br><span class=\"line\">    <span class=\"string\">'bar'</span> <span class=\"comment\">// -&gt; this.bar()</span></span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Vuex是什么\"><a href=\"#Vuex是什么\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h2><blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n</blockquote>","more":"<h2 id=\"Vuex是什么-1\"><a href=\"#Vuex是什么-1\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h2><blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n</blockquote>\n<p>上面是copy自官方的解释，在我的理解看来，vuex相当于复杂版的evenBus，管理项目中一些各个地方都需要使用到的数据，各个地方可能触发的事件。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>先写一个十分简单的vuex<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'todo one'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'todo two'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    doneTodos: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    setTodoDone (state, index) &#123;</span><br><span class=\"line\">      state.todos[index].done = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    setTodoDoneAfterTime (state, time) &#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        state.todos.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> &#123;</span><br><span class=\"line\">          todo.done = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.commit(<span class=\"string\">'setTodoDone'</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 触发 mutations</span></span><br><span class=\"line\">store.dispatch(<span class=\"string\">'setTodoDoneAfterTime'</span>, <span class=\"number\">1000</span>) <span class=\"comment\">// 触发 actions</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>存储状态数据，每次变化时可以触发vue的computed，并触发更新相关联的DOM<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是如果每次取值都要通过声明一个计算属性，那未免也太过麻烦了，所以vuex提供了一个简便的方法<code>mapState</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可使代码更简练</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">    countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class=\"line\">    countPlusLocalState (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.count 为 store.state.count</span></span><br><span class=\"line\">  <span class=\"string\">'count'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h3><p>类似于vue中的computed，获取从store中派生出的一些状态，例如对列表进行过滤并计数，并且与computed一样可以缓存状态的变化<br>同样，在获取getters时也有一个简便的方法<code>mapGetters</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\">      <span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class=\"line\">  doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><p>更改store中状态的唯一方法就是提交mutation，mutation其实就类似与事件的触发<br><strong>注意点：</strong></p>\n<ul>\n<li>对象添加新属性时和vue中一样，必须使用set方法才能触发更新，或者使用新对象替换老对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state.obj = &#123;...state.obj, <span class=\"attr\">newProp</span>: <span class=\"number\">123</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用常量替代Mutation事件类型</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mutation-types.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SOME_MUTATION = <span class=\"string\">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; SOME_MUTATION &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mutation-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class=\"line\">    [SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// mutate state</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Mutation 必须是同步函数</li>\n<li>辅助函数 <code>mapMutations</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span>, <span class=\"comment\">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// `mapMutations` 也支持载荷：</span></span><br><span class=\"line\">      <span class=\"string\">'incrementBy'</span> <span class=\"comment\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n<li><code>mapActions</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span>, <span class=\"comment\">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// `mapActions` 也支持载荷：</span></span><br><span class=\"line\">      <span class=\"string\">'incrementBy'</span> <span class=\"comment\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>对复杂的store对象进行模块的划分<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意点：</strong></p>\n<ul>\n<li>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发绑定命名空间的state mapGetters等函数时</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  ...mapState(<span class=\"string\">'some/nested/module'</span>, &#123;</span><br><span class=\"line\">    a: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.a,</span><br><span class=\"line\">    b: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.b</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapActions(<span class=\"string\">'some/nested/module'</span>, [</span><br><span class=\"line\">    <span class=\"string\">'foo'</span>, <span class=\"comment\">// -&gt; this.foo()</span></span><br><span class=\"line\">    <span class=\"string\">'bar'</span> <span class=\"comment\">// -&gt; this.bar()</span></span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"关于HTTP请求小记","date":"2017-03-20T07:31:38.000Z","_content":"* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","source":"_posts/关于HTTP请求小记.md","raw":"---\ntitle: 关于HTTP请求小记\ndate: 2017-03-20 15:31:38\ncategories: 知识碎片\ntags: \n  - HTTP\n  - 网络\n---\n* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","slug":"关于HTTP请求小记","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl81000mfr03jgrqzolh","content":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><p><strong>步骤：</strong></p>\n<ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /login.php HTTP/1.1 //请求地址</span><br><span class=\"line\"></span><br><span class=\"line\">//请求头</span><br><span class=\"line\"><span class=\"attribute\">Host:localhost</span></span><br><span class=\"line\"><span class=\"attribute\">Connection:keep-alive</span></span><br><span class=\"line\"><span class=\"attribute\">Accept:text/javascript,application/javascript,application/ecmascript,</span></span><br><span class=\"line\"><span class=\"attribute\">application/x-ecmascript,*/*;</span></span><br><span class=\"line\">q=0.01</span><br><span class=\"line\"><span class=\"attribute\">X-Requested-With:XMLHttpRequest</span></span><br><span class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</span><br><span class=\"line\"><span class=\"attribute\">Accept-Encoding:gzip,deflate,sdch</span></span><br><span class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</span><br><span class=\"line\"></span><br><span class=\"line\">//请求体</span><br><span class=\"line\">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server:Apache</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding:gzip</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Length:7112</span></span><br><span class=\"line\"><span class=\"attribute\">Connection:Keep-Alive</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type:application/javascript</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><p><strong>步骤：</strong></p>\n<ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /login.php HTTP/1.1 //请求地址</span><br><span class=\"line\"></span><br><span class=\"line\">//请求头</span><br><span class=\"line\"><span class=\"attribute\">Host:localhost</span></span><br><span class=\"line\"><span class=\"attribute\">Connection:keep-alive</span></span><br><span class=\"line\"><span class=\"attribute\">Accept:text/javascript,application/javascript,application/ecmascript,</span></span><br><span class=\"line\"><span class=\"attribute\">application/x-ecmascript,*/*;</span></span><br><span class=\"line\">q=0.01</span><br><span class=\"line\"><span class=\"attribute\">X-Requested-With:XMLHttpRequest</span></span><br><span class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</span><br><span class=\"line\"><span class=\"attribute\">Accept-Encoding:gzip,deflate,sdch</span></span><br><span class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</span><br><span class=\"line\"></span><br><span class=\"line\">//请求体</span><br><span class=\"line\">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server:Apache</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding:gzip</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Length:7112</span></span><br><span class=\"line\"><span class=\"attribute\">Connection:Keep-Alive</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type:application/javascript</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>"},{"title":"如何开发命令行工具","date":"2019-06-04T14:46:00.000Z","_content":"\n这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于`node`和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。\n\n<!--more-->\n\n这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于`node`和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。\n\n## 原理\n\n在`node`中，有一个变量叫做`process`的全局变量，当启动一个 Node.js 进程时，我们可以通过`process.argv`获得传入的命令行参数。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-1.png)\n其中：\n* `argv[0]`为[`process.execPath`](http://nodejs.cn/s/MCrAya)\n* `argv[1]`为正在执行 JavaScript 文件的路径\n* 其余元素是任何其他命令行参数\n\n通过解析`process.argv`，我们就可以执行不同的操作。\n\n##  commander.js\n\n我们可以引用`commander.js`，让命令行变得更加简单。\n下面简单示例一个图片重命名的node实现。\n```js\nvar program = require('commander')\nvar fs = require('fs')\nvar path = './'\n\nprogram\n  .version('0.0.1')\n  .description('a test cli program')\n\nprogram\n  .command('rename <format>') // 设置指令\n  .option('-n, --number <number>', '设置rename数字，默认从1开始', 1) // 设置参数\n  .option('-a, --after', '将fomat字符固定在数字后，默认在前')\n  .action(function (format, opts) { // 执行操作\n    fs.readdir(path, function(err, files) {\n      files.map(function(filename) {\n        var extname = getExtname(filename)\n        if (isImage(extname)) {\n          var newname = getNewName(format, opts, extname)\n          fs.rename(filename, newname, function(err) {\n            console.log(filename + ' --> ' + newname)\n          })\n        }\n      })\n    })\n  })\n\nprogram.parse(process.argv)\n\nfunction isImage (extname) {\n  var imageTypes = ['webp', 'png', 'svg', 'gif', 'jpg', 'jpeg', 'bmp']\n  return imageTypes.includes(extname)\n}\n\nfunction getExtname (filename) {\n  var filenameWithoutSuffix = filename.split(/#|\\?/)[0]\n  return (/[^./\\\\]*$/.exec(filenameWithoutSuffix) || [''])[0]\n}\n\nfunction getNewName (format, opts, extname) {\n  return opts.after\n         ? (opts.number ++) + format + '.' + extname\n         : format + (opts.number ++) + '.' + extname\n}\n```\n\n运行结果如图所示：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-2.png)\n\n## 如何挂载到`npm`上\n\n虽然已经有这个效果，但是`rename.js`能做的也只是将它所在文件夹地下的文件进行重命名，但我们实际的情况是，想在某个文件夹底下执行`rename xxx`的命令，而不是将`rename.js`搬来搬去。因此，我们可以将这个命令通过`npm link`挂到`npm`上。\n\n我们通过`npm init`生成`package.json`文件，并增加一个`bin`的字段来定义我们的指令开头：\n\n```json\n{\n  \"name\": \"cmd-test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"node图片重命名命令行工具\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"bin\": {\n    \"mycmd\": \"./index.js\"\n  },\n  \"author\": \"yx1aoq1\",\n  \"license\": \"ISC\"\n}\n```\n## 设置入口文件，并在入口文件开头写上`#! /usr/bin/env node`\n\n```js\n#! /usr/bin/env node\n\nrequire('../rename.js');\n```\n\n在执行了`npm link`之后，就可以看到，我们的命令已经可以起作用了。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-3.png)\n\n\n\n\n","source":"_posts/如何开发命令行工具.md","raw":"title: 如何开发命令行工具\ncategories:\n  - node相关\ntags:\n  - node\n  - fet源码\n  - cli工具\ndate: 2019-06-04 22:46:00\n---\n\n这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于`node`和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。\n\n<!--more-->\n\n这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于`node`和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。\n\n## 原理\n\n在`node`中，有一个变量叫做`process`的全局变量，当启动一个 Node.js 进程时，我们可以通过`process.argv`获得传入的命令行参数。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-1.png)\n其中：\n* `argv[0]`为[`process.execPath`](http://nodejs.cn/s/MCrAya)\n* `argv[1]`为正在执行 JavaScript 文件的路径\n* 其余元素是任何其他命令行参数\n\n通过解析`process.argv`，我们就可以执行不同的操作。\n\n##  commander.js\n\n我们可以引用`commander.js`，让命令行变得更加简单。\n下面简单示例一个图片重命名的node实现。\n```js\nvar program = require('commander')\nvar fs = require('fs')\nvar path = './'\n\nprogram\n  .version('0.0.1')\n  .description('a test cli program')\n\nprogram\n  .command('rename <format>') // 设置指令\n  .option('-n, --number <number>', '设置rename数字，默认从1开始', 1) // 设置参数\n  .option('-a, --after', '将fomat字符固定在数字后，默认在前')\n  .action(function (format, opts) { // 执行操作\n    fs.readdir(path, function(err, files) {\n      files.map(function(filename) {\n        var extname = getExtname(filename)\n        if (isImage(extname)) {\n          var newname = getNewName(format, opts, extname)\n          fs.rename(filename, newname, function(err) {\n            console.log(filename + ' --> ' + newname)\n          })\n        }\n      })\n    })\n  })\n\nprogram.parse(process.argv)\n\nfunction isImage (extname) {\n  var imageTypes = ['webp', 'png', 'svg', 'gif', 'jpg', 'jpeg', 'bmp']\n  return imageTypes.includes(extname)\n}\n\nfunction getExtname (filename) {\n  var filenameWithoutSuffix = filename.split(/#|\\?/)[0]\n  return (/[^./\\\\]*$/.exec(filenameWithoutSuffix) || [''])[0]\n}\n\nfunction getNewName (format, opts, extname) {\n  return opts.after\n         ? (opts.number ++) + format + '.' + extname\n         : format + (opts.number ++) + '.' + extname\n}\n```\n\n运行结果如图所示：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-2.png)\n\n## 如何挂载到`npm`上\n\n虽然已经有这个效果，但是`rename.js`能做的也只是将它所在文件夹地下的文件进行重命名，但我们实际的情况是，想在某个文件夹底下执行`rename xxx`的命令，而不是将`rename.js`搬来搬去。因此，我们可以将这个命令通过`npm link`挂到`npm`上。\n\n我们通过`npm init`生成`package.json`文件，并增加一个`bin`的字段来定义我们的指令开头：\n\n```json\n{\n  \"name\": \"cmd-test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"node图片重命名命令行工具\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"bin\": {\n    \"mycmd\": \"./index.js\"\n  },\n  \"author\": \"yx1aoq1\",\n  \"license\": \"ISC\"\n}\n```\n## 设置入口文件，并在入口文件开头写上`#! /usr/bin/env node`\n\n```js\n#! /usr/bin/env node\n\nrequire('../rename.js');\n```\n\n在执行了`npm link`之后，就可以看到，我们的命令已经可以起作用了。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-3.png)\n\n\n\n\n","slug":"如何开发命令行工具","published":1,"updated":"2020-01-08T14:07:11.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl81000nfr03ss3uz4t8","content":"<p>这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于<code>node</code>和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。</p>\n<a id=\"more\"></a>\n<p>这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于<code>node</code>和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>在<code>node</code>中，有一个变量叫做<code>process</code>的全局变量，当启动一个 Node.js 进程时，我们可以通过<code>process.argv</code>获得传入的命令行参数。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-1.png\" alt><br>其中：</p>\n<ul>\n<li><code>argv[0]</code>为<a href=\"http://nodejs.cn/s/MCrAya\" target=\"_blank\" rel=\"noopener\"><code>process.execPath</code></a></li>\n<li><code>argv[1]</code>为正在执行 JavaScript 文件的路径</li>\n<li>其余元素是任何其他命令行参数</li>\n</ul>\n<p>通过解析<code>process.argv</code>，我们就可以执行不同的操作。</p>\n<h2 id=\"commander-js\"><a href=\"#commander-js\" class=\"headerlink\" title=\"commander.js\"></a>commander.js</h2><p>我们可以引用<code>commander.js</code>，让命令行变得更加简单。<br>下面简单示例一个图片重命名的node实现。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> program = <span class=\"built_in\">require</span>(<span class=\"string\">'commander'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">'./'</span></span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .version(<span class=\"string\">'0.0.1'</span>)</span><br><span class=\"line\">  .description(<span class=\"string\">'a test cli program'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .command(<span class=\"string\">'rename &lt;format&gt;'</span>) <span class=\"comment\">// 设置指令</span></span><br><span class=\"line\">  .option(<span class=\"string\">'-n, --number &lt;number&gt;'</span>, <span class=\"string\">'设置rename数字，默认从1开始'</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">  .option(<span class=\"string\">'-a, --after'</span>, <span class=\"string\">'将fomat字符固定在数字后，默认在前'</span>)</span><br><span class=\"line\">  .action(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">format, opts</span>) </span>&#123; <span class=\"comment\">// 执行操作</span></span><br><span class=\"line\">    fs.readdir(path, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>) </span>&#123;</span><br><span class=\"line\">      files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> extname = getExtname(filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isImage(extname)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> newname = getNewName(format, opts, extname)</span><br><span class=\"line\">          fs.rename(filename, newname, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(filename + <span class=\"string\">' --&gt; '</span> + newname)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">program.parse(process.argv)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isImage</span> (<span class=\"params\">extname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imageTypes = [<span class=\"string\">'webp'</span>, <span class=\"string\">'png'</span>, <span class=\"string\">'svg'</span>, <span class=\"string\">'gif'</span>, <span class=\"string\">'jpg'</span>, <span class=\"string\">'jpeg'</span>, <span class=\"string\">'bmp'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> imageTypes.includes(extname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getExtname</span> (<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> filenameWithoutSuffix = filename.split(<span class=\"regexp\">/#|\\?/</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"regexp\">/[^./\\\\]*$/</span>.exec(filenameWithoutSuffix) || [<span class=\"string\">''</span>])[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewName</span> (<span class=\"params\">format, opts, extname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> opts.after</span><br><span class=\"line\">         ? (opts.number ++) + format + <span class=\"string\">'.'</span> + extname</span><br><span class=\"line\">         : format + (opts.number ++) + <span class=\"string\">'.'</span> + extname</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如图所示：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-2.png\" alt></p>\n<h2 id=\"如何挂载到npm上\"><a href=\"#如何挂载到npm上\" class=\"headerlink\" title=\"如何挂载到npm上\"></a>如何挂载到<code>npm</code>上</h2><p>虽然已经有这个效果，但是<code>rename.js</code>能做的也只是将它所在文件夹地下的文件进行重命名，但我们实际的情况是，想在某个文件夹底下执行<code>rename xxx</code>的命令，而不是将<code>rename.js</code>搬来搬去。因此，我们可以将这个命令通过<code>npm link</code>挂到<code>npm</code>上。</p>\n<p>我们通过<code>npm init</code>生成<code>package.json</code>文件，并增加一个<code>bin</code>的字段来定义我们的指令开头：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"cmd-test\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"node图片重命名命令行工具\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"bin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"mycmd\"</span>: <span class=\"string\">\"./index.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"yx1aoq1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"license\"</span>: <span class=\"string\">\"ISC\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置入口文件，并在入口文件开头写上-usr-bin-env-node\"><a href=\"#设置入口文件，并在入口文件开头写上-usr-bin-env-node\" class=\"headerlink\" title=\"设置入口文件，并在入口文件开头写上#! /usr/bin/env node\"></a>设置入口文件，并在入口文件开头写上<code>#! /usr/bin/env node</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#! /usr/bin/env node</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'../rename.js'</span>);</span><br></pre></td></tr></table></figure>\n<p>在执行了<code>npm link</code>之后，就可以看到，我们的命令已经可以起作用了。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-3.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于<code>node</code>和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。</p>","more":"<p>这是基于新哥的脚手架工具fet源码阅读的学习笔记第一篇，主要内容是如何基于<code>node</code>和其他的一些工具包来完成一些简单的命令行小工具。主要实践为一个批量重命名的命令行工具（巨简单的那种），大概梳理流程和思路。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>在<code>node</code>中，有一个变量叫做<code>process</code>的全局变量，当启动一个 Node.js 进程时，我们可以通过<code>process.argv</code>获得传入的命令行参数。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-1.png\" alt><br>其中：</p>\n<ul>\n<li><code>argv[0]</code>为<a href=\"http://nodejs.cn/s/MCrAya\" target=\"_blank\" rel=\"noopener\"><code>process.execPath</code></a></li>\n<li><code>argv[1]</code>为正在执行 JavaScript 文件的路径</li>\n<li>其余元素是任何其他命令行参数</li>\n</ul>\n<p>通过解析<code>process.argv</code>，我们就可以执行不同的操作。</p>\n<h2 id=\"commander-js\"><a href=\"#commander-js\" class=\"headerlink\" title=\"commander.js\"></a>commander.js</h2><p>我们可以引用<code>commander.js</code>，让命令行变得更加简单。<br>下面简单示例一个图片重命名的node实现。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> program = <span class=\"built_in\">require</span>(<span class=\"string\">'commander'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">'./'</span></span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .version(<span class=\"string\">'0.0.1'</span>)</span><br><span class=\"line\">  .description(<span class=\"string\">'a test cli program'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .command(<span class=\"string\">'rename &lt;format&gt;'</span>) <span class=\"comment\">// 设置指令</span></span><br><span class=\"line\">  .option(<span class=\"string\">'-n, --number &lt;number&gt;'</span>, <span class=\"string\">'设置rename数字，默认从1开始'</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">  .option(<span class=\"string\">'-a, --after'</span>, <span class=\"string\">'将fomat字符固定在数字后，默认在前'</span>)</span><br><span class=\"line\">  .action(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">format, opts</span>) </span>&#123; <span class=\"comment\">// 执行操作</span></span><br><span class=\"line\">    fs.readdir(path, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>) </span>&#123;</span><br><span class=\"line\">      files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> extname = getExtname(filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isImage(extname)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> newname = getNewName(format, opts, extname)</span><br><span class=\"line\">          fs.rename(filename, newname, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(filename + <span class=\"string\">' --&gt; '</span> + newname)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">program.parse(process.argv)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isImage</span> (<span class=\"params\">extname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imageTypes = [<span class=\"string\">'webp'</span>, <span class=\"string\">'png'</span>, <span class=\"string\">'svg'</span>, <span class=\"string\">'gif'</span>, <span class=\"string\">'jpg'</span>, <span class=\"string\">'jpeg'</span>, <span class=\"string\">'bmp'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> imageTypes.includes(extname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getExtname</span> (<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> filenameWithoutSuffix = filename.split(<span class=\"regexp\">/#|\\?/</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"regexp\">/[^./\\\\]*$/</span>.exec(filenameWithoutSuffix) || [<span class=\"string\">''</span>])[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewName</span> (<span class=\"params\">format, opts, extname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> opts.after</span><br><span class=\"line\">         ? (opts.number ++) + format + <span class=\"string\">'.'</span> + extname</span><br><span class=\"line\">         : format + (opts.number ++) + <span class=\"string\">'.'</span> + extname</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如图所示：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-2.png\" alt></p>\n<h2 id=\"如何挂载到npm上\"><a href=\"#如何挂载到npm上\" class=\"headerlink\" title=\"如何挂载到npm上\"></a>如何挂载到<code>npm</code>上</h2><p>虽然已经有这个效果，但是<code>rename.js</code>能做的也只是将它所在文件夹地下的文件进行重命名，但我们实际的情况是，想在某个文件夹底下执行<code>rename xxx</code>的命令，而不是将<code>rename.js</code>搬来搬去。因此，我们可以将这个命令通过<code>npm link</code>挂到<code>npm</code>上。</p>\n<p>我们通过<code>npm init</code>生成<code>package.json</code>文件，并增加一个<code>bin</code>的字段来定义我们的指令开头：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"cmd-test\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"node图片重命名命令行工具\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"bin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"mycmd\"</span>: <span class=\"string\">\"./index.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"yx1aoq1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"license\"</span>: <span class=\"string\">\"ISC\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置入口文件，并在入口文件开头写上-usr-bin-env-node\"><a href=\"#设置入口文件，并在入口文件开头写上-usr-bin-env-node\" class=\"headerlink\" title=\"设置入口文件，并在入口文件开头写上#! /usr/bin/env node\"></a>设置入口文件，并在入口文件开头写上<code>#! /usr/bin/env node</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#! /usr/bin/env node</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'../rename.js'</span>);</span><br></pre></td></tr></table></figure>\n<p>在执行了<code>npm link</code>之后，就可以看到，我们的命令已经可以起作用了。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/ys-3.png\" alt></p>"},{"title":"异步编程之promise与trigger","date":"2017-07-15T08:13:01.000Z","_content":"这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n<!-- more -->\n\n这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","source":"_posts/异步编程之promise与trigger.md","raw":"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\ncategories: JS相关\ntags: \n  - JavaScript\n  - 异步\n---\n这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n<!-- more -->\n\n这周的学习任务：`promise`与`trigger`\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","slug":"异步编程之promise与trigger","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl86000ofr03wvghiaj3","content":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code></p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>这周的学习任务：<code>promise</code>与<code>trigger</code></p>\n<h2 id=\"异步编程-1\"><a href=\"#异步编程-1\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h3 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h3><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></span><br><span class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></span><br><span class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></span><br></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//f1执行代码</span></span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(f2);</span><br><span class=\"line\">f3();</span><br></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></span><br></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//f1执行代码</span></span><br><span class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</span><br></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//f1执行代码</span></span><br><span class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1().then(f2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</span><br><span class=\"line\">　<span class=\"comment\">// f1的任务代码</span></span><br><span class=\"line\">　dfd.resolve();</span><br><span class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h3 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h3><ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"test.html\"</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">      url: ...,</span><br><span class=\"line\">      success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">\"test.html\"</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  dosth();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h3><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code></p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>","more":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code></p>\n<h2 id=\"异步编程-1\"><a href=\"#异步编程-1\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h3 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h3><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></span><br><span class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></span><br><span class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></span><br></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//f1执行代码</span></span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(f2);</span><br><span class=\"line\">f3();</span><br></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></span><br></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//f1执行代码</span></span><br><span class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</span><br></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//f1执行代码</span></span><br><span class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1().then(f2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</span><br><span class=\"line\">　<span class=\"comment\">// f1的任务代码</span></span><br><span class=\"line\">　dfd.resolve();</span><br><span class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h3 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h3><ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"test.html\"</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">      url: ...,</span><br><span class=\"line\">      success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">\"test.html\"</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  dosth();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h3><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>"},{"title":"搭建Hexo博客之后","date":"2017-07-15T06:59:11.000Z","_content":"这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!-- more -->\n\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n### 更换电脑后的操作\n\n* 使用`git clone`将远程仓库克隆到本地\n* 在本地的仓库执行`npm install hexo`、`npm install`、`npm install hexo-git-backup --save`，就完成了更换电脑更新的操作啦（记得，不需要`hexo init`这条指令）。\n\n","source":"_posts/搭建Hexo博客之后.md","raw":"---\ntitle: 搭建Hexo博客之后\ndate: 2017-07-15 14:59:11\ncategories: 知识碎片\ntags: \n  - hexo\n---\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!-- more -->\n\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n### 更换电脑后的操作\n\n* 使用`git clone`将远程仓库克隆到本地\n* 在本地的仓库执行`npm install hexo`、`npm install`、`npm install hexo-git-backup --save`，就完成了更换电脑更新的操作啦（记得，不需要`hexo init`这条指令）。\n\n","slug":"搭建Hexo博客之后","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl86000pfr03w3h8ctu2","content":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>\n<a id=\"more\"></a>\n<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>\n<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h3 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h3><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch README.md</span><br><span class=\"line\">$ git init </span><br><span class=\"line\">$ git add README.md</span><br><span class=\"line\">$ git commit -m &quot;first commit&quot;</span><br><span class=\"line\">$ git remote add origin 你的项目地址</span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull --rebase origin master</span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h3 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch hexo</span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h3 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout hexo</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"noopener\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h3><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></span><br><span class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></span><br><span class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></span><br><span class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></span><br><span class=\"line\"><span class=\"attr\">backup:</span></span><br><span class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">\t<span class=\"attr\">repository:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></span><br></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo d //部署博客</span><br><span class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</span><br></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h3 id=\"更换电脑后的操作\"><a href=\"#更换电脑后的操作\" class=\"headerlink\" title=\"更换电脑后的操作\"></a>更换电脑后的操作</h3><ul>\n<li>使用<code>git clone</code>将远程仓库克隆到本地</li>\n<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>","more":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>\n<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h3 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h3><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch README.md</span><br><span class=\"line\">$ git init </span><br><span class=\"line\">$ git add README.md</span><br><span class=\"line\">$ git commit -m &quot;first commit&quot;</span><br><span class=\"line\">$ git remote add origin 你的项目地址</span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull --rebase origin master</span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h3 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch hexo</span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h3 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout hexo</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"noopener\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h3><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></span><br><span class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></span><br><span class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></span><br><span class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></span><br><span class=\"line\"><span class=\"attr\">backup:</span></span><br><span class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">\t<span class=\"attr\">repository:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></span><br></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo d //部署博客</span><br><span class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</span><br></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h3 id=\"更换电脑后的操作\"><a href=\"#更换电脑后的操作\" class=\"headerlink\" title=\"更换电脑后的操作\"></a>更换电脑后的操作</h3><ul>\n<li>使用<code>git clone</code>将远程仓库克隆到本地</li>\n<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>\n</ul>"},{"title":"有关一些数组和对象方法的比较和总结","date":"2018-11-04T14:57:01.000Z","_content":"最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结\n\n## Array\n\n### 元素的添加与删除\n\n<!-- more -->\n\n最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结\n\n## Array\n\n### 元素的添加与删除\n▶ **posh & pop** 数组的栈方法，在数组的末端增加和删除一个元素\n```js\nlet a = [1, 2, 3]\na.posh(4) // [1, 2, 3, 4]\na.pop() // [1, 2, 3]\n```\n▶ **shift & unshift** 数组的队列方法，在数组的第一个位置增加和删除一个元素\n```js\nlet a = [1, 2, 3]\na.shift(0) // [0, 1, 2, 3]\na.unshift() // [1, 2, 3]\n```\n▶ **splice** 用于删除原数组的一部分元素，可以在被删除的位置加入新元素，会改变原数组\n```js\nlet a = [1, 2, 3, 4]\na.splice(2, 3, 5) // [3, 4]\na // [1, 2, 5]\n```\n### 数组的分割与合并\n▶ **slice** 用于提取数组的某个部分，参数是开始位置与结束位置\n```js\nlet a = [1, 2, 3, 4]\na.slice() // 参数为空时相当于复制数组 [1, 2, 3, 4]\na.slice(1) // 只有一个参数时默认提取到最后一个 [2, 3, 4]\na.slice(1, 3) // 结束位置的那个元素并不包括 [2, 3]\na.slice(-2, -1) // 参数为负数时会取倒数第n个元素 [3]\n// 正数从0开始而倒数从1开始\n```\n▶ **concat** 用于多个数组的合并，返回新数组，不会改变原数组；同时也可以用于对象的合并。\n```js\nlet a = [1, [2]]\nlet b = [3, [4]]\na.concat(b) // [1, [2], 3, [4]]\n\n// 在ES6中等同于[..a,..b]\n```\n### 排序\n▶ **sort** 对元素进行排序，会改变原数组\n```js\nlet a = [1, 3, 2, 4]\na.sort() // [1, 2, 3, 4]\n```\n▶ **reverse** 颠倒元素的顺序，会改变原数组\n```js\nlet a = [3, 2, 1, 4]\na.reverse() // [4, 1, 2, 3] \n```\n### 遍历\n▶ **forEach** 遍历，参数分别是当前元素、当前位置和整个数组\n```js\n[1, 2, 3].forEach((item, index, array) => {\n  console.log('[' + index + '] = ' + item)\n})\n// [0] = 1\n// [1] = 2\n// [2] = 3\n```\n▶ **map** 遍历，参数分别是当前元素、当前位置和整个数组\n```js\n[1, 2, 3].map((item, index, array) => {\n  return item * index\n})\n// [0, 2, 6]\n```\n▶ **filter** 过滤数据，遍历数据查找符合输入函数条件的元素，返回一个新的数组\n```js\n[1, 2, 3, 4, 5].filter((item) => {\n  return item > 3\n})\n// [4, 5]\n```\n▶ **some & every** 断言，判断数组的每个元素是否符合某条件，返回布尔值\n```js\n[1, 2, 3, 4].some((item, index, array) => {\n  return item >= 3\n})\n// true\n[1, 2, 3, 4].every((item, index, array) => {\n  return item >= 3\n})\n// false\n```\n▶ **reduce & reduceRight** 接受函数作为累加器，让每个值最终合成一个值\n```js\n[1, 2, 3].reduce((acc, cur, idx, src) => {\n  return acc + cur\n})\n// 6\n// reduce(callback, initialValue) 可设置acc第一次计算的默认值，不设置的话是数组第一个元素\n```\n### 查找元素\n▶ **indexOf** 查找某元素的索引，不存在返回-1\n```js\n[1, 3, 5].indexOf(5) // 2\n```\n▶ **find & findIndex** 查找满足条件的元素，返回第一个符合条件的元素，未找到返回`undefined`，**findIndex**返回的是索引\n```js\n[1, 3, 5].find((item, index, array) => {\n  return item > 2\n})\n// 3\n```\n▶ **includes** 判断当前数组是否包含某指定的值，返回布尔值\n```js\n['a', 'b', 'c'].includes('a') // true\n```\n### 字符串相关\n▶ **join** 输入指定分隔符将数组拼成一个字符串\n```js\n['a', 'b', 'c'].join(',') // a,b,c\n```\n\n▶ **toString** 将数组转换为字符串，间隔符为逗号\n```js\n['a', 'b', 'c'].toString() // a,b,c\n```\n\n### 其他\n▶ **from** 从一个类似数组或可迭代对象中创建一个新的数组实例（ES6）\n```js\nArray.from([1, 2, 3], x => x + x) // [2, 4, 6]\n\n// 合并数组并去重\nfunction combine () {\n  let arr = [].concat.apply([], arguments)\n  // new Set为ES6的新数据结构，类似于数组，但它的成员是唯一的\n  return Array.from(new Set(arr))\n}\n\ncombine([1, 2, 2], [2, 3, 3]) // [1, 2, 3]\n```\n\n▶ **copyWithin** 将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变。接收三个参数【从该位置开始替换|从该位置开始读取数据|到该位置停止读取数据】（ES6）\n```js\n[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]\n```\n\n▶ **fill** 用给定的值填充一个数组（ES6）\n```js\n['a', 'b', 'c'].fill(7) // [7, 7, 7]\n```\n\n## Objcet\n\n▶ **Object.assign** 合并对象，合并时含有相同属性则后者覆盖前者，会改变目标对象\n```js\nObject.assign({a: 1, b: 2}, {b: 3, c: 4})\n// {a: 1, b: 3, c: 4}\n```\n\n▶ **Object.is** 用来判断两个值是否是同一个值\n```\nObject.is('haorooms', 'haorooms');     // true\nObject.is(window, window);   // true\n\nObject.is('foo', 'bar');     // false\nObject.is([], []);           // false\n\nvar test = { a: 1 };\nObject.is(test, test);       // true\n\nObject.is(null, null);       // true\n\n// 特例\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true\n```\n▶ **Object.keys** 回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 `for...in`循环遍历该对象时返回的顺序一致\n```js\nlet obj = {a: 1, b: 2}\nObject.keys(obj) // ['a', 'b']\n```\n\n## Lodash\n\n由于lodash的方法实在是太多了，只提一下最最最常用的`merge`，用于两个对象的合并，可以实现深拷贝，但是在合并数组的时候有一个坑\n```js\nlet a = {\n  name: 'xm',\n  age: 18,\n  tag: ['smart', 'happy']\n}\nlet b = {\n  form: 'china',\n  tag: ['smart']\n}\nlodash.merge(a, b)\n//{\n//  name: 'xm',\n//  age: 18,\n//  tag: ['smart', 'happy'],\n//  from: 'china'\n//}\n```\n由于是深拷贝，合并时数组会把两个对象的数组合并到一起，区别于`Object.assign()`，但是有的时候确实必须用深拷贝，又要去后一个数组覆盖目标数组，那么在合并之前就必须先移除掉目标对象中的这个属性\n```js\nlodash.merge(lodash.omit(a, ['tag']), b)\n//{\n//  name: 'xm',\n//  age: 18,\n//  tag: ['smart'],\n//  from: 'china'\n//}\n```\n","source":"_posts/有关一些数组和对象方法的比较和总结.md","raw":"---\ntitle: 有关一些数组和对象方法的比较和总结\ndate: 2018-11-04 22:57:01\ncategories: JS相关\ntags: \n  - JavaScript\n  - lodash\n---\n最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结\n\n## Array\n\n### 元素的添加与删除\n\n<!-- more -->\n\n最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结\n\n## Array\n\n### 元素的添加与删除\n▶ **posh & pop** 数组的栈方法，在数组的末端增加和删除一个元素\n```js\nlet a = [1, 2, 3]\na.posh(4) // [1, 2, 3, 4]\na.pop() // [1, 2, 3]\n```\n▶ **shift & unshift** 数组的队列方法，在数组的第一个位置增加和删除一个元素\n```js\nlet a = [1, 2, 3]\na.shift(0) // [0, 1, 2, 3]\na.unshift() // [1, 2, 3]\n```\n▶ **splice** 用于删除原数组的一部分元素，可以在被删除的位置加入新元素，会改变原数组\n```js\nlet a = [1, 2, 3, 4]\na.splice(2, 3, 5) // [3, 4]\na // [1, 2, 5]\n```\n### 数组的分割与合并\n▶ **slice** 用于提取数组的某个部分，参数是开始位置与结束位置\n```js\nlet a = [1, 2, 3, 4]\na.slice() // 参数为空时相当于复制数组 [1, 2, 3, 4]\na.slice(1) // 只有一个参数时默认提取到最后一个 [2, 3, 4]\na.slice(1, 3) // 结束位置的那个元素并不包括 [2, 3]\na.slice(-2, -1) // 参数为负数时会取倒数第n个元素 [3]\n// 正数从0开始而倒数从1开始\n```\n▶ **concat** 用于多个数组的合并，返回新数组，不会改变原数组；同时也可以用于对象的合并。\n```js\nlet a = [1, [2]]\nlet b = [3, [4]]\na.concat(b) // [1, [2], 3, [4]]\n\n// 在ES6中等同于[..a,..b]\n```\n### 排序\n▶ **sort** 对元素进行排序，会改变原数组\n```js\nlet a = [1, 3, 2, 4]\na.sort() // [1, 2, 3, 4]\n```\n▶ **reverse** 颠倒元素的顺序，会改变原数组\n```js\nlet a = [3, 2, 1, 4]\na.reverse() // [4, 1, 2, 3] \n```\n### 遍历\n▶ **forEach** 遍历，参数分别是当前元素、当前位置和整个数组\n```js\n[1, 2, 3].forEach((item, index, array) => {\n  console.log('[' + index + '] = ' + item)\n})\n// [0] = 1\n// [1] = 2\n// [2] = 3\n```\n▶ **map** 遍历，参数分别是当前元素、当前位置和整个数组\n```js\n[1, 2, 3].map((item, index, array) => {\n  return item * index\n})\n// [0, 2, 6]\n```\n▶ **filter** 过滤数据，遍历数据查找符合输入函数条件的元素，返回一个新的数组\n```js\n[1, 2, 3, 4, 5].filter((item) => {\n  return item > 3\n})\n// [4, 5]\n```\n▶ **some & every** 断言，判断数组的每个元素是否符合某条件，返回布尔值\n```js\n[1, 2, 3, 4].some((item, index, array) => {\n  return item >= 3\n})\n// true\n[1, 2, 3, 4].every((item, index, array) => {\n  return item >= 3\n})\n// false\n```\n▶ **reduce & reduceRight** 接受函数作为累加器，让每个值最终合成一个值\n```js\n[1, 2, 3].reduce((acc, cur, idx, src) => {\n  return acc + cur\n})\n// 6\n// reduce(callback, initialValue) 可设置acc第一次计算的默认值，不设置的话是数组第一个元素\n```\n### 查找元素\n▶ **indexOf** 查找某元素的索引，不存在返回-1\n```js\n[1, 3, 5].indexOf(5) // 2\n```\n▶ **find & findIndex** 查找满足条件的元素，返回第一个符合条件的元素，未找到返回`undefined`，**findIndex**返回的是索引\n```js\n[1, 3, 5].find((item, index, array) => {\n  return item > 2\n})\n// 3\n```\n▶ **includes** 判断当前数组是否包含某指定的值，返回布尔值\n```js\n['a', 'b', 'c'].includes('a') // true\n```\n### 字符串相关\n▶ **join** 输入指定分隔符将数组拼成一个字符串\n```js\n['a', 'b', 'c'].join(',') // a,b,c\n```\n\n▶ **toString** 将数组转换为字符串，间隔符为逗号\n```js\n['a', 'b', 'c'].toString() // a,b,c\n```\n\n### 其他\n▶ **from** 从一个类似数组或可迭代对象中创建一个新的数组实例（ES6）\n```js\nArray.from([1, 2, 3], x => x + x) // [2, 4, 6]\n\n// 合并数组并去重\nfunction combine () {\n  let arr = [].concat.apply([], arguments)\n  // new Set为ES6的新数据结构，类似于数组，但它的成员是唯一的\n  return Array.from(new Set(arr))\n}\n\ncombine([1, 2, 2], [2, 3, 3]) // [1, 2, 3]\n```\n\n▶ **copyWithin** 将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变。接收三个参数【从该位置开始替换|从该位置开始读取数据|到该位置停止读取数据】（ES6）\n```js\n[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]\n```\n\n▶ **fill** 用给定的值填充一个数组（ES6）\n```js\n['a', 'b', 'c'].fill(7) // [7, 7, 7]\n```\n\n## Objcet\n\n▶ **Object.assign** 合并对象，合并时含有相同属性则后者覆盖前者，会改变目标对象\n```js\nObject.assign({a: 1, b: 2}, {b: 3, c: 4})\n// {a: 1, b: 3, c: 4}\n```\n\n▶ **Object.is** 用来判断两个值是否是同一个值\n```\nObject.is('haorooms', 'haorooms');     // true\nObject.is(window, window);   // true\n\nObject.is('foo', 'bar');     // false\nObject.is([], []);           // false\n\nvar test = { a: 1 };\nObject.is(test, test);       // true\n\nObject.is(null, null);       // true\n\n// 特例\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true\n```\n▶ **Object.keys** 回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 `for...in`循环遍历该对象时返回的顺序一致\n```js\nlet obj = {a: 1, b: 2}\nObject.keys(obj) // ['a', 'b']\n```\n\n## Lodash\n\n由于lodash的方法实在是太多了，只提一下最最最常用的`merge`，用于两个对象的合并，可以实现深拷贝，但是在合并数组的时候有一个坑\n```js\nlet a = {\n  name: 'xm',\n  age: 18,\n  tag: ['smart', 'happy']\n}\nlet b = {\n  form: 'china',\n  tag: ['smart']\n}\nlodash.merge(a, b)\n//{\n//  name: 'xm',\n//  age: 18,\n//  tag: ['smart', 'happy'],\n//  from: 'china'\n//}\n```\n由于是深拷贝，合并时数组会把两个对象的数组合并到一起，区别于`Object.assign()`，但是有的时候确实必须用深拷贝，又要去后一个数组覆盖目标数组，那么在合并之前就必须先移除掉目标对象中的这个属性\n```js\nlodash.merge(lodash.omit(a, ['tag']), b)\n//{\n//  name: 'xm',\n//  age: 18,\n//  tag: ['smart'],\n//  from: 'china'\n//}\n```\n","slug":"有关一些数组和对象方法的比较和总结","published":1,"updated":"2020-01-08T13:48:10.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl87000qfr0394ipgg8w","content":"<p>最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结</p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"元素的添加与删除\"><a href=\"#元素的添加与删除\" class=\"headerlink\" title=\"元素的添加与删除\"></a>元素的添加与删除</h3><a id=\"more\"></a>\n<p>最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结</p>\n<h2 id=\"Array-1\"><a href=\"#Array-1\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"元素的添加与删除-1\"><a href=\"#元素的添加与删除-1\" class=\"headerlink\" title=\"元素的添加与删除\"></a>元素的添加与删除</h3><p>▶ <strong>posh &amp; pop</strong> 数组的栈方法，在数组的末端增加和删除一个元素<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">a.posh(<span class=\"number\">4</span>) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">a.pop() <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>shift &amp; unshift</strong> 数组的队列方法，在数组的第一个位置增加和删除一个元素<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">a.shift(<span class=\"number\">0</span>) <span class=\"comment\">// [0, 1, 2, 3]</span></span><br><span class=\"line\">a.unshift() <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>splice</strong> 用于删除原数组的一部分元素，可以在被删除的位置加入新元素，会改变原数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.splice(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>) <span class=\"comment\">// [3, 4]</span></span><br><span class=\"line\">a <span class=\"comment\">// [1, 2, 5]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组的分割与合并\"><a href=\"#数组的分割与合并\" class=\"headerlink\" title=\"数组的分割与合并\"></a>数组的分割与合并</h3><p>▶ <strong>slice</strong> 用于提取数组的某个部分，参数是开始位置与结束位置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.slice() <span class=\"comment\">// 参数为空时相当于复制数组 [1, 2, 3, 4]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>) <span class=\"comment\">// 只有一个参数时默认提取到最后一个 [2, 3, 4]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 结束位置的那个元素并不包括 [2, 3]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">-2</span>, <span class=\"number\">-1</span>) <span class=\"comment\">// 参数为负数时会取倒数第n个元素 [3]</span></span><br><span class=\"line\"><span class=\"comment\">// 正数从0开始而倒数从1开始</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>concat</strong> 用于多个数组的合并，返回新数组，不会改变原数组；同时也可以用于对象的合并。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>]]</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = [<span class=\"number\">3</span>, [<span class=\"number\">4</span>]]</span><br><span class=\"line\">a.concat(b) <span class=\"comment\">// [1, [2], 3, [4]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在ES6中等同于[..a,..b]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>▶ <strong>sort</strong> 对元素进行排序，会改变原数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.sort() <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>reverse</strong> 颠倒元素的顺序，会改变原数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.reverse() <span class=\"comment\">// [4, 1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><p>▶ <strong>forEach</strong> 遍历，参数分别是当前元素、当前位置和整个数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'['</span> + index + <span class=\"string\">'] = '</span> + item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [0] = 1</span></span><br><span class=\"line\"><span class=\"comment\">// [1] = 2</span></span><br><span class=\"line\"><span class=\"comment\">// [2] = 3</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>map</strong> 遍历，参数分别是当前元素、当前位置和整个数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item * index</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>filter</strong> 过滤数据，遍历数据查找符合输入函数条件的元素，返回一个新的数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].filter(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [4, 5]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>some &amp; every</strong> 断言，判断数组的每个元素是否符合某条件，返回布尔值<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].some(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt;= <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].every(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt;= <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>reduce &amp; reduceRight</strong> 接受函数作为累加器，让每个值最终合成一个值<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].reduce(<span class=\"function\">(<span class=\"params\">acc, cur, idx, src</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> acc + cur</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// reduce(callback, initialValue) 可设置acc第一次计算的默认值，不设置的话是数组第一个元素</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h3><p>▶ <strong>indexOf</strong> 查找某元素的索引，不存在返回-1<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>].indexOf(<span class=\"number\">5</span>) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>find &amp; findIndex</strong> 查找满足条件的元素，返回第一个符合条件的元素，未找到返回<code>undefined</code>，<strong>findIndex</strong>返回的是索引<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>].find(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt; <span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>includes</strong> 判断当前数组是否包含某指定的值，返回布尔值<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].includes(<span class=\"string\">'a'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h3><p>▶ <strong>join</strong> 输入指定分隔符将数组拼成一个字符串<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].join(<span class=\"string\">','</span>) <span class=\"comment\">// a,b,c</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>toString</strong> 将数组转换为字符串，间隔符为逗号<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].toString() <span class=\"comment\">// a,b,c</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>▶ <strong>from</strong> 从一个类似数组或可迭代对象中创建一个新的数组实例（ES6）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], x =&gt; x + x) <span class=\"comment\">// [2, 4, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并数组并去重</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combine</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [].concat.apply([], <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// new Set为ES6的新数据结构，类似于数组，但它的成员是唯一的</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">combine([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>]) <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>copyWithin</strong> 将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变。接收三个参数【从该位置开始替换|从该位置开始读取数据|到该位置停止读取数据】（ES6）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>) <span class=\"comment\">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>fill</strong> 用给定的值填充一个数组（ES6）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>) <span class=\"comment\">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Objcet\"><a href=\"#Objcet\" class=\"headerlink\" title=\"Objcet\"></a>Objcet</h2><p>▶ <strong>Object.assign</strong> 合并对象，合并时含有相同属性则后者覆盖前者，会改变目标对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;, &#123;<span class=\"attr\">b</span>: <span class=\"number\">3</span>, <span class=\"attr\">c</span>: <span class=\"number\">4</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 4&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>Object.is</strong> 用来判断两个值是否是同一个值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;);     // true</span><br><span class=\"line\">Object.is(window, window);   // true</span><br><span class=\"line\"></span><br><span class=\"line\">Object.is(&apos;foo&apos;, &apos;bar&apos;);     // false</span><br><span class=\"line\">Object.is([], []);           // false</span><br><span class=\"line\"></span><br><span class=\"line\">var test = &#123; a: 1 &#125;;</span><br><span class=\"line\">Object.is(test, test);       // true</span><br><span class=\"line\"></span><br><span class=\"line\">Object.is(null, null);       // true</span><br><span class=\"line\"></span><br><span class=\"line\">// 特例</span><br><span class=\"line\">Object.is(0, -0);            // false</span><br><span class=\"line\">Object.is(-0, -0);           // true</span><br><span class=\"line\">Object.is(NaN, 0/0);         // true</span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>Object.keys</strong> 回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 <code>for...in</code>循环遍历该对象时返回的顺序一致<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(obj) <span class=\"comment\">// ['a', 'b']</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Lodash\"><a href=\"#Lodash\" class=\"headerlink\" title=\"Lodash\"></a>Lodash</h2><p>由于lodash的方法实在是太多了，只提一下最最最常用的<code>merge</code>，用于两个对象的合并，可以实现深拷贝，但是在合并数组的时候有一个坑<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xm'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  tag: [<span class=\"string\">'smart'</span>, <span class=\"string\">'happy'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = &#123;</span><br><span class=\"line\">  form: <span class=\"string\">'china'</span>,</span><br><span class=\"line\">  tag: [<span class=\"string\">'smart'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lodash.merge(a, b)</span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  name: 'xm',</span></span><br><span class=\"line\"><span class=\"comment\">//  age: 18,</span></span><br><span class=\"line\"><span class=\"comment\">//  tag: ['smart', 'happy'],</span></span><br><span class=\"line\"><span class=\"comment\">//  from: 'china'</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>由于是深拷贝，合并时数组会把两个对象的数组合并到一起，区别于<code>Object.assign()</code>，但是有的时候确实必须用深拷贝，又要去后一个数组覆盖目标数组，那么在合并之前就必须先移除掉目标对象中的这个属性<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lodash.merge(lodash.omit(a, [<span class=\"string\">'tag'</span>]), b)</span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  name: 'xm',</span></span><br><span class=\"line\"><span class=\"comment\">//  age: 18,</span></span><br><span class=\"line\"><span class=\"comment\">//  tag: ['smart'],</span></span><br><span class=\"line\"><span class=\"comment\">//  from: 'china'</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结</p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"元素的添加与删除\"><a href=\"#元素的添加与删除\" class=\"headerlink\" title=\"元素的添加与删除\"></a>元素的添加与删除</h3>","more":"<p>最近搬砖的时候总觉得自己对一些数组和对象的方法了解不够透彻，所以连着一些lodash的方法放在一起做个比较和总结</p>\n<h2 id=\"Array-1\"><a href=\"#Array-1\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"元素的添加与删除-1\"><a href=\"#元素的添加与删除-1\" class=\"headerlink\" title=\"元素的添加与删除\"></a>元素的添加与删除</h3><p>▶ <strong>posh &amp; pop</strong> 数组的栈方法，在数组的末端增加和删除一个元素<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">a.posh(<span class=\"number\">4</span>) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">a.pop() <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>shift &amp; unshift</strong> 数组的队列方法，在数组的第一个位置增加和删除一个元素<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">a.shift(<span class=\"number\">0</span>) <span class=\"comment\">// [0, 1, 2, 3]</span></span><br><span class=\"line\">a.unshift() <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>splice</strong> 用于删除原数组的一部分元素，可以在被删除的位置加入新元素，会改变原数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.splice(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>) <span class=\"comment\">// [3, 4]</span></span><br><span class=\"line\">a <span class=\"comment\">// [1, 2, 5]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组的分割与合并\"><a href=\"#数组的分割与合并\" class=\"headerlink\" title=\"数组的分割与合并\"></a>数组的分割与合并</h3><p>▶ <strong>slice</strong> 用于提取数组的某个部分，参数是开始位置与结束位置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.slice() <span class=\"comment\">// 参数为空时相当于复制数组 [1, 2, 3, 4]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>) <span class=\"comment\">// 只有一个参数时默认提取到最后一个 [2, 3, 4]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 结束位置的那个元素并不包括 [2, 3]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">-2</span>, <span class=\"number\">-1</span>) <span class=\"comment\">// 参数为负数时会取倒数第n个元素 [3]</span></span><br><span class=\"line\"><span class=\"comment\">// 正数从0开始而倒数从1开始</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>concat</strong> 用于多个数组的合并，返回新数组，不会改变原数组；同时也可以用于对象的合并。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>]]</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = [<span class=\"number\">3</span>, [<span class=\"number\">4</span>]]</span><br><span class=\"line\">a.concat(b) <span class=\"comment\">// [1, [2], 3, [4]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在ES6中等同于[..a,..b]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>▶ <strong>sort</strong> 对元素进行排序，会改变原数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.sort() <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>reverse</strong> 颠倒元素的顺序，会改变原数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">a.reverse() <span class=\"comment\">// [4, 1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><p>▶ <strong>forEach</strong> 遍历，参数分别是当前元素、当前位置和整个数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'['</span> + index + <span class=\"string\">'] = '</span> + item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [0] = 1</span></span><br><span class=\"line\"><span class=\"comment\">// [1] = 2</span></span><br><span class=\"line\"><span class=\"comment\">// [2] = 3</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>map</strong> 遍历，参数分别是当前元素、当前位置和整个数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item * index</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>filter</strong> 过滤数据，遍历数据查找符合输入函数条件的元素，返回一个新的数组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].filter(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [4, 5]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>some &amp; every</strong> 断言，判断数组的每个元素是否符合某条件，返回布尔值<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].some(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt;= <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].every(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt;= <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>reduce &amp; reduceRight</strong> 接受函数作为累加器，让每个值最终合成一个值<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].reduce(<span class=\"function\">(<span class=\"params\">acc, cur, idx, src</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> acc + cur</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// reduce(callback, initialValue) 可设置acc第一次计算的默认值，不设置的话是数组第一个元素</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h3><p>▶ <strong>indexOf</strong> 查找某元素的索引，不存在返回-1<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>].indexOf(<span class=\"number\">5</span>) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>find &amp; findIndex</strong> 查找满足条件的元素，返回第一个符合条件的元素，未找到返回<code>undefined</code>，<strong>findIndex</strong>返回的是索引<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>].find(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item &gt; <span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>includes</strong> 判断当前数组是否包含某指定的值，返回布尔值<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].includes(<span class=\"string\">'a'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h3><p>▶ <strong>join</strong> 输入指定分隔符将数组拼成一个字符串<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].join(<span class=\"string\">','</span>) <span class=\"comment\">// a,b,c</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>toString</strong> 将数组转换为字符串，间隔符为逗号<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].toString() <span class=\"comment\">// a,b,c</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>▶ <strong>from</strong> 从一个类似数组或可迭代对象中创建一个新的数组实例（ES6）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], x =&gt; x + x) <span class=\"comment\">// [2, 4, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并数组并去重</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combine</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [].concat.apply([], <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// new Set为ES6的新数据结构，类似于数组，但它的成员是唯一的</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">combine([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>]) <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>copyWithin</strong> 将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变。接收三个参数【从该位置开始替换|从该位置开始读取数据|到该位置停止读取数据】（ES6）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>) <span class=\"comment\">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>fill</strong> 用给定的值填充一个数组（ES6）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>) <span class=\"comment\">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Objcet\"><a href=\"#Objcet\" class=\"headerlink\" title=\"Objcet\"></a>Objcet</h2><p>▶ <strong>Object.assign</strong> 合并对象，合并时含有相同属性则后者覆盖前者，会改变目标对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;, &#123;<span class=\"attr\">b</span>: <span class=\"number\">3</span>, <span class=\"attr\">c</span>: <span class=\"number\">4</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 4&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>Object.is</strong> 用来判断两个值是否是同一个值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.is(&apos;haorooms&apos;, &apos;haorooms&apos;);     // true</span><br><span class=\"line\">Object.is(window, window);   // true</span><br><span class=\"line\"></span><br><span class=\"line\">Object.is(&apos;foo&apos;, &apos;bar&apos;);     // false</span><br><span class=\"line\">Object.is([], []);           // false</span><br><span class=\"line\"></span><br><span class=\"line\">var test = &#123; a: 1 &#125;;</span><br><span class=\"line\">Object.is(test, test);       // true</span><br><span class=\"line\"></span><br><span class=\"line\">Object.is(null, null);       // true</span><br><span class=\"line\"></span><br><span class=\"line\">// 特例</span><br><span class=\"line\">Object.is(0, -0);            // false</span><br><span class=\"line\">Object.is(-0, -0);           // true</span><br><span class=\"line\">Object.is(NaN, 0/0);         // true</span><br></pre></td></tr></table></figure></p>\n<p>▶ <strong>Object.keys</strong> 回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 <code>for...in</code>循环遍历该对象时返回的顺序一致<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(obj) <span class=\"comment\">// ['a', 'b']</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Lodash\"><a href=\"#Lodash\" class=\"headerlink\" title=\"Lodash\"></a>Lodash</h2><p>由于lodash的方法实在是太多了，只提一下最最最常用的<code>merge</code>，用于两个对象的合并，可以实现深拷贝，但是在合并数组的时候有一个坑<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xm'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  tag: [<span class=\"string\">'smart'</span>, <span class=\"string\">'happy'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = &#123;</span><br><span class=\"line\">  form: <span class=\"string\">'china'</span>,</span><br><span class=\"line\">  tag: [<span class=\"string\">'smart'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lodash.merge(a, b)</span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  name: 'xm',</span></span><br><span class=\"line\"><span class=\"comment\">//  age: 18,</span></span><br><span class=\"line\"><span class=\"comment\">//  tag: ['smart', 'happy'],</span></span><br><span class=\"line\"><span class=\"comment\">//  from: 'china'</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>由于是深拷贝，合并时数组会把两个对象的数组合并到一起，区别于<code>Object.assign()</code>，但是有的时候确实必须用深拷贝，又要去后一个数组覆盖目标数组，那么在合并之前就必须先移除掉目标对象中的这个属性<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lodash.merge(lodash.omit(a, [<span class=\"string\">'tag'</span>]), b)</span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  name: 'xm',</span></span><br><span class=\"line\"><span class=\"comment\">//  age: 18,</span></span><br><span class=\"line\"><span class=\"comment\">//  tag: ['smart'],</span></span><br><span class=\"line\"><span class=\"comment\">//  from: 'china'</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure></p>"},{"title":"ES6 核心向新特性（02）","date":"2018-03-08T11:56:33.000Z","_content":"## 模块 module\n```js\nimport { sayHi } from './people';\nexport default sayHi;\n```\n**注意点**：使用`default`导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。\n\n<!--more-->\n\n## 类\n```js\n// 类声明\nclass Aminal {\n  // 类中只能包含一个名为constructor的特殊方法\n  constructor() {\n    // ...\n  }\n}\n// extends 创建子类\nclass People extends Aminal {\n  constructor(contents = {}) {\n    super(); // 调用父类的构造函数\n    this.name = contents.name;\n    this.family = contents.family;\n  }\n  sayHi() {\n    console.log(`Hello ${this.name} ${this.family}`);\n  }\n}\n\nlet boy = new People({\n  name: 'ouven',\n  family: 'zhang'\n});\n\nboy.sayHi(); // Hello ouven zhang\n```\n\n## 模块 module\n```js\nimport { sayHi } from './people';\nexport default sayHi;\n```\n**注意点**：使用`default`导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。\n\n## 循环与迭代器 Iterator\n在 es6 阶段，除了`do...while`、`for`循环，还可以使用`for...in`来遍历**对象**。Iterator迭代器的加入让遍历数组、对象和集合的方式更加灵活可控，Iterator可以控制每次单步循环触发的时机，不用一次遍历所有的循环。\n\n▼ **`for...of`遍历实现**\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nfor(let number of numbers) {\n  console.log(number);\n}\n```\n▼ **迭代器遍历数组**\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nlet iterator = numbers[Symbol.iterator]();\nlet result = iterator.next();\nconsole.log(result.value); // 1\n\nresult = iterator.next();\nconsole.log(result.value); // 2\n\nresult = iterator.next();\nconsole.log(result.value); // 3\n\nresult = iterator.next();\nconsole.log(result.value); // 4\n\nresult = iterator.next();\nconsole.log(result.value); // 5\n```\n▼ **对比**\nIterator 可以在循环开始后任意的地方进行数组的单步循环，当循环迭代中每次单步循环操作都不一样时，使用 Iterator 更加的方便。如果使用`for...of`则需要不断判断执行的次数来执行不同的单步循环。\n▼ **注意点**\n每次 Iterator 调用`next()`都会返回一个对象`{done: false, value: item}`，`done`的属性是布尔值，表示循环遍历是否完成，`value`则是每一步`next()`调用获取到的值。\n\n## 生成器 Generator\n```js\nconst generator = function* () {\n  const numbers = [1, 2, 3, 4, 5];\n  for(let number of numbers) {\n    yield console.log(number);\n  }\n}\n\nlet result = generator();\n\nresult.next(); // 1\n// ...doSomething\nresult.next(); // 2\n// ...doSomething\nresult.next(); // 3\n// ...doSomething\nresult.next(); // 4\n// ...doSomething\nresult.next(); // 5\n// ...doSomething\n```\nGenerator 是针对函数内代码块的执行控制，如果将一个特殊函数的代码使用`yield`关键字来分割成多个不同的代码段，那么每次 Generator 调用`next()`都只会执行`yield`关键字之间的一段代码。Generator 可以认为是一个可中断执行的特殊函数，声明方法是在函数名后面加上`*`来与普通函数区分。\n▼ **注意点**\nGenerator 遇到`yield`关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果`console.log(number)`是一个耗时的工作，那么程序只在 Generator 里面暂停，外面的程序仍会继续执行。\n```js\nconst generator = function* () {\n  const numbers = [1, 2, 3, 4, 5];\n  for(let number of numbers) {\n    yield setTimeout(function() {\n      console.log(number);\n    }, 3000);\n  }\n}\n\nlet result = generator();\nlet done = result.next();\nwhile(!done.done) {\n  done = result.next();\n}\nconsole.log('finish');\n// 输出\nfinish\n1\n2\n3\n4\n5\n```\n\n## 集合类型\n### Set & Map\n▼ **为什么有了数组和对象来进行存储数据还要要使用 Map & Set**\n* 对象的键名一般只能是字符串，而不能是一个对象；\n* 对象没有直接获取属性个数等这些方便操作的方法；\n* 对于对象的任何操作都需要进入对象的内部数据中完成，如查找、删除某个值必须循环遍历对象内部的所有键值对来完成。\n\n▼ **Set的基本用法**\n```js\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n```\nSet 不会添加重复的值，并且可以接受一个数组（或者具有 Iterable 接口的其他数据解构）作为参数，用来初始化。\n▼ **Map的基本用法**\n```js\nconst m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\nMap 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以作为键。\n\n### WeakSet & WeakMap\nWeakSet 和 WeakMap 则对应着 Set 和 Map 的优化类型，所以某种程度上，为了让程序开发更加方便，我妈有必要引入集合这类更为高效的类型。WeakSet 和 WeakMap 在生成时有更加严格的限制：WeakSet 只存储对象类型的元素，不能遍历，没有`size`属性；WeakMap 只接受基本类型的值作为键名，没有`keys`、`values`、`entries`等遍历方法，也没有`size`属性。\n▼ **WeakSet的基本用法**\n```js\nconst a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet {[1, 2], [3, 4]}\n\nconst b = [3, 4];\nconst ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n```\n▼ **WeakMap的基本用法**\n```js\nconst wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\nconst map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\n```\n\n## 数组或对象循环遍历的方法对比\n### for/while 循环语句\n```js\nlet arr = [1, 2, 3];\nfor(let = 0, len = arr.length; i < len; i++) {\n  console.log(arr[i]);\n}\n```\n所有语言都会涉及的循环。不过单纯的for/while能力有限，而且性能上也堪忧。而且必须借助特定的结构才能遍历数据结构。\n### forEach 方法\n```js\n[1, 2, 3].forEach(function(value, index) {\n  console.log(index + ':' + value);\n});\n```\n**优点：**可以同时获取index和value，不必再像以前遍历数组那样，还要再在for去获取值。\n**缺点：**仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。\n**应用场景：**仅在遍历数组的时候使用。\n### for...in 语句\n```js\nlet obj = {a: 1, b: 2,c: 3};\nfor(let key in obj) {\n  console.log(obj[key]);\n}\n```\n**优点：**它可以支持所有对象类型的数据，包括数组，甚至是函数等，而且语法简单。且不同于`forEach`方法，它可以与break、continue和return配合使用。\n**缺点：**循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。主要是为遍历对象而设计的，不适用于遍历数组。\n**应用场景：** 遍历常用对象（如例子）\n### for...of 语句\n```js\nvar list = new Map();\nlist.set('a', 1);\nlist.set('b', 2);\nlist.set('c', 3);\nfor(var [key, value] of list) {\n  console.log(key + ':' + value);\n}\n```\n`for...of`是ES6新增的语法，它是基于ES6新增的Iterator和Symbol开发的。\n**优点：**在遍历中直接取值。感觉上和`for...in`形成互补，一个在遍历中取键名，另一个取值。另一个优点是，它可以遍历任何部署了 Iterator 接口的数据结构（如 Set 和 Map），甚至是非 JavaScript 的数据类型，即自己定义的数据结构。\n**缺点：**对于普通的对象，`for...of`结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。\n**应用场景：**推荐应用于Map上的遍历。\n### map() & filter() & reduce()\n```js\nvar arr = [1, 2, 3];\n\narr.map(function(element) {\n  return element + 1;\n});\n// [2, 3, 4]\n\narr.filter(function(element) {\n  return element > 1;\n})\n// [2, 3]\n\nvar result = arr.reduce(function(prev, element) {\n  return prev + element;\n}, 0);\n// 5\n```\n**应用场景：**这三个方法都是是 Array 中的方法，常用于数组中的数值的处理。`map`主要用于对存储的数据进行加工，`filter`偏向于过滤数据，`reduce`用于计算总和。\n\n学习参考：\n[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)\n《现代前端技术解析》","source":"_posts/ES6 核心向新特性（02）.md","raw":"---\ntitle: ES6 核心向新特性（02）\ndate: 2018-03-08 19:56:33\ncategories: JS相关\ntags: \n  - JavaScript\n  - ES6\n---\n## 模块 module\n```js\nimport { sayHi } from './people';\nexport default sayHi;\n```\n**注意点**：使用`default`导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。\n\n<!--more-->\n\n## 类\n```js\n// 类声明\nclass Aminal {\n  // 类中只能包含一个名为constructor的特殊方法\n  constructor() {\n    // ...\n  }\n}\n// extends 创建子类\nclass People extends Aminal {\n  constructor(contents = {}) {\n    super(); // 调用父类的构造函数\n    this.name = contents.name;\n    this.family = contents.family;\n  }\n  sayHi() {\n    console.log(`Hello ${this.name} ${this.family}`);\n  }\n}\n\nlet boy = new People({\n  name: 'ouven',\n  family: 'zhang'\n});\n\nboy.sayHi(); // Hello ouven zhang\n```\n\n## 模块 module\n```js\nimport { sayHi } from './people';\nexport default sayHi;\n```\n**注意点**：使用`default`导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。\n\n## 循环与迭代器 Iterator\n在 es6 阶段，除了`do...while`、`for`循环，还可以使用`for...in`来遍历**对象**。Iterator迭代器的加入让遍历数组、对象和集合的方式更加灵活可控，Iterator可以控制每次单步循环触发的时机，不用一次遍历所有的循环。\n\n▼ **`for...of`遍历实现**\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nfor(let number of numbers) {\n  console.log(number);\n}\n```\n▼ **迭代器遍历数组**\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nlet iterator = numbers[Symbol.iterator]();\nlet result = iterator.next();\nconsole.log(result.value); // 1\n\nresult = iterator.next();\nconsole.log(result.value); // 2\n\nresult = iterator.next();\nconsole.log(result.value); // 3\n\nresult = iterator.next();\nconsole.log(result.value); // 4\n\nresult = iterator.next();\nconsole.log(result.value); // 5\n```\n▼ **对比**\nIterator 可以在循环开始后任意的地方进行数组的单步循环，当循环迭代中每次单步循环操作都不一样时，使用 Iterator 更加的方便。如果使用`for...of`则需要不断判断执行的次数来执行不同的单步循环。\n▼ **注意点**\n每次 Iterator 调用`next()`都会返回一个对象`{done: false, value: item}`，`done`的属性是布尔值，表示循环遍历是否完成，`value`则是每一步`next()`调用获取到的值。\n\n## 生成器 Generator\n```js\nconst generator = function* () {\n  const numbers = [1, 2, 3, 4, 5];\n  for(let number of numbers) {\n    yield console.log(number);\n  }\n}\n\nlet result = generator();\n\nresult.next(); // 1\n// ...doSomething\nresult.next(); // 2\n// ...doSomething\nresult.next(); // 3\n// ...doSomething\nresult.next(); // 4\n// ...doSomething\nresult.next(); // 5\n// ...doSomething\n```\nGenerator 是针对函数内代码块的执行控制，如果将一个特殊函数的代码使用`yield`关键字来分割成多个不同的代码段，那么每次 Generator 调用`next()`都只会执行`yield`关键字之间的一段代码。Generator 可以认为是一个可中断执行的特殊函数，声明方法是在函数名后面加上`*`来与普通函数区分。\n▼ **注意点**\nGenerator 遇到`yield`关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果`console.log(number)`是一个耗时的工作，那么程序只在 Generator 里面暂停，外面的程序仍会继续执行。\n```js\nconst generator = function* () {\n  const numbers = [1, 2, 3, 4, 5];\n  for(let number of numbers) {\n    yield setTimeout(function() {\n      console.log(number);\n    }, 3000);\n  }\n}\n\nlet result = generator();\nlet done = result.next();\nwhile(!done.done) {\n  done = result.next();\n}\nconsole.log('finish');\n// 输出\nfinish\n1\n2\n3\n4\n5\n```\n\n## 集合类型\n### Set & Map\n▼ **为什么有了数组和对象来进行存储数据还要要使用 Map & Set**\n* 对象的键名一般只能是字符串，而不能是一个对象；\n* 对象没有直接获取属性个数等这些方便操作的方法；\n* 对于对象的任何操作都需要进入对象的内部数据中完成，如查找、删除某个值必须循环遍历对象内部的所有键值对来完成。\n\n▼ **Set的基本用法**\n```js\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n```\nSet 不会添加重复的值，并且可以接受一个数组（或者具有 Iterable 接口的其他数据解构）作为参数，用来初始化。\n▼ **Map的基本用法**\n```js\nconst m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\nMap 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以作为键。\n\n### WeakSet & WeakMap\nWeakSet 和 WeakMap 则对应着 Set 和 Map 的优化类型，所以某种程度上，为了让程序开发更加方便，我妈有必要引入集合这类更为高效的类型。WeakSet 和 WeakMap 在生成时有更加严格的限制：WeakSet 只存储对象类型的元素，不能遍历，没有`size`属性；WeakMap 只接受基本类型的值作为键名，没有`keys`、`values`、`entries`等遍历方法，也没有`size`属性。\n▼ **WeakSet的基本用法**\n```js\nconst a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet {[1, 2], [3, 4]}\n\nconst b = [3, 4];\nconst ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n```\n▼ **WeakMap的基本用法**\n```js\nconst wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\nconst map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\n```\n\n## 数组或对象循环遍历的方法对比\n### for/while 循环语句\n```js\nlet arr = [1, 2, 3];\nfor(let = 0, len = arr.length; i < len; i++) {\n  console.log(arr[i]);\n}\n```\n所有语言都会涉及的循环。不过单纯的for/while能力有限，而且性能上也堪忧。而且必须借助特定的结构才能遍历数据结构。\n### forEach 方法\n```js\n[1, 2, 3].forEach(function(value, index) {\n  console.log(index + ':' + value);\n});\n```\n**优点：**可以同时获取index和value，不必再像以前遍历数组那样，还要再在for去获取值。\n**缺点：**仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。\n**应用场景：**仅在遍历数组的时候使用。\n### for...in 语句\n```js\nlet obj = {a: 1, b: 2,c: 3};\nfor(let key in obj) {\n  console.log(obj[key]);\n}\n```\n**优点：**它可以支持所有对象类型的数据，包括数组，甚至是函数等，而且语法简单。且不同于`forEach`方法，它可以与break、continue和return配合使用。\n**缺点：**循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。主要是为遍历对象而设计的，不适用于遍历数组。\n**应用场景：** 遍历常用对象（如例子）\n### for...of 语句\n```js\nvar list = new Map();\nlist.set('a', 1);\nlist.set('b', 2);\nlist.set('c', 3);\nfor(var [key, value] of list) {\n  console.log(key + ':' + value);\n}\n```\n`for...of`是ES6新增的语法，它是基于ES6新增的Iterator和Symbol开发的。\n**优点：**在遍历中直接取值。感觉上和`for...in`形成互补，一个在遍历中取键名，另一个取值。另一个优点是，它可以遍历任何部署了 Iterator 接口的数据结构（如 Set 和 Map），甚至是非 JavaScript 的数据类型，即自己定义的数据结构。\n**缺点：**对于普通的对象，`for...of`结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。\n**应用场景：**推荐应用于Map上的遍历。\n### map() & filter() & reduce()\n```js\nvar arr = [1, 2, 3];\n\narr.map(function(element) {\n  return element + 1;\n});\n// [2, 3, 4]\n\narr.filter(function(element) {\n  return element > 1;\n})\n// [2, 3]\n\nvar result = arr.reduce(function(prev, element) {\n  return prev + element;\n}, 0);\n// 5\n```\n**应用场景：**这三个方法都是是 Array 中的方法，常用于数组中的数值的处理。`map`主要用于对存储的数据进行加工，`filter`偏向于过滤数据，`reduce`用于计算总和。\n\n学习参考：\n[ECMAScript 6入门——阮一峰](http://es6.ruanyifeng.com/)\n《现代前端技术解析》","slug":"ES6 核心向新特性（02）","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl8z000rfr03bc7g3fnn","content":"<h2 id=\"模块-module\"><a href=\"#模块-module\" class=\"headerlink\" title=\"模块 module\"></a>模块 module</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; sayHi &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./people'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> sayHi;</span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>：使用<code>default</code>导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。</p>\n<a id=\"more\"></a>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aminal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类中只能包含一个名为constructor的特殊方法</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// extends 创建子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aminal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(contents = &#123;&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(); <span class=\"comment\">// 调用父类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = contents.name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.family = contents.family;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.family&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy = <span class=\"keyword\">new</span> People(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'ouven'</span>,</span><br><span class=\"line\">  family: <span class=\"string\">'zhang'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">boy.sayHi(); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"模块-module-1\"><a href=\"#模块-module-1\" class=\"headerlink\" title=\"模块 module\"></a>模块 module</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; sayHi &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./people'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> sayHi;</span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>：使用<code>default</code>导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。</p>\n<h2 id=\"循环与迭代器-Iterator\"><a href=\"#循环与迭代器-Iterator\" class=\"headerlink\" title=\"循环与迭代器 Iterator\"></a>循环与迭代器 Iterator</h2><p>在 es6 阶段，除了<code>do...while</code>、<code>for</code>循环，还可以使用<code>for...in</code>来遍历<strong>对象</strong>。Iterator迭代器的加入让遍历数组、对象和集合的方式更加灵活可控，Iterator可以控制每次单步循环触发的时机，不用一次遍历所有的循环。</p>\n<p>▼ <strong><code>for...of</code>遍历实现</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>迭代器遍历数组</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>对比</strong><br>Iterator 可以在循环开始后任意的地方进行数组的单步循环，当循环迭代中每次单步循环操作都不一样时，使用 Iterator 更加的方便。如果使用<code>for...of</code>则需要不断判断执行的次数来执行不同的单步循环。<br>▼ <strong>注意点</strong><br>每次 Iterator 调用<code>next()</code>都会返回一个对象<code>{done: false, value: item}</code>，<code>done</code>的属性是布尔值，表示循环遍历是否完成，<code>value</code>则是每一步<code>next()</code>调用获取到的值。</p>\n<h2 id=\"生成器-Generator\"><a href=\"#生成器-Generator\" class=\"headerlink\" title=\"生成器 Generator\"></a>生成器 Generator</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> generator = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = generator();</span><br><span class=\"line\"></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br></pre></td></tr></table></figure>\n<p>Generator 是针对函数内代码块的执行控制，如果将一个特殊函数的代码使用<code>yield</code>关键字来分割成多个不同的代码段，那么每次 Generator 调用<code>next()</code>都只会执行<code>yield</code>关键字之间的一段代码。Generator 可以认为是一个可中断执行的特殊函数，声明方法是在函数名后面加上<code>*</code>来与普通函数区分。<br>▼ <strong>注意点</strong><br>Generator 遇到<code>yield</code>关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果<code>console.log(number)</code>是一个耗时的工作，那么程序只在 Generator 里面暂停，外面的程序仍会继续执行。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> generator = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = generator();</span><br><span class=\"line\"><span class=\"keyword\">let</span> done = result.next();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!done.done) &#123;</span><br><span class=\"line\">  done = result.next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'finish'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">finish</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"集合类型\"><a href=\"#集合类型\" class=\"headerlink\" title=\"集合类型\"></a>集合类型</h2><h3 id=\"Set-amp-Map\"><a href=\"#Set-amp-Map\" class=\"headerlink\" title=\"Set &amp; Map\"></a>Set &amp; Map</h3><p>▼ <strong>为什么有了数组和对象来进行存储数据还要要使用 Map &amp; Set</strong></p>\n<ul>\n<li>对象的键名一般只能是字符串，而不能是一个对象；</li>\n<li>对象没有直接获取属性个数等这些方便操作的方法；</li>\n<li>对于对象的任何操作都需要进入对象的内部数据中完成，如查找、删除某个值必须循环遍历对象内部的所有键值对来完成。</li>\n</ul>\n<p>▼ <strong>Set的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set]</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p>Set 不会添加重复的值，并且可以接受一个数组（或者具有 Iterable 接口的其他数据解构）作为参数，用来初始化。<br>▼ <strong>Map的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;<span class=\"attr\">p</span>: <span class=\"string\">'Hello World'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(o, <span class=\"string\">'content'</span>)</span><br><span class=\"line\">m.get(o) <span class=\"comment\">// \"content\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.has(o) <span class=\"comment\">// true</span></span><br><span class=\"line\">m.delete(o) <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(o) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以作为键。</p>\n<h3 id=\"WeakSet-amp-WeakMap\"><a href=\"#WeakSet-amp-WeakMap\" class=\"headerlink\" title=\"WeakSet &amp; WeakMap\"></a>WeakSet &amp; WeakMap</h3><p>WeakSet 和 WeakMap 则对应着 Set 和 Map 的优化类型，所以某种程度上，为了让程序开发更加方便，我妈有必要引入集合这类更为高效的类型。WeakSet 和 WeakMap 在生成时有更加严格的限制：WeakSet 只存储对象类型的元素，不能遍历，没有<code>size</code>属性；WeakMap 只接受基本类型的值作为键名，没有<code>keys</code>、<code>values</code>、<code>entries</code>等遍历方法，也没有<code>size</code>属性。<br>▼ <strong>WeakSet的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]];</span><br><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(a);</span><br><span class=\"line\"><span class=\"comment\">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(b);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>WeakMap的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm1 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> key = &#123;<span class=\"attr\">foo</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">wm1.set(key, <span class=\"number\">2</span>);</span><br><span class=\"line\">wm1.get(key) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// TypeError: 1 is not an object!</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组或对象循环遍历的方法对比\"><a href=\"#数组或对象循环遍历的方法对比\" class=\"headerlink\" title=\"数组或对象循环遍历的方法对比\"></a>数组或对象循环遍历的方法对比</h2><h3 id=\"for-while-循环语句\"><a href=\"#for-while-循环语句\" class=\"headerlink\" title=\"for/while 循环语句\"></a>for/while 循环语句</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有语言都会涉及的循环。不过单纯的for/while能力有限，而且性能上也堪忧。而且必须借助特定的结构才能遍历数据结构。</p>\n<h3 id=\"forEach-方法\"><a href=\"#forEach-方法\" class=\"headerlink\" title=\"forEach 方法\"></a>forEach 方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index + <span class=\"string\">':'</span> + value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>优点：</strong>可以同时获取index和value，不必再像以前遍历数组那样，还要再在for去获取值。<br><strong>缺点：</strong>仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。<br><strong>应用场景：</strong>仅在遍历数组的时候使用。</p>\n<h3 id=\"for…in-语句\"><a href=\"#for…in-语句\" class=\"headerlink\" title=\"for…in 语句\"></a>for…in 语句</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>,<span class=\"attr\">c</span>: <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(obj[key]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优点：</strong>它可以支持所有对象类型的数据，包括数组，甚至是函数等，而且语法简单。且不同于<code>forEach</code>方法，它可以与break、continue和return配合使用。<br><strong>缺点：</strong>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。主要是为遍历对象而设计的，不适用于遍历数组。<br><strong>应用场景：</strong> 遍历常用对象（如例子）</p>\n<h3 id=\"for…of-语句\"><a href=\"#for…of-语句\" class=\"headerlink\" title=\"for…of 语句\"></a>for…of 语句</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">list.set(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">list.set(<span class=\"string\">'b'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">list.set(<span class=\"string\">'c'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> list) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">':'</span> + value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>for...of</code>是ES6新增的语法，它是基于ES6新增的Iterator和Symbol开发的。<br><strong>优点：</strong>在遍历中直接取值。感觉上和<code>for...in</code>形成互补，一个在遍历中取键名，另一个取值。另一个优点是，它可以遍历任何部署了 Iterator 接口的数据结构（如 Set 和 Map），甚至是非 JavaScript 的数据类型，即自己定义的数据结构。<br><strong>缺点：</strong>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。<br><strong>应用场景：</strong>推荐应用于Map上的遍历。</p>\n<h3 id=\"map-amp-filter-amp-reduce\"><a href=\"#map-amp-filter-amp-reduce\" class=\"headerlink\" title=\"map() &amp; filter() &amp; reduce()\"></a>map() &amp; filter() &amp; reduce()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element &gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + element;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p><strong>应用场景：</strong>这三个方法都是是 Array 中的方法，常用于数组中的数值的处理。<code>map</code>主要用于对存储的数据进行加工，<code>filter</code>偏向于过滤数据，<code>reduce</code>用于计算总和。</p>\n<p>学习参考：<br><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门——阮一峰</a><br>《现代前端技术解析》</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"模块-module\"><a href=\"#模块-module\" class=\"headerlink\" title=\"模块 module\"></a>模块 module</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; sayHi &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./people'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> sayHi;</span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>：使用<code>default</code>导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。</p>","more":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aminal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类中只能包含一个名为constructor的特殊方法</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// extends 创建子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aminal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(contents = &#123;&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(); <span class=\"comment\">// 调用父类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = contents.name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.family = contents.family;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.family&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy = <span class=\"keyword\">new</span> People(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'ouven'</span>,</span><br><span class=\"line\">  family: <span class=\"string\">'zhang'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">boy.sayHi(); <span class=\"comment\">// Hello ouven zhang</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"模块-module-1\"><a href=\"#模块-module-1\" class=\"headerlink\" title=\"模块 module\"></a>模块 module</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; sayHi &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./people'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> sayHi;</span><br></pre></td></tr></table></figure>\n<p><strong>注意点</strong>：使用<code>default</code>导出时要尽量将其他模板需要使用的部分属性导出，不要导出整个对象，因为这样会导出一些不需要的东西，如果使用模块按需内容导出，部分ECMAScript6的打包工具可以使用静态树分析的方法来自动移除程序运行时不需要的代码。</p>\n<h2 id=\"循环与迭代器-Iterator\"><a href=\"#循环与迭代器-Iterator\" class=\"headerlink\" title=\"循环与迭代器 Iterator\"></a>循环与迭代器 Iterator</h2><p>在 es6 阶段，除了<code>do...while</code>、<code>for</code>循环，还可以使用<code>for...in</code>来遍历<strong>对象</strong>。Iterator迭代器的加入让遍历数组、对象和集合的方式更加灵活可控，Iterator可以控制每次单步循环触发的时机，不用一次遍历所有的循环。</p>\n<p>▼ <strong><code>for...of</code>遍历实现</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>迭代器遍历数组</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = iterator.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.value); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>对比</strong><br>Iterator 可以在循环开始后任意的地方进行数组的单步循环，当循环迭代中每次单步循环操作都不一样时，使用 Iterator 更加的方便。如果使用<code>for...of</code>则需要不断判断执行的次数来执行不同的单步循环。<br>▼ <strong>注意点</strong><br>每次 Iterator 调用<code>next()</code>都会返回一个对象<code>{done: false, value: item}</code>，<code>done</code>的属性是布尔值，表示循环遍历是否完成，<code>value</code>则是每一步<code>next()</code>调用获取到的值。</p>\n<h2 id=\"生成器-Generator\"><a href=\"#生成器-Generator\" class=\"headerlink\" title=\"生成器 Generator\"></a>生成器 Generator</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> generator = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = generator();</span><br><span class=\"line\"></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br><span class=\"line\">result.next(); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// ...doSomething</span></span><br></pre></td></tr></table></figure>\n<p>Generator 是针对函数内代码块的执行控制，如果将一个特殊函数的代码使用<code>yield</code>关键字来分割成多个不同的代码段，那么每次 Generator 调用<code>next()</code>都只会执行<code>yield</code>关键字之间的一段代码。Generator 可以认为是一个可中断执行的特殊函数，声明方法是在函数名后面加上<code>*</code>来与普通函数区分。<br>▼ <strong>注意点</strong><br>Generator 遇到<code>yield</code>关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果<code>console.log(number)</code>是一个耗时的工作，那么程序只在 Generator 里面暂停，外面的程序仍会继续执行。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> generator = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = generator();</span><br><span class=\"line\"><span class=\"keyword\">let</span> done = result.next();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!done.done) &#123;</span><br><span class=\"line\">  done = result.next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'finish'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">finish</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"集合类型\"><a href=\"#集合类型\" class=\"headerlink\" title=\"集合类型\"></a>集合类型</h2><h3 id=\"Set-amp-Map\"><a href=\"#Set-amp-Map\" class=\"headerlink\" title=\"Set &amp; Map\"></a>Set &amp; Map</h3><p>▼ <strong>为什么有了数组和对象来进行存储数据还要要使用 Map &amp; Set</strong></p>\n<ul>\n<li>对象的键名一般只能是字符串，而不能是一个对象；</li>\n<li>对象没有直接获取属性个数等这些方便操作的方法；</li>\n<li>对于对象的任何操作都需要进入对象的内部数据中完成，如查找、删除某个值必须循环遍历对象内部的所有键值对来完成。</li>\n</ul>\n<p>▼ <strong>Set的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set]</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p>Set 不会添加重复的值，并且可以接受一个数组（或者具有 Iterable 接口的其他数据解构）作为参数，用来初始化。<br>▼ <strong>Map的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;<span class=\"attr\">p</span>: <span class=\"string\">'Hello World'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(o, <span class=\"string\">'content'</span>)</span><br><span class=\"line\">m.get(o) <span class=\"comment\">// \"content\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.has(o) <span class=\"comment\">// true</span></span><br><span class=\"line\">m.delete(o) <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(o) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以作为键。</p>\n<h3 id=\"WeakSet-amp-WeakMap\"><a href=\"#WeakSet-amp-WeakMap\" class=\"headerlink\" title=\"WeakSet &amp; WeakMap\"></a>WeakSet &amp; WeakMap</h3><p>WeakSet 和 WeakMap 则对应着 Set 和 Map 的优化类型，所以某种程度上，为了让程序开发更加方便，我妈有必要引入集合这类更为高效的类型。WeakSet 和 WeakMap 在生成时有更加严格的限制：WeakSet 只存储对象类型的元素，不能遍历，没有<code>size</code>属性；WeakMap 只接受基本类型的值作为键名，没有<code>keys</code>、<code>values</code>、<code>entries</code>等遍历方法，也没有<code>size</code>属性。<br>▼ <strong>WeakSet的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]];</span><br><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(a);</span><br><span class=\"line\"><span class=\"comment\">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(b);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure></p>\n<p>▼ <strong>WeakMap的基本用法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm1 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> key = &#123;<span class=\"attr\">foo</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">wm1.set(key, <span class=\"number\">2</span>);</span><br><span class=\"line\">wm1.get(key) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// TypeError: 1 is not an object!</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组或对象循环遍历的方法对比\"><a href=\"#数组或对象循环遍历的方法对比\" class=\"headerlink\" title=\"数组或对象循环遍历的方法对比\"></a>数组或对象循环遍历的方法对比</h2><h3 id=\"for-while-循环语句\"><a href=\"#for-while-循环语句\" class=\"headerlink\" title=\"for/while 循环语句\"></a>for/while 循环语句</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有语言都会涉及的循环。不过单纯的for/while能力有限，而且性能上也堪忧。而且必须借助特定的结构才能遍历数据结构。</p>\n<h3 id=\"forEach-方法\"><a href=\"#forEach-方法\" class=\"headerlink\" title=\"forEach 方法\"></a>forEach 方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index + <span class=\"string\">':'</span> + value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>优点：</strong>可以同时获取index和value，不必再像以前遍历数组那样，还要再在for去获取值。<br><strong>缺点：</strong>仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。<br><strong>应用场景：</strong>仅在遍历数组的时候使用。</p>\n<h3 id=\"for…in-语句\"><a href=\"#for…in-语句\" class=\"headerlink\" title=\"for…in 语句\"></a>for…in 语句</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>,<span class=\"attr\">c</span>: <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(obj[key]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优点：</strong>它可以支持所有对象类型的数据，包括数组，甚至是函数等，而且语法简单。且不同于<code>forEach</code>方法，它可以与break、continue和return配合使用。<br><strong>缺点：</strong>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。主要是为遍历对象而设计的，不适用于遍历数组。<br><strong>应用场景：</strong> 遍历常用对象（如例子）</p>\n<h3 id=\"for…of-语句\"><a href=\"#for…of-语句\" class=\"headerlink\" title=\"for…of 语句\"></a>for…of 语句</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">list.set(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">list.set(<span class=\"string\">'b'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">list.set(<span class=\"string\">'c'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> list) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">':'</span> + value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>for...of</code>是ES6新增的语法，它是基于ES6新增的Iterator和Symbol开发的。<br><strong>优点：</strong>在遍历中直接取值。感觉上和<code>for...in</code>形成互补，一个在遍历中取键名，另一个取值。另一个优点是，它可以遍历任何部署了 Iterator 接口的数据结构（如 Set 和 Map），甚至是非 JavaScript 的数据类型，即自己定义的数据结构。<br><strong>缺点：</strong>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。<br><strong>应用场景：</strong>推荐应用于Map上的遍历。</p>\n<h3 id=\"map-amp-filter-amp-reduce\"><a href=\"#map-amp-filter-amp-reduce\" class=\"headerlink\" title=\"map() &amp; filter() &amp; reduce()\"></a>map() &amp; filter() &amp; reduce()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element &gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// [2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + element;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p><strong>应用场景：</strong>这三个方法都是是 Array 中的方法，常用于数组中的数值的处理。<code>map</code>主要用于对存储的数据进行加工，<code>filter</code>偏向于过滤数据，<code>reduce</code>用于计算总和。</p>\n<p>学习参考：<br><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6入门——阮一峰</a><br>《现代前端技术解析》</p>"},{"title":"JS变量、作用域和内存问题","date":"2017-08-15T12:30:52.000Z","_content":"## 变量\n\n### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n\n<!--more-->\n\n## 变量\n\n### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n```JavaScript\n//eg1\nvar num = 4;\nnum = 3; //这里的值操作并不是修改，而是覆盖\n\n//eg2\nvar str = 'string';\nvar anotherStr = str.replace('s',''); \n//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr\n\n```\n基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是`Number`，字符的包装对象是`String`。包装对象包含了这个类型的属性和方法。\n\n### 堆栈\n\n在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。\n\n因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-1.png)\n\n### 变量的比较\n\n```javascript\n//基本类型的比较\nvar xmScore = 4;\nvar xhScore =4;\nconsole.log(xmScore === xhScore) //true\n\n//引用类型的比较\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = {\n  age: 18,\n  score: 4\n};\nconsole.log(xm === xh); //false\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-2.png)\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-3.png)\n在引用类型中，只有指向同一个引用，变量才是相等的。\n\n\n```javascript\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用\nconsole.log(xm === xh); //true;\n```\n那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。\n```javascript\nfunction equalObjs(a,b) {\n  for(var p in a) {\n    if(a[p] !== b[p] return false;\n  }\n  return true;\n}\n\nfunction equalArrays(a,b) {\n  if(a.length !== b.length) return false;\n  for(var i = 0; i < a.length; i ++) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n```\n\n### 变量的复制\n\n当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。\n```javascript\nfunction copyObj(obj) {\n  var newObj = {};\n  for(var p in obj) {\n   newObj[p] = obj[p];\n  }\n  return newObj;\n}\n```\n以上的方法便是**浅拷贝**，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。\n* `$.extend(deep,target,object1,objectN)`\n参数说明：\n`deep`：可选。布尔值。指是否深度合并对象，默认`false`。\n`target`：目标对象，其他对象的成员属性将被附加到该对象上。\n`object1`：可选。指第一个被合并的对象。\n`objectN`：可选。指第N个被合并的对象。\n\n### 参数传递\n\n```javascript\nfunction fn(a,b) {\n  return a + b;\n} // 在函数里声明的a与b是形参\nfn(1,2); //在调用函数时传入的参数是实参\n```\n当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。\n```javascript\n//eg1 当变量为基本类型时\nfunction addTen(num) {\n  return num + 10;\n}\nvar score = 10;\naddTen(score);\n//相当于\nnum = score;\n\n//eg2 当变量为引用类型时\nfunction setName(obj) {\n  return obj.name = 'xm';\n}\nvar person = {};\nsetName(person);\n```\n当传递的参数是引用类型时，也相当于`obj = person`，因为引用类型赋值时是对地址进行复制的，所以`obj`与`person`实际上指向的都是同一个引用，所以我们对`obj`的修改也能反应到`person`上。\n\n### 类型检测\n\n`typeof`：返回字符串类型。可以区分基本类型，但是无法区分引用类型（`null`，对象和数组返回的都是`object`）。\n`instanceof`：用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法`[] instanceof Array`。\n\n## 作用域\n\n> 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量\n\n### 全局与局部\n\n在JS中，变量的作用域分为两种：全局变量和局部变量\n全局变量的声明方式有两种：\n```javascript\nvar n = 999; //直接在外部声明\nfunction f1() {\n  i = 888; //在函数内部声明，但是不适用var命令\n}\n```\n全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。\n在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用`{}`包含的域。在其他语言，例如C++，`if`和`for`中声明的变量在外部也是无法访问到的。但是JS中，在`if`和`for`中声明的变量在整个函数内部都可以访问。\n```\nfor(var i = 0; i < 10; i ++) { }\n//等同于\nvar i = 0;\nfor(i < 10; i ++) { }\n```\n\n### 变量的作用域链\n\n```javascript\nvar name = 'xm';\nfunuction fn(argument) {\n  var name = 'xh';\n  var sex = 'male';\n  function fn2(argument) {\n    var name = 'xhei';\n    var age = 18;\n  }\n}\n```\n\n所有全局空间中的属性和方法，都是属于window的（`window.name = 'xm';`）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（`fn.sex`与`fn.fn2`不存在）。\n作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。\n**作用链：** 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png)\n\n* **延长作用域链**\n\n```javascript\nvar person = {};\nperson.name = 'xm';\nperson.sex = 'male';\nvar score = 4;\n\nwith(person) {\n  name = 'xh';\n  sex = 'female';\n  score = 44;\n}\n\nconsole.log(person.name); //xh\nconsole.log(person.sex); //female\nconsole.log(score); //44\n```\n使用`with`的时候，当修改`name`与`sex`时，此时查找的作用域是`person`，但是`person`中并不存在`score`这个属性，于是with就随着作用域链查找到`window`下的`score`，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。\n\n* **闭包**\n\n在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //999\n  }\n  return f2; //将f2作为返回值\n}\n\nvar result = f1();\nresult(); //999\n```\n以上代码中的f2函数就是闭包，也就是闭包可以理解为**\"定义在一个函数内部的函数\"**。\n* **闭包的两个用途**：\n  * 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。\n  * 将某些变量的值始终保持在内存中。（JS的垃圾回收机制）\n\n### JS解析机制-预解析\n\nJS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。\n```javascript\nvar name = 'xm';\nvar age = 18;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\nfn(); //undefined\n```\n就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的`var`找出来，并且将所有的变量都赋值为`undefined`。然后查找该域中的`function`，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是`undefined`。\n```javascript\n//window域预解析\nvar name = undefiied;\nvar age = undefined;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\n\n//fn域预解析\nvar name = undefined;\nvar age = undefined;\n\n//逐行解析\nname = 'xm';\nage = 18;\nfn(argument) {\n  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined\n  name = 'xh';\n  age = 10;\n}\n```\n在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。\n```javascript\nconsole.log(a);\na = 1; //预解析不解析没有var的变量，所以浏览器会报错\n```\n\n## 内存\n\n### 垃圾回收机制\n**垃圾回收机制：**释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。\n**标识无用数据的策略：**\n  * **标记清除：**垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。**环境中的变量**指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。\n  * **引用计数：**引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。\n  * **循环引用问题：**\n  \n```javascript\nfunction fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n}\nfun();\nxm = null; //0\nxh = null; //0\n\nfunctioni fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n  xm.wife = xh; //2\n  xh.husband = xm; //2\n}\nfn();\nxm = null; //1\nxh = null; //1\n```\n由于`xm`与`xh`相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。\n\n### 管理内存\n\n为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为`null`。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","source":"_posts/JS变量、作用域和内存问题.md","raw":"---\ntitle: JS变量、作用域和内存问题\ndate: 2017-08-15 20:30:52\ncategories: JS相关\ntags: \n  - JavaScript\n---\n## 变量\n\n### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n\n<!--more-->\n\n## 变量\n\n### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n```JavaScript\n//eg1\nvar num = 4;\nnum = 3; //这里的值操作并不是修改，而是覆盖\n\n//eg2\nvar str = 'string';\nvar anotherStr = str.replace('s',''); \n//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr\n\n```\n基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是`Number`，字符的包装对象是`String`。包装对象包含了这个类型的属性和方法。\n\n### 堆栈\n\n在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。\n\n因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-1.png)\n\n### 变量的比较\n\n```javascript\n//基本类型的比较\nvar xmScore = 4;\nvar xhScore =4;\nconsole.log(xmScore === xhScore) //true\n\n//引用类型的比较\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = {\n  age: 18,\n  score: 4\n};\nconsole.log(xm === xh); //false\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-2.png)\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-3.png)\n在引用类型中，只有指向同一个引用，变量才是相等的。\n\n\n```javascript\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用\nconsole.log(xm === xh); //true;\n```\n那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。\n```javascript\nfunction equalObjs(a,b) {\n  for(var p in a) {\n    if(a[p] !== b[p] return false;\n  }\n  return true;\n}\n\nfunction equalArrays(a,b) {\n  if(a.length !== b.length) return false;\n  for(var i = 0; i < a.length; i ++) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n```\n\n### 变量的复制\n\n当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。\n```javascript\nfunction copyObj(obj) {\n  var newObj = {};\n  for(var p in obj) {\n   newObj[p] = obj[p];\n  }\n  return newObj;\n}\n```\n以上的方法便是**浅拷贝**，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。\n* `$.extend(deep,target,object1,objectN)`\n参数说明：\n`deep`：可选。布尔值。指是否深度合并对象，默认`false`。\n`target`：目标对象，其他对象的成员属性将被附加到该对象上。\n`object1`：可选。指第一个被合并的对象。\n`objectN`：可选。指第N个被合并的对象。\n\n### 参数传递\n\n```javascript\nfunction fn(a,b) {\n  return a + b;\n} // 在函数里声明的a与b是形参\nfn(1,2); //在调用函数时传入的参数是实参\n```\n当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。\n```javascript\n//eg1 当变量为基本类型时\nfunction addTen(num) {\n  return num + 10;\n}\nvar score = 10;\naddTen(score);\n//相当于\nnum = score;\n\n//eg2 当变量为引用类型时\nfunction setName(obj) {\n  return obj.name = 'xm';\n}\nvar person = {};\nsetName(person);\n```\n当传递的参数是引用类型时，也相当于`obj = person`，因为引用类型赋值时是对地址进行复制的，所以`obj`与`person`实际上指向的都是同一个引用，所以我们对`obj`的修改也能反应到`person`上。\n\n### 类型检测\n\n`typeof`：返回字符串类型。可以区分基本类型，但是无法区分引用类型（`null`，对象和数组返回的都是`object`）。\n`instanceof`：用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法`[] instanceof Array`。\n\n## 作用域\n\n> 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量\n\n### 全局与局部\n\n在JS中，变量的作用域分为两种：全局变量和局部变量\n全局变量的声明方式有两种：\n```javascript\nvar n = 999; //直接在外部声明\nfunction f1() {\n  i = 888; //在函数内部声明，但是不适用var命令\n}\n```\n全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。\n在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用`{}`包含的域。在其他语言，例如C++，`if`和`for`中声明的变量在外部也是无法访问到的。但是JS中，在`if`和`for`中声明的变量在整个函数内部都可以访问。\n```\nfor(var i = 0; i < 10; i ++) { }\n//等同于\nvar i = 0;\nfor(i < 10; i ++) { }\n```\n\n### 变量的作用域链\n\n```javascript\nvar name = 'xm';\nfunuction fn(argument) {\n  var name = 'xh';\n  var sex = 'male';\n  function fn2(argument) {\n    var name = 'xhei';\n    var age = 18;\n  }\n}\n```\n\n所有全局空间中的属性和方法，都是属于window的（`window.name = 'xm';`）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（`fn.sex`与`fn.fn2`不存在）。\n作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。\n**作用链：** 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png)\n\n* **延长作用域链**\n\n```javascript\nvar person = {};\nperson.name = 'xm';\nperson.sex = 'male';\nvar score = 4;\n\nwith(person) {\n  name = 'xh';\n  sex = 'female';\n  score = 44;\n}\n\nconsole.log(person.name); //xh\nconsole.log(person.sex); //female\nconsole.log(score); //44\n```\n使用`with`的时候，当修改`name`与`sex`时，此时查找的作用域是`person`，但是`person`中并不存在`score`这个属性，于是with就随着作用域链查找到`window`下的`score`，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。\n\n* **闭包**\n\n在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //999\n  }\n  return f2; //将f2作为返回值\n}\n\nvar result = f1();\nresult(); //999\n```\n以上代码中的f2函数就是闭包，也就是闭包可以理解为**\"定义在一个函数内部的函数\"**。\n* **闭包的两个用途**：\n  * 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。\n  * 将某些变量的值始终保持在内存中。（JS的垃圾回收机制）\n\n### JS解析机制-预解析\n\nJS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。\n```javascript\nvar name = 'xm';\nvar age = 18;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\nfn(); //undefined\n```\n就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的`var`找出来，并且将所有的变量都赋值为`undefined`。然后查找该域中的`function`，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是`undefined`。\n```javascript\n//window域预解析\nvar name = undefiied;\nvar age = undefined;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\n\n//fn域预解析\nvar name = undefined;\nvar age = undefined;\n\n//逐行解析\nname = 'xm';\nage = 18;\nfn(argument) {\n  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined\n  name = 'xh';\n  age = 10;\n}\n```\n在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。\n```javascript\nconsole.log(a);\na = 1; //预解析不解析没有var的变量，所以浏览器会报错\n```\n\n## 内存\n\n### 垃圾回收机制\n**垃圾回收机制：**释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。\n**标识无用数据的策略：**\n  * **标记清除：**垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。**环境中的变量**指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。\n  * **引用计数：**引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。\n  * **循环引用问题：**\n  \n```javascript\nfunction fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n}\nfun();\nxm = null; //0\nxh = null; //0\n\nfunctioni fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n  xm.wife = xh; //2\n  xh.husband = xm; //2\n}\nfn();\nxm = null; //1\nxh = null; //1\n```\n由于`xm`与`xh`相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。\n\n### 管理内存\n\n为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为`null`。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","slug":"JS变量、作用域和内存问题","published":1,"updated":"2020-01-08T13:48:10.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl9x000ufr03eg480ig7","content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"变量-1\"><a href=\"#变量-1\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"数据类型-1\"><a href=\"#数据类型-1\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">4</span>;</span><br><span class=\"line\">num = <span class=\"number\">3</span>; <span class=\"comment\">//这里的值操作并不是修改，而是覆盖</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//eg2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'string'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.replace(<span class=\"string\">'s'</span>,<span class=\"string\">''</span>); </span><br><span class=\"line\"><span class=\"comment\">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>\n<h3 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h3><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>\n<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png\" alt></p>\n<h3 id=\"变量的比较\"><a href=\"#变量的比较\" class=\"headerlink\" title=\"变量的比较\"></a>变量的比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本类型的比较</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xmScore = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xhScore =<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(xmScore === xhScore) <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用类型的比较</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  score: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  score: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png\" alt><br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png\" alt><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  score: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xh = xm; <span class=\"comment\">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//true;</span></span><br></pre></td></tr></table></figure>\n<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalObjs</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[p] !== b[p] <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalArrays</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(a.length !== b.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[i] !== b[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的复制\"><a href=\"#变量的复制\" class=\"headerlink\" title=\"变量的复制\"></a>变量的复制</h3><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObj</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">   newObj[p] = obj[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>\n<ul>\n<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>\n</ul>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 在函数里声明的a与b是形参</span></span><br><span class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//在调用函数时传入的参数是实参</span></span><br></pre></td></tr></table></figure>\n<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg1 当变量为基本类型时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTen</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">10</span>;</span><br><span class=\"line\">addTen(score);</span><br><span class=\"line\"><span class=\"comment\">//相当于</span></span><br><span class=\"line\">num = score;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//eg2 当变量为引用类型时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj.name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</span><br><span class=\"line\">setName(person);</span><br></pre></td></tr></table></figure></p>\n<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>\n<h3 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h3><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>\n</blockquote>\n<h3 id=\"全局与局部\"><a href=\"#全局与局部\" class=\"headerlink\" title=\"全局与局部\"></a>全局与局部</h3><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">999</span>; <span class=\"comment\">//直接在外部声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"number\">888</span>; <span class=\"comment\">//在函数内部声明，但是不适用var命令</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</span><br><span class=\"line\">//等同于</span><br><span class=\"line\">var i = 0;</span><br><span class=\"line\">for(i &lt; 10; i ++) &#123; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的作用域链\"><a href=\"#变量的作用域链\" class=\"headerlink\" title=\"变量的作用域链\"></a>变量的作用域链</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">funuction fn(argument) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sex = <span class=\"string\">'male'</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'xhei'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png\" alt></p>\n<ul>\n<li><strong>延长作用域链</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</span><br><span class=\"line\">person.name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">person.sex = <span class=\"string\">'male'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span>(person) &#123;</span><br><span class=\"line\">  name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  sex = <span class=\"string\">'female'</span>;</span><br><span class=\"line\">  score = <span class=\"number\">44</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">//xh</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//female</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(score); <span class=\"comment\">//44</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>\n<ul>\n<li><strong>闭包</strong></li>\n</ul>\n<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n); <span class=\"comment\">//999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2; <span class=\"comment\">//将f2作为返回值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f1();</span><br><span class=\"line\">result(); <span class=\"comment\">//999</span></span><br></pre></td></tr></table></figure></p>\n<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>\n<ul>\n<li><strong>闭包的两个用途</strong>：<ul>\n<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>\n<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JS解析机制-预解析\"><a href=\"#JS解析机制-预解析\" class=\"headerlink\" title=\"JS解析机制-预解析\"></a>JS解析机制-预解析</h3><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//window域预解析</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = undefiied;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//fn域预解析</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//逐行解析</span></span><br><span class=\"line\">name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">age = <span class=\"number\">18</span>;</span><br><span class=\"line\">fn(argument) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">//此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</span></span><br><span class=\"line\">  name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">a = <span class=\"number\">1</span>; <span class=\"comment\">//预解析不解析没有var的变量，所以浏览器会报错</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>\n<ul>\n<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>\n<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>\n<li><strong>循环引用问题：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();</span><br><span class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></span><br><span class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></span><br><span class=\"line\"></span><br><span class=\"line\">functioni fn(argument) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">  xm.wife = xh; <span class=\"comment\">//2</span></span><br><span class=\"line\">  xh.husband = xm; <span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br><span class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></span><br><span class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>\n<h3 id=\"管理内存\"><a href=\"#管理内存\" class=\"headerlink\" title=\"管理内存\"></a>管理内存</h3><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改</li>\n</ul>","more":"<h2 id=\"变量-1\"><a href=\"#变量-1\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"数据类型-1\"><a href=\"#数据类型-1\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">4</span>;</span><br><span class=\"line\">num = <span class=\"number\">3</span>; <span class=\"comment\">//这里的值操作并不是修改，而是覆盖</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//eg2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'string'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.replace(<span class=\"string\">'s'</span>,<span class=\"string\">''</span>); </span><br><span class=\"line\"><span class=\"comment\">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>\n<h3 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h3><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>\n<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png\" alt></p>\n<h3 id=\"变量的比较\"><a href=\"#变量的比较\" class=\"headerlink\" title=\"变量的比较\"></a>变量的比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本类型的比较</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xmScore = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xhScore =<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(xmScore === xhScore) <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用类型的比较</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  score: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  score: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png\" alt><br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png\" alt><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">18</span>,</span><br><span class=\"line\">  score: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xh = xm; <span class=\"comment\">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//true;</span></span><br></pre></td></tr></table></figure>\n<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalObjs</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[p] !== b[p] <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalArrays</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(a.length !== b.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[i] !== b[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的复制\"><a href=\"#变量的复制\" class=\"headerlink\" title=\"变量的复制\"></a>变量的复制</h3><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObj</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">   newObj[p] = obj[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>\n<ul>\n<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>\n</ul>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 在函数里声明的a与b是形参</span></span><br><span class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//在调用函数时传入的参数是实参</span></span><br></pre></td></tr></table></figure>\n<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg1 当变量为基本类型时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTen</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">10</span>;</span><br><span class=\"line\">addTen(score);</span><br><span class=\"line\"><span class=\"comment\">//相当于</span></span><br><span class=\"line\">num = score;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//eg2 当变量为引用类型时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj.name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</span><br><span class=\"line\">setName(person);</span><br></pre></td></tr></table></figure></p>\n<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>\n<h3 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h3><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>\n</blockquote>\n<h3 id=\"全局与局部\"><a href=\"#全局与局部\" class=\"headerlink\" title=\"全局与局部\"></a>全局与局部</h3><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">999</span>; <span class=\"comment\">//直接在外部声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"number\">888</span>; <span class=\"comment\">//在函数内部声明，但是不适用var命令</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</span><br><span class=\"line\">//等同于</span><br><span class=\"line\">var i = 0;</span><br><span class=\"line\">for(i &lt; 10; i ++) &#123; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的作用域链\"><a href=\"#变量的作用域链\" class=\"headerlink\" title=\"变量的作用域链\"></a>变量的作用域链</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">funuction fn(argument) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sex = <span class=\"string\">'male'</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'xhei'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png\" alt></p>\n<ul>\n<li><strong>延长作用域链</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</span><br><span class=\"line\">person.name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">person.sex = <span class=\"string\">'male'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span>(person) &#123;</span><br><span class=\"line\">  name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  sex = <span class=\"string\">'female'</span>;</span><br><span class=\"line\">  score = <span class=\"number\">44</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">//xh</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//female</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(score); <span class=\"comment\">//44</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>\n<ul>\n<li><strong>闭包</strong></li>\n</ul>\n<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n); <span class=\"comment\">//999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2; <span class=\"comment\">//将f2作为返回值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f1();</span><br><span class=\"line\">result(); <span class=\"comment\">//999</span></span><br></pre></td></tr></table></figure></p>\n<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>\n<ul>\n<li><strong>闭包的两个用途</strong>：<ul>\n<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>\n<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JS解析机制-预解析\"><a href=\"#JS解析机制-预解析\" class=\"headerlink\" title=\"JS解析机制-预解析\"></a>JS解析机制-预解析</h3><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//window域预解析</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = undefiied;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//fn域预解析</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//逐行解析</span></span><br><span class=\"line\">name = <span class=\"string\">'xm'</span>;</span><br><span class=\"line\">age = <span class=\"number\">18</span>;</span><br><span class=\"line\">fn(argument) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">//此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</span></span><br><span class=\"line\">  name = <span class=\"string\">'xh'</span>;</span><br><span class=\"line\">  age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">a = <span class=\"number\">1</span>; <span class=\"comment\">//预解析不解析没有var的变量，所以浏览器会报错</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>\n<ul>\n<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>\n<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>\n<li><strong>循环引用问题：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();</span><br><span class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></span><br><span class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></span><br><span class=\"line\"></span><br><span class=\"line\">functioni fn(argument) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></span><br><span class=\"line\">  xm.wife = xh; <span class=\"comment\">//2</span></span><br><span class=\"line\">  xh.husband = xm; <span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br><span class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></span><br><span class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>\n<h3 id=\"管理内存\"><a href=\"#管理内存\" class=\"headerlink\" title=\"管理内存\"></a>管理内存</h3><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>"},{"title":"网络知识补充——浏览器请求过程","date":"2017-08-17T12:49:56.000Z","_content":"当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n<!-- more -->\n\n当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。\n以Chrome浏览器为例，其解析过程：\n* 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存\n* 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）\n* 读取本地的HOST文件（操作系统的DNS缓存也没有找到）\n* 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求\n\n紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：\n* 查找本地缓存\n* 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求\n* 将迭代查询后的结果返回给操作系统内核同时进行缓存\n\n之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入`Controller`层，进行相关的逻辑处理，以及请求的分发，然后来调用`Model`层，`Model`层主要负责与数据的交互，在交互过程中会它会读取`redis`和数据库中存储的数据，最终将渲染好的页面通过`View`层返回给网络。这时，`httpResponse`就通过层层网络回到浏览器，浏览器根据请求回来的`html`、`css`、`js`进行渲染，最终将页面展现在我们面前。\n\n## DNS\n\nDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：`http://www.baidu.com/`，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。\n**Tip：**电脑中的HOST文件是通过静态匹配IP和域名\n\n### 域名空间结构\n\n* 根域：`.`，根域名的服务器只有13台\n* 顶级域（一级域）：`edu`、`gov`、`com`、`org`、`mil`、`cn`等，由域名分配组织ISO决定\n  * 组织域\n  ```\n  gov         政府部门\n  com         商业部门\n  edu         教育部门\n  org         民间团体组织\n  net         网络服务机构\n  mil         军事部门\n  ```\n  * 国家或地区域\n  ```\n  cn          中国\n  jp          日本\n  uk          英国\n  au          澳大利亚\n  hk          中国香港\n  ```\n* 二级域：个人和企业向域名分配组织申请的，需要购买，如`baidu`、`sina`等\n* 主机名（三级域）：申请完二级域名后自己规定的，如`www`（代表网页服务）、`NEWS`\n\n一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。\n在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。\n\n### DNS查询过程\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png)\n\n客户机向指定的域名服务器发送请求，说我想要访问`www.baidu.com.cn`这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（`cn`）的IP地址，紧接着本地域名服务器就向`cn`服务器发送询问，`cn`服务器返回`com.cn`服务器的IP，然后本地服务器接着询问，直到找到`www.baidu.com.cn`的IP地址，再返回给客户机。这个过程就是**DNS迭代查询**。\n\n## ISO/OSI 七层模型\n\n### 基本概念\n\n* ISO：国际标准化组织\n* OSI：开放系统互联模型\n* IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统\n* OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png)\n\n每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。 \n**注意点：**各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。\n\n**为什么要进行分层？**\n\n因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。\n\n**传输单位：**\n  * 比特：bit，机器码的传输单位，每个0或1就是一个比特。\n  * 帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。\n  * 报文：保存的基本信息为IP地址（负责外网通信）。\n  * TPDU：传输协议数据单元。\n  * APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。\n\n### 七层详解\n\n* 物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）\n* 数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。\n* 网络层：提供逻辑地址（IP）、选路。\n* 传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）\n* 会话层：对应用会话的管理、同步。\n* 表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。\n* 应用层：用户接口（可以理解为各自桌面应用）。\n\n## TCP/IP 四层模型\n\n### 基本概念\n\n* 网络接口层：与OSI参考模型中的**物理层**和**数据链路层**相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。**地址解析协议（ARP）**工作在此层，即OSI参考模型的数据链路层。\n* 网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：**网际协议（IP）**、**互联网组管理协议（IGMP）**和**互联网控制报文协议（ICMP）**。\n* 传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：**传输控制协议（TCP）**和**用户数据报协议（UDP）**。\n* 应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png)\n\n### 比较\n\n* 共同点：\n    * 都采用了层次结构的概念；\n    * 都能够提供面向连接和无连接两种通信服务机制；\n* 不同点：\n    * 前者七层模型，后者四层结构；\n    * 对可靠性的要求不同（后者更高）；\n    * OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。\n    * 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。\n\n## TCP/IP 通信\n\n**当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？**\n\n首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。\n在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。\n\n### IP协议 \n\nIP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是**IP地址**和**MAC地址**（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。\n\n**APR协议：**通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。\n**路由选择：**在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。\n\n### TCP协议\n\nTCP协议位于传输层，提供可靠的字节流服务。其中**字节流服务**是指，将大块的数据分割成以报文为单位的数据包进行管理。**可靠的传输服务**是指能够把数据准确可靠的传给对方。\n\n**三次握手：**为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。\n\n发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n>**「我给你讲个TCP的笑话吧」**\n\n>“我给你讲一个TCP的笑话吧？”\n>“给我讲一个TCP笑话呗！”\n>“好的，我会给你讲一个TCP的笑话。”\n\n**TCP与UDP比较：**UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。\n","source":"_posts/网络知识补充——浏览器请求过程.md","raw":"---\ntitle: 网络知识补充——浏览器请求过程\ndate: 2017-08-17 20:49:56\ncategories: 知识碎片\ntags:\n  - 网络知识\n---\n当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n<!-- more -->\n\n当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。\n以Chrome浏览器为例，其解析过程：\n* 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存\n* 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）\n* 读取本地的HOST文件（操作系统的DNS缓存也没有找到）\n* 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求\n\n紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：\n* 查找本地缓存\n* 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求\n* 将迭代查询后的结果返回给操作系统内核同时进行缓存\n\n之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入`Controller`层，进行相关的逻辑处理，以及请求的分发，然后来调用`Model`层，`Model`层主要负责与数据的交互，在交互过程中会它会读取`redis`和数据库中存储的数据，最终将渲染好的页面通过`View`层返回给网络。这时，`httpResponse`就通过层层网络回到浏览器，浏览器根据请求回来的`html`、`css`、`js`进行渲染，最终将页面展现在我们面前。\n\n## DNS\n\nDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：`http://www.baidu.com/`，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。\n**Tip：**电脑中的HOST文件是通过静态匹配IP和域名\n\n### 域名空间结构\n\n* 根域：`.`，根域名的服务器只有13台\n* 顶级域（一级域）：`edu`、`gov`、`com`、`org`、`mil`、`cn`等，由域名分配组织ISO决定\n  * 组织域\n  ```\n  gov         政府部门\n  com         商业部门\n  edu         教育部门\n  org         民间团体组织\n  net         网络服务机构\n  mil         军事部门\n  ```\n  * 国家或地区域\n  ```\n  cn          中国\n  jp          日本\n  uk          英国\n  au          澳大利亚\n  hk          中国香港\n  ```\n* 二级域：个人和企业向域名分配组织申请的，需要购买，如`baidu`、`sina`等\n* 主机名（三级域）：申请完二级域名后自己规定的，如`www`（代表网页服务）、`NEWS`\n\n一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。\n在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。\n\n### DNS查询过程\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png)\n\n客户机向指定的域名服务器发送请求，说我想要访问`www.baidu.com.cn`这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（`cn`）的IP地址，紧接着本地域名服务器就向`cn`服务器发送询问，`cn`服务器返回`com.cn`服务器的IP，然后本地服务器接着询问，直到找到`www.baidu.com.cn`的IP地址，再返回给客户机。这个过程就是**DNS迭代查询**。\n\n## ISO/OSI 七层模型\n\n### 基本概念\n\n* ISO：国际标准化组织\n* OSI：开放系统互联模型\n* IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统\n* OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png)\n\n每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。 \n**注意点：**各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。\n\n**为什么要进行分层？**\n\n因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。\n\n**传输单位：**\n  * 比特：bit，机器码的传输单位，每个0或1就是一个比特。\n  * 帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。\n  * 报文：保存的基本信息为IP地址（负责外网通信）。\n  * TPDU：传输协议数据单元。\n  * APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。\n\n### 七层详解\n\n* 物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）\n* 数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。\n* 网络层：提供逻辑地址（IP）、选路。\n* 传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）\n* 会话层：对应用会话的管理、同步。\n* 表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。\n* 应用层：用户接口（可以理解为各自桌面应用）。\n\n## TCP/IP 四层模型\n\n### 基本概念\n\n* 网络接口层：与OSI参考模型中的**物理层**和**数据链路层**相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。**地址解析协议（ARP）**工作在此层，即OSI参考模型的数据链路层。\n* 网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：**网际协议（IP）**、**互联网组管理协议（IGMP）**和**互联网控制报文协议（ICMP）**。\n* 传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：**传输控制协议（TCP）**和**用户数据报协议（UDP）**。\n* 应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png)\n\n### 比较\n\n* 共同点：\n    * 都采用了层次结构的概念；\n    * 都能够提供面向连接和无连接两种通信服务机制；\n* 不同点：\n    * 前者七层模型，后者四层结构；\n    * 对可靠性的要求不同（后者更高）；\n    * OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。\n    * 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。\n\n## TCP/IP 通信\n\n**当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？**\n\n首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。\n在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。\n\n### IP协议 \n\nIP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是**IP地址**和**MAC地址**（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。\n\n**APR协议：**通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。\n**路由选择：**在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。\n\n### TCP协议\n\nTCP协议位于传输层，提供可靠的字节流服务。其中**字节流服务**是指，将大块的数据分割成以报文为单位的数据包进行管理。**可靠的传输服务**是指能够把数据准确可靠的传给对方。\n\n**三次握手：**为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。\n\n发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n>**「我给你讲个TCP的笑话吧」**\n\n>“我给你讲一个TCP的笑话吧？”\n>“给我讲一个TCP笑话呗！”\n>“好的，我会给你讲一个TCP的笑话。”\n\n**TCP与UDP比较：**UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。\n","slug":"网络知识补充——浏览器请求过程","published":1,"updated":"2020-01-08T13:48:10.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfl9y000vfr03iggltpup","content":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt></p>\n<a id=\"more\"></a>\n<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt></p>\n<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>\n<ul>\n<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>\n<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>\n<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>\n<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>\n</ul>\n<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>\n<ul>\n<li>查找本地缓存</li>\n<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>\n<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>\n</ul>\n<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>\n<h3 id=\"域名空间结构\"><a href=\"#域名空间结构\" class=\"headerlink\" title=\"域名空间结构\"></a>域名空间结构</h3><ul>\n<li>根域：<code>.</code>，根域名的服务器只有13台</li>\n<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>\n<ul>\n<li><p>组织域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gov         政府部门</span><br><span class=\"line\">com         商业部门</span><br><span class=\"line\">edu         教育部门</span><br><span class=\"line\">org         民间团体组织</span><br><span class=\"line\">net         网络服务机构</span><br><span class=\"line\">mil         军事部门</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>国家或地区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cn          中国</span><br><span class=\"line\">jp          日本</span><br><span class=\"line\">uk          英国</span><br><span class=\"line\">au          澳大利亚</span><br><span class=\"line\">hk          中国香港</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>\n</li>\n<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>\n</ul>\n<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>\n<h3 id=\"DNS查询过程\"><a href=\"#DNS查询过程\" class=\"headerlink\" title=\"DNS查询过程\"></a>DNS查询过程</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png\" alt></p>\n<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>\n<h2 id=\"ISO-OSI-七层模型\"><a href=\"#ISO-OSI-七层模型\" class=\"headerlink\" title=\"ISO/OSI 七层模型\"></a>ISO/OSI 七层模型</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>ISO：国际标准化组织</li>\n<li>OSI：开放系统互联模型</li>\n<li>IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统</li>\n<li>OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png\" alt></p>\n<p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。<br><strong>注意点：</strong>各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。</p>\n<p><strong>为什么要进行分层？</strong></p>\n<p>因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。</p>\n<p><strong>传输单位：</strong></p>\n<ul>\n<li>比特：bit，机器码的传输单位，每个0或1就是一个比特。</li>\n<li>帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。</li>\n<li>报文：保存的基本信息为IP地址（负责外网通信）。</li>\n<li>TPDU：传输协议数据单元。</li>\n<li>APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。</li>\n</ul>\n<h3 id=\"七层详解\"><a href=\"#七层详解\" class=\"headerlink\" title=\"七层详解\"></a>七层详解</h3><ul>\n<li>物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）</li>\n<li>数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。</li>\n<li>网络层：提供逻辑地址（IP）、选路。</li>\n<li>传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）</li>\n<li>会话层：对应用会话的管理、同步。</li>\n<li>表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。</li>\n<li>应用层：用户接口（可以理解为各自桌面应用）。</li>\n</ul>\n<h2 id=\"TCP-IP-四层模型\"><a href=\"#TCP-IP-四层模型\" class=\"headerlink\" title=\"TCP/IP 四层模型\"></a>TCP/IP 四层模型</h2><h3 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>网络接口层：与OSI参考模型中的<strong>物理层</strong>和<strong>数据链路层</strong>相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。<strong>地址解析协议（ARP）</strong>工作在此层，即OSI参考模型的数据链路层。</li>\n<li>网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：<strong>网际协议（IP）</strong>、<strong>互联网组管理协议（IGMP）</strong>和<strong>互联网控制报文协议（ICMP）</strong>。</li>\n<li>传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：<strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议（UDP）</strong>。</li>\n<li>应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png\" alt></p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><ul>\n<li>共同点：<ul>\n<li>都采用了层次结构的概念；</li>\n<li>都能够提供面向连接和无连接两种通信服务机制；</li>\n</ul>\n</li>\n<li>不同点：<ul>\n<li>前者七层模型，后者四层结构；</li>\n<li>对可靠性的要求不同（后者更高）；</li>\n<li>OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。</li>\n<li>实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP-IP-通信\"><a href=\"#TCP-IP-通信\" class=\"headerlink\" title=\"TCP/IP 通信\"></a>TCP/IP 通信</h2><p><strong>当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？</strong></p>\n<p>首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是<strong>IP地址</strong>和<strong>MAC地址</strong>（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p>\n<p><strong>APR协议：</strong>通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。<br><strong>路由选择：</strong>在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP协议位于传输层，提供可靠的字节流服务。其中<strong>字节流服务</strong>是指，将大块的数据分割成以报文为单位的数据包进行管理。<strong>可靠的传输服务</strong>是指能够把数据准确可靠的传给对方。</p>\n<p><strong>三次握手：</strong>为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>\n<blockquote>\n<p><strong>「我给你讲个TCP的笑话吧」</strong></p>\n<p>“我给你讲一个TCP的笑话吧？”<br>“给我讲一个TCP笑话呗！”<br>“好的，我会给你讲一个TCP的笑话。”</p>\n</blockquote>\n<p><strong>TCP与UDP比较：</strong>UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。</p>\n","site":{"data":{}},"excerpt":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt></p>","more":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt></p>\n<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>\n<ul>\n<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>\n<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>\n<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>\n<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>\n</ul>\n<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>\n<ul>\n<li>查找本地缓存</li>\n<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>\n<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>\n</ul>\n<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>\n<h3 id=\"域名空间结构\"><a href=\"#域名空间结构\" class=\"headerlink\" title=\"域名空间结构\"></a>域名空间结构</h3><ul>\n<li>根域：<code>.</code>，根域名的服务器只有13台</li>\n<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>\n<ul>\n<li><p>组织域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gov         政府部门</span><br><span class=\"line\">com         商业部门</span><br><span class=\"line\">edu         教育部门</span><br><span class=\"line\">org         民间团体组织</span><br><span class=\"line\">net         网络服务机构</span><br><span class=\"line\">mil         军事部门</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>国家或地区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cn          中国</span><br><span class=\"line\">jp          日本</span><br><span class=\"line\">uk          英国</span><br><span class=\"line\">au          澳大利亚</span><br><span class=\"line\">hk          中国香港</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>\n</li>\n<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>\n</ul>\n<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>\n<h3 id=\"DNS查询过程\"><a href=\"#DNS查询过程\" class=\"headerlink\" title=\"DNS查询过程\"></a>DNS查询过程</h3><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png\" alt></p>\n<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>\n<h2 id=\"ISO-OSI-七层模型\"><a href=\"#ISO-OSI-七层模型\" class=\"headerlink\" title=\"ISO/OSI 七层模型\"></a>ISO/OSI 七层模型</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>ISO：国际标准化组织</li>\n<li>OSI：开放系统互联模型</li>\n<li>IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统</li>\n<li>OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png\" alt></p>\n<p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。<br><strong>注意点：</strong>各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。</p>\n<p><strong>为什么要进行分层？</strong></p>\n<p>因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。</p>\n<p><strong>传输单位：</strong></p>\n<ul>\n<li>比特：bit，机器码的传输单位，每个0或1就是一个比特。</li>\n<li>帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。</li>\n<li>报文：保存的基本信息为IP地址（负责外网通信）。</li>\n<li>TPDU：传输协议数据单元。</li>\n<li>APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。</li>\n</ul>\n<h3 id=\"七层详解\"><a href=\"#七层详解\" class=\"headerlink\" title=\"七层详解\"></a>七层详解</h3><ul>\n<li>物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）</li>\n<li>数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。</li>\n<li>网络层：提供逻辑地址（IP）、选路。</li>\n<li>传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）</li>\n<li>会话层：对应用会话的管理、同步。</li>\n<li>表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。</li>\n<li>应用层：用户接口（可以理解为各自桌面应用）。</li>\n</ul>\n<h2 id=\"TCP-IP-四层模型\"><a href=\"#TCP-IP-四层模型\" class=\"headerlink\" title=\"TCP/IP 四层模型\"></a>TCP/IP 四层模型</h2><h3 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>网络接口层：与OSI参考模型中的<strong>物理层</strong>和<strong>数据链路层</strong>相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。<strong>地址解析协议（ARP）</strong>工作在此层，即OSI参考模型的数据链路层。</li>\n<li>网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：<strong>网际协议（IP）</strong>、<strong>互联网组管理协议（IGMP）</strong>和<strong>互联网控制报文协议（ICMP）</strong>。</li>\n<li>传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：<strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议（UDP）</strong>。</li>\n<li>应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png\" alt></p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><ul>\n<li>共同点：<ul>\n<li>都采用了层次结构的概念；</li>\n<li>都能够提供面向连接和无连接两种通信服务机制；</li>\n</ul>\n</li>\n<li>不同点：<ul>\n<li>前者七层模型，后者四层结构；</li>\n<li>对可靠性的要求不同（后者更高）；</li>\n<li>OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。</li>\n<li>实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP-IP-通信\"><a href=\"#TCP-IP-通信\" class=\"headerlink\" title=\"TCP/IP 通信\"></a>TCP/IP 通信</h2><p><strong>当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？</strong></p>\n<p>首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是<strong>IP地址</strong>和<strong>MAC地址</strong>（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p>\n<p><strong>APR协议：</strong>通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。<br><strong>路由选择：</strong>在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP协议位于传输层，提供可靠的字节流服务。其中<strong>字节流服务</strong>是指，将大块的数据分割成以报文为单位的数据包进行管理。<strong>可靠的传输服务</strong>是指能够把数据准确可靠的传给对方。</p>\n<p><strong>三次握手：</strong>为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>\n<blockquote>\n<p><strong>「我给你讲个TCP的笑话吧」</strong></p>\n<p>“我给你讲一个TCP的笑话吧？”<br>“给我讲一个TCP笑话呗！”<br>“好的，我会给你讲一个TCP的笑话。”</p>\n</blockquote>\n<p><strong>TCP与UDP比较：</strong>UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。</p>"},{"title":"页面加载——浏览器渲染","date":"2017-08-19T10:46:53.000Z","_content":"一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n\n<!-- more -->\n\n一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n\n## 顺序执行、并发加载\n\n因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入`<link>`或`<script>`，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。\n\n对于`<img>`所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。\n\n```javascript\nwindow.addEventListener('load', function() {\n  // 页面的全部资源加载完才会执行，包括图片、视频\n})\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // DOM 渲染完即可执行，此时图片、视频可能还没加载完\n})\n```\n\n## 阻塞\n\n### CSS阻塞\n* **css在`<head>`中阻塞页面的渲染：**即这个页面要呈现出效果需要等待这个`<link>`所对应的css资源加载完成以后才能进行渲染。如果css并不是在`<head>`中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在`<head>`标签中就引入。\n* **css阻塞js的执行：**即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作`DOM`元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。\n* **css不阻塞外部脚本的加载：**即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在`HTMLPreloadScanner`类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。\n\n### JS阻塞\n* **直接引入的js阻塞页面的渲染：**直接引入指的是没有通过`defer`和`async`方法直接用`<script>`引入的js资源。如果在标签中指定了`defer`方法，这个资源将在页面解析到`<script>`的时候就开始下载，但不会执行，直到`DOM`加载完成（触发`onload`事件前）才会被调用。而`async`与`defer`的作用是相同的，它们的区别在于`sync`的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作`DOM`元素。\n* **js不阻塞资源的加载：**与css的加载同理，由于有扫描器的存在，资源会并行加载。\n* **js顺序执行，阻塞后续js逻辑的运行：**即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。\n\n## 引入方法\n\n### 脚本的位置\n\n```html \n<html>\n<head>\n<title>Source Example</title>\n<script type=\"text/javascript\" src=\"script1.js\"></script>\n<script type=\"text/javascript\" src=\"script2.js\"></script>\n<script type=\"text/javascript\" src=\"script3.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n</body>\n</html>\n```\n当我们在`<head>`中引入js文件时，由于js的阻塞特性，当浏览器解析到`<script>`标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。\n```html \n<html>\n<head>\n<title>Source Example</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n\n    <!-- <script> 文件推荐放在这儿 -->\n    <script type=\"text/javascript\" src=\"script1.js\"></script>\n    <script type=\"text/javascript\" src=\"script2.js\"></script>\n    <script type=\"text/javascript\" src=\"script3.js\"></script>\n</body>\n</html>\n```\n所以建议把`<script>`放在`<body>`末尾，因为此时样式和`DOM`元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。\n\n### 无阻塞脚本\n\n* `defer`属性：是HTML4为`<script>`拓展的属性，指明本元素所含的脚本不会修改`DOM`，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。\n\n```html \n<html>\n<head>\n<title>Script Defer Example</title>\n</head>\n<body>\n    <script type=\"text/javascript\" defer>\n        console.log(\"defer\");\n    </script>\n    <script type=\"text/javascript\">\n        console.log(\"script\");\n    </script>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            console.log(\"load\");\n        };\n    </script>\n</body>\n</html>\n```\n该段代码执行后的结果是`script`、`defer`、`load`，表明含有`defer`属性的脚本是在`onload`执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。\n* `async`属性：是HTML5为`<script>`拓展的属性，作用和`defer`一样，能够异步地加载和执行脚本。它比`defer`有更好的兼容性，但由于`async`在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。\n\n### 动态脚本\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n该方式可以让`<script>`无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他`DOM`元素是并行的，所以可能出现这个文件中绑定操作的`DOM`元素还没加载，因为找不到而报错。\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.onload = function(){\n  console.log(\"Script loaded!\");\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n在Firefox、Opera、Chrom和Safari 3+中提供了`script.onload`事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即`readystatechange`事件。\n> `uninitialized`：默认状态\n> `loading`：下载开始\n> `loaded`：下载完成\n> `interactive`：下载完成但尚不可用\n> `complete`：所有数据已经准备好 \n\n```javascript\nvar script = document.createElement(\"script\");\nscript.type = \"text/javascript\";\n\n//Internet Explorer\nscript.onreadystatechange = function(){\n  if (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n    script.onreadystatechange = null;\n    console.log(\"Script loaded.\");\n  }\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。\n```javascript\nfunction loadScript(url, callback) {\n  var script = document.creatElement(\"script\");\n  script.type = \"text/javascript\";\n  if(script.readyState) {\n    script.onreadystatechange = function() {\n      if(script.readyState == \"loaded\" || script.readyState == \"complete\") {\n        script.onreadystatechange = null;\n        callback();\n      }\n    }\n  } else {\n    script.onload = function() {\n      callback();\n    }\n  }\n  script.src = url;\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n```\n如此就可以通过嵌套调用来保证他们的加载顺序：\n```javascript\nloadScript(\"script1.js\",function() {\n  loadScript(\"script2.js\",function() {\n\talert(\"all files are loaded!\");\n  })\n})\n```\n\n### XMLHttpRequest(XHR)对象\n\n可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。\n\n","source":"_posts/页面加载——浏览器渲染.md","raw":"---\ntitle: 页面加载——浏览器渲染\ndate: 2017-08-19 18:46:53\ncategories: 知识碎片\ntags: \n---\n一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n\n<!-- more -->\n\n一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n\n## 顺序执行、并发加载\n\n因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入`<link>`或`<script>`，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。\n\n对于`<img>`所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。\n\n```javascript\nwindow.addEventListener('load', function() {\n  // 页面的全部资源加载完才会执行，包括图片、视频\n})\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // DOM 渲染完即可执行，此时图片、视频可能还没加载完\n})\n```\n\n## 阻塞\n\n### CSS阻塞\n* **css在`<head>`中阻塞页面的渲染：**即这个页面要呈现出效果需要等待这个`<link>`所对应的css资源加载完成以后才能进行渲染。如果css并不是在`<head>`中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在`<head>`标签中就引入。\n* **css阻塞js的执行：**即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作`DOM`元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。\n* **css不阻塞外部脚本的加载：**即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在`HTMLPreloadScanner`类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。\n\n### JS阻塞\n* **直接引入的js阻塞页面的渲染：**直接引入指的是没有通过`defer`和`async`方法直接用`<script>`引入的js资源。如果在标签中指定了`defer`方法，这个资源将在页面解析到`<script>`的时候就开始下载，但不会执行，直到`DOM`加载完成（触发`onload`事件前）才会被调用。而`async`与`defer`的作用是相同的，它们的区别在于`sync`的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作`DOM`元素。\n* **js不阻塞资源的加载：**与css的加载同理，由于有扫描器的存在，资源会并行加载。\n* **js顺序执行，阻塞后续js逻辑的运行：**即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。\n\n## 引入方法\n\n### 脚本的位置\n\n```html \n<html>\n<head>\n<title>Source Example</title>\n<script type=\"text/javascript\" src=\"script1.js\"></script>\n<script type=\"text/javascript\" src=\"script2.js\"></script>\n<script type=\"text/javascript\" src=\"script3.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n</body>\n</html>\n```\n当我们在`<head>`中引入js文件时，由于js的阻塞特性，当浏览器解析到`<script>`标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。\n```html \n<html>\n<head>\n<title>Source Example</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n\n    <!-- <script> 文件推荐放在这儿 -->\n    <script type=\"text/javascript\" src=\"script1.js\"></script>\n    <script type=\"text/javascript\" src=\"script2.js\"></script>\n    <script type=\"text/javascript\" src=\"script3.js\"></script>\n</body>\n</html>\n```\n所以建议把`<script>`放在`<body>`末尾，因为此时样式和`DOM`元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。\n\n### 无阻塞脚本\n\n* `defer`属性：是HTML4为`<script>`拓展的属性，指明本元素所含的脚本不会修改`DOM`，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。\n\n```html \n<html>\n<head>\n<title>Script Defer Example</title>\n</head>\n<body>\n    <script type=\"text/javascript\" defer>\n        console.log(\"defer\");\n    </script>\n    <script type=\"text/javascript\">\n        console.log(\"script\");\n    </script>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            console.log(\"load\");\n        };\n    </script>\n</body>\n</html>\n```\n该段代码执行后的结果是`script`、`defer`、`load`，表明含有`defer`属性的脚本是在`onload`执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。\n* `async`属性：是HTML5为`<script>`拓展的属性，作用和`defer`一样，能够异步地加载和执行脚本。它比`defer`有更好的兼容性，但由于`async`在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。\n\n### 动态脚本\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n该方式可以让`<script>`无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他`DOM`元素是并行的，所以可能出现这个文件中绑定操作的`DOM`元素还没加载，因为找不到而报错。\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.onload = function(){\n  console.log(\"Script loaded!\");\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n在Firefox、Opera、Chrom和Safari 3+中提供了`script.onload`事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即`readystatechange`事件。\n> `uninitialized`：默认状态\n> `loading`：下载开始\n> `loaded`：下载完成\n> `interactive`：下载完成但尚不可用\n> `complete`：所有数据已经准备好 \n\n```javascript\nvar script = document.createElement(\"script\");\nscript.type = \"text/javascript\";\n\n//Internet Explorer\nscript.onreadystatechange = function(){\n  if (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n    script.onreadystatechange = null;\n    console.log(\"Script loaded.\");\n  }\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。\n```javascript\nfunction loadScript(url, callback) {\n  var script = document.creatElement(\"script\");\n  script.type = \"text/javascript\";\n  if(script.readyState) {\n    script.onreadystatechange = function() {\n      if(script.readyState == \"loaded\" || script.readyState == \"complete\") {\n        script.onreadystatechange = null;\n        callback();\n      }\n    }\n  } else {\n    script.onload = function() {\n      callback();\n    }\n  }\n  script.src = url;\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n```\n如此就可以通过嵌套调用来保证他们的加载顺序：\n```javascript\nloadScript(\"script1.js\",function() {\n  loadScript(\"script2.js\",function() {\n\talert(\"all files are loaded!\");\n  })\n})\n```\n\n### XMLHttpRequest(XHR)对象\n\n可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。\n\n","slug":"页面加载——浏览器渲染","published":1,"updated":"2020-01-08T13:48:10.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55hfla0000yfr03wqmcdg25","content":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>\n</ul>\n<a id=\"more\"></a>\n<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>\n</ul>\n<h2 id=\"顺序执行、并发加载\"><a href=\"#顺序执行、并发加载\" class=\"headerlink\" title=\"顺序执行、并发加载\"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>\n<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 页面的全部资源加载完才会执行，包括图片、视频</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><h3 id=\"CSS阻塞\"><a href=\"#CSS阻塞\" class=\"headerlink\" title=\"CSS阻塞\"></a>CSS阻塞</h3><ul>\n<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>\n<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>\n<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>\n</ul>\n<h3 id=\"JS阻塞\"><a href=\"#JS阻塞\" class=\"headerlink\" title=\"JS阻塞\"></a>JS阻塞</h3><ul>\n<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>\n<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>\n<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>\n</ul>\n<h2 id=\"引入方法\"><a href=\"#引入方法\" class=\"headerlink\" title=\"引入方法\"></a>引入方法</h2><h3 id=\"脚本的位置\"><a href=\"#脚本的位置\" class=\"headerlink\" title=\"脚本的位置\"></a>脚本的位置</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"styles.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>\n<h3 id=\"无阻塞脚本\"><a href=\"#无阻塞脚本\" class=\"headerlink\" title=\"无阻塞脚本\"></a>无阻塞脚本</h3><ul>\n<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Script Defer Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"defer\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"script\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"load\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>\n<ul>\n<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>\n</ul>\n<h3 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded!\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>\n<blockquote>\n<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Internet Explorer</span></span><br><span class=\"line\">script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>)&#123;</span><br><span class=\"line\">    script.onreadystatechange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">  script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(script.readyState) &#123;</span><br><span class=\"line\">    script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>) &#123;</span><br><span class=\"line\">        script.onreadystatechange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        callback();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  script.src = url;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadScript(<span class=\"string\">\"script1.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  loadScript(<span class=\"string\">\"script2.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"all files are loaded!\"</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"XMLHttpRequest-XHR-对象\"><a href=\"#XMLHttpRequest-XHR-对象\" class=\"headerlink\" title=\"XMLHttpRequest(XHR)对象\"></a>XMLHttpRequest(XHR)对象</h3><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>\n","site":{"data":{}},"excerpt":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>\n</ul>","more":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>\n</ul>\n<h2 id=\"顺序执行、并发加载\"><a href=\"#顺序执行、并发加载\" class=\"headerlink\" title=\"顺序执行、并发加载\"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>\n<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 页面的全部资源加载完才会执行，包括图片、视频</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><h3 id=\"CSS阻塞\"><a href=\"#CSS阻塞\" class=\"headerlink\" title=\"CSS阻塞\"></a>CSS阻塞</h3><ul>\n<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>\n<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>\n<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>\n</ul>\n<h3 id=\"JS阻塞\"><a href=\"#JS阻塞\" class=\"headerlink\" title=\"JS阻塞\"></a>JS阻塞</h3><ul>\n<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>\n<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>\n<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>\n</ul>\n<h2 id=\"引入方法\"><a href=\"#引入方法\" class=\"headerlink\" title=\"引入方法\"></a>引入方法</h2><h3 id=\"脚本的位置\"><a href=\"#脚本的位置\" class=\"headerlink\" title=\"脚本的位置\"></a>脚本的位置</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"styles.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>\n<h3 id=\"无阻塞脚本\"><a href=\"#无阻塞脚本\" class=\"headerlink\" title=\"无阻塞脚本\"></a>无阻塞脚本</h3><ul>\n<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Script Defer Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"defer\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"script\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"load\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>\n<ul>\n<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>\n</ul>\n<h3 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded!\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>\n<blockquote>\n<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Internet Explorer</span></span><br><span class=\"line\">script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>)&#123;</span><br><span class=\"line\">    script.onreadystatechange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">  script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(script.readyState) &#123;</span><br><span class=\"line\">    script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>) &#123;</span><br><span class=\"line\">        script.onreadystatechange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        callback();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  script.src = url;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadScript(<span class=\"string\">\"script1.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  loadScript(<span class=\"string\">\"script2.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"all files are loaded!\"</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"XMLHttpRequest-XHR-对象\"><a href=\"#XMLHttpRequest-XHR-对象\" class=\"headerlink\" title=\"XMLHttpRequest(XHR)对象\"></a>XMLHttpRequest(XHR)对象</h3><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck55hfl7h0002fr03wpa6ofih","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflb6002pfr03g0bwlnrg"},{"post_id":"ck55hfl7l0003fr03vf9lpqzj","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflb7002rfr03n0jdxd4l"},{"post_id":"ck55hfl7l0004fr03xjiopuo2","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb7002tfr03bredvx0f"},{"post_id":"ck55hfl7m0005fr031ym6cs58","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb7002vfr0364oacgr9"},{"post_id":"ck55hfl7n0006fr034kdtecrb","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflb7002xfr036069ryw4"},{"post_id":"ck55hfl7n0007fr03gcx4i283","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb7002zfr03v7ysuqwd"},{"post_id":"ck55hfl7s0008fr03mbp4hzdk","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb80031fr03sanflqzj"},{"post_id":"ck55hfl7s0009fr03xfwgdzix","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb80033fr030ty8flii"},{"post_id":"ck55hfl7t000afr03ffn075nk","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb80035fr03myrdg8qr"},{"post_id":"ck55hfl7u000bfr036gornyks","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb80037fr03a1h2to2r"},{"post_id":"ck55hfl7u000cfr03b80u8tr0","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflb80039fr036dkj2597"},{"post_id":"ck55hfl7w000efr03s8jr80dr","category_id":"ck55hflad001hfr03vm7x1nvr","_id":"ck55hflb8003bfr03zbcr9voa"},{"post_id":"ck55hfl7w000ffr03hrxw8hb2","category_id":"ck55hflae001jfr03lwekxlv0","_id":"ck55hflb9003dfr03hyg14z58"},{"post_id":"ck55hfl7x000gfr03utgl7t1s","category_id":"ck55hflae001jfr03lwekxlv0","_id":"ck55hflb9003ffr03krudzi7f"},{"post_id":"ck55hfl7x000hfr03ih582gy6","category_id":"ck55hflae001jfr03lwekxlv0","_id":"ck55hflb9003hfr03fw8j93y1"},{"post_id":"ck55hfl7y000ifr03f0z5lzwl","category_id":"ck55hflah001pfr03xqwg8tg0","_id":"ck55hflb9003jfr03pjn0c0mq"},{"post_id":"ck55hfl7z000jfr038ax06hlq","category_id":"ck55hflai001rfr034luajxx8","_id":"ck55hflb9003lfr038klz235l"},{"post_id":"ck55hfl7z000kfr03ydugt7n9","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflb9003nfr03vkv9359r"},{"post_id":"ck55hfl80000lfr03qzvx8aor","category_id":"ck55hflae001jfr03lwekxlv0","_id":"ck55hflb9003pfr0331vfupof"},{"post_id":"ck55hfl81000mfr03jgrqzolh","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflba003rfr031zdwgq52"},{"post_id":"ck55hfl81000nfr03ss3uz4t8","category_id":"ck55hflai001rfr034luajxx8","_id":"ck55hflba003tfr03r2lca058"},{"post_id":"ck55hfl86000ofr03wvghiaj3","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflba003vfr039zp0g0bh"},{"post_id":"ck55hfl86000pfr03w3h8ctu2","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflba003xfr03oog2ak9i"},{"post_id":"ck55hfl87000qfr0394ipgg8w","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflba003zfr03cg1mlkpp"},{"post_id":"ck55hfl8z000rfr03bc7g3fnn","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflba0041fr03ee07bjxh"},{"post_id":"ck55hfl9x000ufr03eg480ig7","category_id":"ck55hfla1000zfr0384pnpqr4","_id":"ck55hflbb0043fr0362dnabu0"},{"post_id":"ck55hfl9y000vfr03iggltpup","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflbb0045fr032nw78kup"},{"post_id":"ck55hfla0000yfr03wqmcdg25","category_id":"ck55hfl90000sfr03uzjcvaj6","_id":"ck55hflbb0047fr038v13ed6p"}],"PostTag":[{"post_id":"ck55hfl7h0002fr03wpa6ofih","tag_id":"ck55hfl99000tfr03dsa1lx9u","_id":"ck55hflb6002nfr03jet0tqhi"},{"post_id":"ck55hfl7l0003fr03vf9lpqzj","tag_id":"ck55hfl9z000xfr03l6y78ruw","_id":"ck55hflb7002qfr0389tk3572"},{"post_id":"ck55hfl7l0003fr03vf9lpqzj","tag_id":"ck55hfla10010fr033qwt79er","_id":"ck55hflb7002sfr03szzfxq2n"},{"post_id":"ck55hfl7l0003fr03vf9lpqzj","tag_id":"ck55hfla20012fr034bqhgvxx","_id":"ck55hflb7002ufr03h2l3kv4f"},{"post_id":"ck55hfl7l0004fr03xjiopuo2","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb7002wfr03n19e4luv"},{"post_id":"ck55hfl7l0004fr03xjiopuo2","tag_id":"ck55hfla40016fr037gj9ldxc","_id":"ck55hflb7002yfr03m3dkzx6f"},{"post_id":"ck55hfl7m0005fr031ym6cs58","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb80030fr03pyd3n20o"},{"post_id":"ck55hfl7m0005fr031ym6cs58","tag_id":"ck55hfla40016fr037gj9ldxc","_id":"ck55hflb80032fr03blpw56ei"},{"post_id":"ck55hfl7n0006fr034kdtecrb","tag_id":"ck55hfla6001cfr03aoga1iqg","_id":"ck55hflb80034fr03x1xomqkr"},{"post_id":"ck55hfl7n0007fr03gcx4i283","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb80036fr03yh4h6ebq"},{"post_id":"ck55hfl7s0008fr03mbp4hzdk","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb80038fr031g9jvvaa"},{"post_id":"ck55hfl7s0009fr03xfwgdzix","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb8003afr03lwj550og"},{"post_id":"ck55hfl7t000afr03ffn075nk","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb8003cfr03rchgil6l"},{"post_id":"ck55hfl7u000bfr036gornyks","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb9003efr03xiww5v25"},{"post_id":"ck55hfl7u000cfr03b80u8tr0","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflb9003gfr03uf14mqyk"},{"post_id":"ck55hfl7w000efr03s8jr80dr","tag_id":"ck55hflah001qfr03qwmm4rs5","_id":"ck55hflb9003ifr037f0b4ul0"},{"post_id":"ck55hfl7w000ffr03hrxw8hb2","tag_id":"ck55hflai001sfr03lpova4xi","_id":"ck55hflb9003kfr03dj2g9tzr"},{"post_id":"ck55hfl7w000ffr03hrxw8hb2","tag_id":"ck55hflaj001ufr03nlvrv5qp","_id":"ck55hflb9003mfr03iyhuxs5p"},{"post_id":"ck55hfl7w000ffr03hrxw8hb2","tag_id":"ck55hflak001wfr03r54134cv","_id":"ck55hflb9003ofr03t90dfxbs"},{"post_id":"ck55hfl7x000gfr03utgl7t1s","tag_id":"ck55hflai001sfr03lpova4xi","_id":"ck55hflba003qfr03hzssyzce"},{"post_id":"ck55hfl7x000gfr03utgl7t1s","tag_id":"ck55hflam0020fr0359973kyf","_id":"ck55hflba003sfr03ri6vhyrs"},{"post_id":"ck55hfl7x000hfr03ih582gy6","tag_id":"ck55hflai001sfr03lpova4xi","_id":"ck55hflba003ufr03a5aqlmjf"},{"post_id":"ck55hfl7x000hfr03ih582gy6","tag_id":"ck55hflas0024fr033t9ao7a1","_id":"ck55hflba003wfr03m2if9hmt"},{"post_id":"ck55hfl7x000hfr03ih582gy6","tag_id":"ck55hflat0026fr03lnq49k3e","_id":"ck55hflba003yfr03boc9wam9"},{"post_id":"ck55hfl7y000ifr03f0z5lzwl","tag_id":"ck55hflat0027fr03lsracimw","_id":"ck55hflba0040fr03no1ks1eo"},{"post_id":"ck55hfl7z000jfr038ax06hlq","tag_id":"ck55hflat0028fr03czbpf5uo","_id":"ck55hflba0042fr03w4ehraqr"},{"post_id":"ck55hfl7z000jfr038ax06hlq","tag_id":"ck55hflau0029fr03g1y0976u","_id":"ck55hflbb0044fr034m1tt2id"},{"post_id":"ck55hfl7z000jfr038ax06hlq","tag_id":"ck55hflau002afr03hg6gtqtg","_id":"ck55hflbb0046fr03ka2q2qlp"},{"post_id":"ck55hfl7z000kfr03ydugt7n9","tag_id":"ck55hflau002bfr03rz7qz2n3","_id":"ck55hflbc0048fr03bhwys1i9"},{"post_id":"ck55hfl80000lfr03qzvx8aor","tag_id":"ck55hflau002cfr03mnray5u7","_id":"ck55hflbc0049fr0344vqj64x"},{"post_id":"ck55hfl81000mfr03jgrqzolh","tag_id":"ck55hflav002dfr03pou8k3we","_id":"ck55hflbc004afr03thj62wos"},{"post_id":"ck55hfl81000mfr03jgrqzolh","tag_id":"ck55hflav002efr03vj4jbazk","_id":"ck55hflbc004bfr03i7qvjlcd"},{"post_id":"ck55hfl81000nfr03ss3uz4t8","tag_id":"ck55hflat0028fr03czbpf5uo","_id":"ck55hflbc004cfr033c3jge0y"},{"post_id":"ck55hfl81000nfr03ss3uz4t8","tag_id":"ck55hflau0029fr03g1y0976u","_id":"ck55hflbd004dfr039v820x5v"},{"post_id":"ck55hfl81000nfr03ss3uz4t8","tag_id":"ck55hflau002afr03hg6gtqtg","_id":"ck55hflbd004efr03xxpi3ec7"},{"post_id":"ck55hfl86000ofr03wvghiaj3","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflbd004ffr03mitouscm"},{"post_id":"ck55hfl86000ofr03wvghiaj3","tag_id":"ck55hflax002jfr0303q1ozn8","_id":"ck55hflbd004gfr039mu18t2w"},{"post_id":"ck55hfl86000pfr03w3h8ctu2","tag_id":"ck55hflax002kfr03yj0iwdoi","_id":"ck55hflbd004hfr03ppjth3fj"},{"post_id":"ck55hfl87000qfr0394ipgg8w","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflbd004ifr03aqmfex3r"},{"post_id":"ck55hfl87000qfr0394ipgg8w","tag_id":"ck55hflay002mfr03j1p03ten","_id":"ck55hflbd004jfr03o136pm01"},{"post_id":"ck55hfl8z000rfr03bc7g3fnn","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflbd004kfr03hek4ix0i"},{"post_id":"ck55hfl8z000rfr03bc7g3fnn","tag_id":"ck55hfla40016fr037gj9ldxc","_id":"ck55hflbd004lfr039p2sx7mq"},{"post_id":"ck55hfl9x000ufr03eg480ig7","tag_id":"ck55hfla30014fr03gfax8t0c","_id":"ck55hflbd004mfr034rlibnh9"},{"post_id":"ck55hfl9y000vfr03iggltpup","tag_id":"ck55hflb6002ofr03hy177f89","_id":"ck55hflbx004nfr03gfemduqt"}],"Tag":[{"name":"Ajax","_id":"ck55hfl99000tfr03dsa1lx9u"},{"name":"DOM","_id":"ck55hfl9z000xfr03l6y78ruw"},{"name":"BOM","_id":"ck55hfla10010fr033qwt79er"},{"name":"HTML","_id":"ck55hfla20012fr034bqhgvxx"},{"name":"JavaScript","_id":"ck55hfla30014fr03gfax8t0c"},{"name":"ES6","_id":"ck55hfla40016fr037gj9ldxc"},{"name":"JSON","_id":"ck55hfla6001cfr03aoga1iqg"},{"name":"TypeScript","_id":"ck55hflah001qfr03qwmm4rs5"},{"name":"Vue","_id":"ck55hflai001sfr03lpova4xi"},{"name":"MVC","_id":"ck55hflaj001ufr03nlvrv5qp"},{"name":"MVVM","_id":"ck55hflak001wfr03r54134cv"},{"name":"Vue生命周期","_id":"ck55hflam0020fr0359973kyf"},{"name":"Vue指令","_id":"ck55hflas0024fr033t9ao7a1"},{"name":"Vue事件","_id":"ck55hflat0026fr03lnq49k3e"},{"name":"Webpack","_id":"ck55hflat0027fr03lsracimw"},{"name":"node","_id":"ck55hflat0028fr03czbpf5uo"},{"name":"fet源码","_id":"ck55hflau0029fr03g1y0976u"},{"name":"cli工具","_id":"ck55hflau002afr03hg6gtqtg"},{"name":"iconfont","_id":"ck55hflau002bfr03rz7qz2n3"},{"name":"Vuex","_id":"ck55hflau002cfr03mnray5u7"},{"name":"HTTP","_id":"ck55hflav002dfr03pou8k3we"},{"name":"网络","_id":"ck55hflav002efr03vj4jbazk"},{"name":"异步","_id":"ck55hflax002jfr0303q1ozn8"},{"name":"hexo","_id":"ck55hflax002kfr03yj0iwdoi"},{"name":"lodash","_id":"ck55hflay002mfr03j1p03ten"},{"name":"网络知识","_id":"ck55hflb6002ofr03hy177f89"}]}}