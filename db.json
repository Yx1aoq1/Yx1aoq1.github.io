{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/canvas-img-1.png","path":"images/canvas-img-1.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-2.png","path":"images/iconfont-img-2.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-3.png","path":"images/iconfont-img-3.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-4.png","path":"images/iconfont-img-4.png","modified":0,"renderable":0},{"_id":"source/images/jicheng-1.png","path":"images/jicheng-1.png","modified":0,"renderable":0},{"_id":"source/images/jicheng-2.png","path":"images/jicheng-2.png","modified":0,"renderable":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"source/images/iconfont-img-1.png","path":"images/iconfont-img-1.png","modified":0,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/favicon.ico","hash":"9ff098fa25054b2bfd02874e7c2ba35e11643396","modified":1490344847838},{"_id":"themes/apollo/.gitignore","hash":"d6cc8c2730e89bbee83e01a5a4490f8dbf12c332","modified":1500099972134},{"_id":"themes/apollo/LICENSE","hash":"1588511f0c37609ebfb55298b83a77ae5afca870","modified":1500099972148},{"_id":"themes/apollo/README.md","hash":"bee45e9d6e41f6b9c01bc38f26bc60ba19c825f7","modified":1500099972161},{"_id":"themes/apollo/_config.yml","hash":"e32d62a2327fa0916cd9fb1a52161e0a01e84984","modified":1500105785331},{"_id":"themes/apollo/gulpfile.js","hash":"3bf61bca569665944cc61ac0483c9d568a4f58d7","modified":1500099972227},{"_id":"themes/apollo/package.json","hash":"2e81f69d66c01a6bfaacbd8bd7324b370acbed88","modified":1500099972434},{"_id":"source/_posts/17-02-28-1.md","hash":"ffee1fcdccca1009fbbe38c43488d8d2c0a8c299","modified":1500100989259},{"_id":"source/_posts/17-02-28-2.md","hash":"5fe373bf1a4448dab304226102400e1d622b9a66","modified":1500104858323},{"_id":"source/_posts/17-03-20-4.md","hash":"cd3ced56acb865dd5038d10a51151d1cc3f70c3a","modified":1500104864984},{"_id":"source/_posts/17-03-21-5.md","hash":"33bbd338a6859f614a67b712902fe954c3bdd632","modified":1500104869278},{"_id":"source/_posts/17-03-21-6.md","hash":"2a147ea41f8298d6b5823b5fc61cb98fa26198ac","modified":1500104873310},{"_id":"source/_posts/17-03-26-7.md","hash":"2bb8d08c5ce6590fa7432d5b7fb47639a840d743","modified":1500104876264},{"_id":"source/_posts/17-03-28-8.md","hash":"4cd3ff99d633e0eedd2ad67ff8501b8b465aaf7b","modified":1500104879919},{"_id":"source/_posts/17-03-29-9.md","hash":"0e9051991414cbc09b60918144e02eb1701373df","modified":1500104883362},{"_id":"source/_posts/17-04-06-11.md","hash":"c4618dd864c2a5d9b11e0a20b8cf36129b6f2454","modified":1500104886485},{"_id":"source/_posts/17-04-06-12.md","hash":"73a4e735ef9c0b4f728407641caf1a8efa9bbeac","modified":1500104889556},{"_id":"source/_posts/17-04-10-13.md","hash":"67977023412e32a36c6e7abf86b8b47bd09207b9","modified":1500104893599},{"_id":"source/_posts/17-04-21-14.md","hash":"379ff6b41ddd70e980bc545cd2e3be5a387399bb","modified":1500104897044},{"_id":"source/_posts/17-05-11-16.md","hash":"cd9b2191af2aa5a898c77d7a0b01c5aaec4ba820","modified":1500104900971},{"_id":"source/_posts/17-07-07-17.md","hash":"dfdd73d2abc3ba552c48737a45aa9c9c6f5c7f42","modified":1500106003410},{"_id":"source/_posts/17-07-08-18.md","hash":"a349dc4d320b66c826c471733aecdb9249f6a2a0","modified":1500106016104},{"_id":"source/_posts/17-07-15-19.md","hash":"3d0fde2608b916bc8ace78f312ed2fb071e968af","modified":1500105211310},{"_id":"source/_posts/17-07-15-20.md","hash":"6376ee3f453d874cd5b6d9a559d48fa9645cca27","modified":1502885893242},{"_id":"source/images/avatar.jpg","hash":"b2cd72c603ca58a27504c4744bb78de605adf456","modified":1435394447271},{"_id":"source/images/canvas-img-1.png","hash":"79357cc2687e1f19ebb11c7f5d3ed032ecaf9ee7","modified":1493101204674},{"_id":"source/images/iconfont-img-2.png","hash":"4f9c43a8d9b5a498dadcd1e7982d8c464b60462b","modified":1490491207238},{"_id":"source/images/iconfont-img-3.png","hash":"379845359d10d9578bff906cc328b00f18683b34","modified":1490491239294},{"_id":"source/images/iconfont-img-4.png","hash":"32eac83fe1450db586186a0e51e83f68db694ca3","modified":1490491263289},{"_id":"source/images/jicheng-1.png","hash":"405f7177225c5f12a289603689ccbb51a428a80f","modified":1499443454186},{"_id":"source/images/jicheng-2.png","hash":"35606fc921e2a7f254235f72234add1136ca7fb9","modified":1499492510314},{"_id":"themes/apollo/doc/doc-en.md","hash":"123aa670151db03ba5b1a20eaeef2cd3c9bec2b9","modified":1500099972188},{"_id":"themes/apollo/doc/doc-zh.md","hash":"f2ef939e9b39d4d150d613f68a80ca65425d406a","modified":1500099972202},{"_id":"themes/apollo/languages/en.yml","hash":"29b8e211d422cb846af005bd1c21435b45ed6457","modified":1500099972239},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"05ef430fa5586e919839bad35aba4a9690e8e672","modified":1500099972250},{"_id":"themes/apollo/layout/archive.jade","hash":"a993dddad0213cfc4adbf5d25597b7effac758b0","modified":1500099972265},{"_id":"themes/apollo/layout/index.jade","hash":"fd11746c566d9fb6de1224a2992e3e443a83c139","modified":1500099972280},{"_id":"themes/apollo/layout/post.jade","hash":"ada9f5f76819ff76d2c37c893431dfdb808e19b7","modified":1500099972422},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1500099972452},{"_id":"source/images/iconfont-img-1.png","hash":"845102fc4a31fb67e15b1395f99b3d7aeec307e2","modified":1490491145257},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"47712f8bb3d84ff6a2742f923626d568779fc45a","modified":1500099972294},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"b9a6ca7d8769312cef09c86dbd6828bc04663ca2","modified":1500099972315},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"a9bd772bb172ba0c54d872d2d3364ff89d762ffb","modified":1500099972345},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"185aa2a3f86176b4924adac06ef576b365440c20","modified":1500099972356},{"_id":"themes/apollo/layout/partial/head.jade","hash":"bc1fb13056ea07b3832ed563c680ffe619d44dd9","modified":1500099972367},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"a49c19346dee6886ac8b37a1321ce170e627129a","modified":1500099972379},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"b43b1166601669cd6467bebf343efc1e5a253d64","modified":1500099972390},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"e309aff22fa5823aa65667cf2f189bd05adeb62a","modified":1500099972411},{"_id":"themes/apollo/source/css/apollo.css","hash":"a9072992f3a03003fb0ada9fb2d6d76386f066ad","modified":1500099972449},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1500099972467},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1500099972482},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"bea961e9c85a0eba26b34d5568f165f48fbc9bdb","modified":1500099972607},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"3003361c281d7aa1cfed944ad0da180ac05f2c32","modified":1500099972496},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"4ede69b12919439b4ae404a1e1d498cb8fd2932a","modified":1500099972508},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"e87b144a8389eefeab4f50c353eef18c428a761c","modified":1500099972519},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"8cd2631d46be05a9518f1966bd84e1a8b0270857","modified":1500099972532},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"a6aeb5177f370f984565f7b6f0a18fe27545d34d","modified":1500099972544},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"658eef39c7cf6f730f784751c2e4701e8eb02e0d","modified":1500099972556},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"25f38fb71ade373416af569558d56e4c2e692700","modified":1500099972572},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"612b367b0e9a0b9f66d37694ee64ce896c552967","modified":1500099972584},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"85e5dded04b7229ab4345e53473d4e9e9cbdbfb5","modified":1500099972596}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Sublime Text3前端插件分享","date":"2017-02-28T08:05:18.000Z","_content":"\n自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利\n\n<!--more-->\n\n***\n*  **Emmet:** \n快速编写HTML+CSS代码，快捷键**ctrl+E**\n[关于如何速写的教程](http://www.iteye.com/news/27580)\n*  **All Autocomplete:**\n搜索所有打开的文件来寻找匹配的提示词\n* **AutoFileName:**\n自动检索并补齐文件路径\n* **CSScomb:**\n使用指定排序方法对CSS的属性进行排序，快捷键**ctrl+alt+C**\n虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法\n* **HTML-CSS-JS Prettify:**\n美化代码格式，需要安装node.js才能使用，快捷键**ctrl+alt+H**，可以自动对齐\n* **ColorHighlighter:**\n可以显示颜色代码的颜色，看上去一目了然\n* **BracketHighlighter:**\n括号以及标签层级显示\n* **Sidebarenhancements:**\n扩展鼠标右键菜单，可以直接open with浏览器，超方便\n* **SublimeCodeIntel:**\n可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上\n\n打开*Package Settings > SublimeCodeIntel > Key Bindings - User*,输入代码\n```python\n[\n\t{ \n\t\t\"keys\": [\";\"], \"command\": \"run_macro_file\", \n\t  \t\"args\": {\"file\": \"Packages/User/unAutoSemiColon.sublime-macro\"} \n\t}\n]\n```\n然后打开 *Preferences > Browser Package > User*，保存文件名为*unAutoSemiColon.sublime-macro*\n```python\n[\n    {\n        \"args\":\n        {\n            \"characters\": \";\"\n        },\n        \"command\": \"insert\"\n    }\n]\n```\n之后打分号再也不会出现提示啦！！\n* **SublimeTmpl:**\n可以快速创建代码模板\n**ctrl+shift+H** HTML模板\n**ctrl+shift+C** CSS模板\n**ctrl+shift+J** Javascript模板\n**ctrl+shift+P** php模板\n*  **Colorsublime:**\n更换主题的插件，含有很多主题配色方案，偶尔转换一下心情\n***\n","source":"_posts/17-02-28-2.md","raw":"---\ntitle: Sublime Text3前端插件分享\ndate: 2017-02-28 16:05:18\n---\n\n自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利\n\n<!--more-->\n\n***\n*  **Emmet:** \n快速编写HTML+CSS代码，快捷键**ctrl+E**\n[关于如何速写的教程](http://www.iteye.com/news/27580)\n*  **All Autocomplete:**\n搜索所有打开的文件来寻找匹配的提示词\n* **AutoFileName:**\n自动检索并补齐文件路径\n* **CSScomb:**\n使用指定排序方法对CSS的属性进行排序，快捷键**ctrl+alt+C**\n虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法\n* **HTML-CSS-JS Prettify:**\n美化代码格式，需要安装node.js才能使用，快捷键**ctrl+alt+H**，可以自动对齐\n* **ColorHighlighter:**\n可以显示颜色代码的颜色，看上去一目了然\n* **BracketHighlighter:**\n括号以及标签层级显示\n* **Sidebarenhancements:**\n扩展鼠标右键菜单，可以直接open with浏览器，超方便\n* **SublimeCodeIntel:**\n可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上\n\n打开*Package Settings > SublimeCodeIntel > Key Bindings - User*,输入代码\n```python\n[\n\t{ \n\t\t\"keys\": [\";\"], \"command\": \"run_macro_file\", \n\t  \t\"args\": {\"file\": \"Packages/User/unAutoSemiColon.sublime-macro\"} \n\t}\n]\n```\n然后打开 *Preferences > Browser Package > User*，保存文件名为*unAutoSemiColon.sublime-macro*\n```python\n[\n    {\n        \"args\":\n        {\n            \"characters\": \";\"\n        },\n        \"command\": \"insert\"\n    }\n]\n```\n之后打分号再也不会出现提示啦！！\n* **SublimeTmpl:**\n可以快速创建代码模板\n**ctrl+shift+H** HTML模板\n**ctrl+shift+C** CSS模板\n**ctrl+shift+J** Javascript模板\n**ctrl+shift+P** php模板\n*  **Colorsublime:**\n更换主题的插件，含有很多主题配色方案，偶尔转换一下心情\n***\n","slug":"17-02-28-2","published":1,"updated":"2017-07-15T07:47:38.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8a00003ocg1atsczoy","content":"<p>自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利</p>\n<a id=\"more\"></a>\n<hr>\n<ul>\n<li><strong>Emmet:</strong><br>快速编写HTML+CSS代码，快捷键<strong>ctrl+E</strong><br><a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"external\">关于如何速写的教程</a></li>\n<li><strong>All Autocomplete:</strong><br>搜索所有打开的文件来寻找匹配的提示词</li>\n<li><strong>AutoFileName:</strong><br>自动检索并补齐文件路径</li>\n<li><strong>CSScomb:</strong><br>使用指定排序方法对CSS的属性进行排序，快捷键<strong>ctrl+alt+C</strong><br>虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法</li>\n<li><strong>HTML-CSS-JS Prettify:</strong><br>美化代码格式，需要安装node.js才能使用，快捷键<strong>ctrl+alt+H</strong>，可以自动对齐</li>\n<li><strong>ColorHighlighter:</strong><br>可以显示颜色代码的颜色，看上去一目了然</li>\n<li><strong>BracketHighlighter:</strong><br>括号以及标签层级显示</li>\n<li><strong>Sidebarenhancements:</strong><br>扩展鼠标右键菜单，可以直接open with浏览器，超方便</li>\n<li><strong>SublimeCodeIntel:</strong><br>可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上</li>\n</ul>\n<p>打开<em>Package Settings &gt; SublimeCodeIntel &gt; Key Bindings - User</em>,输入代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">\t&#123; </div><div class=\"line\">\t\t<span class=\"string\">\"keys\"</span>: [<span class=\"string\">\";\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"run_macro_file\"</span>, </div><div class=\"line\">\t  \t<span class=\"string\">\"args\"</span>: &#123;<span class=\"string\">\"file\"</span>: <span class=\"string\">\"Packages/User/unAutoSemiColon.sublime-macro\"</span>&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>然后打开 <em>Preferences &gt; Browser Package &gt; User</em>，保存文件名为<em>unAutoSemiColon.sublime-macro</em><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"args\"</span>:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"characters\"</span>: <span class=\"string\">\";\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"command\"</span>: <span class=\"string\">\"insert\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>之后打分号再也不会出现提示啦！！</p>\n<ul>\n<li><strong>SublimeTmpl:</strong><br>可以快速创建代码模板<br><strong>ctrl+shift+H</strong> HTML模板<br><strong>ctrl+shift+C</strong> CSS模板<br><strong>ctrl+shift+J</strong> Javascript模板<br><strong>ctrl+shift+P</strong> php模板</li>\n<li><strong>Colorsublime:</strong><br>更换主题的插件，含有很多主题配色方案，偶尔转换一下心情</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<p>自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利</p>","more":"<hr>\n<ul>\n<li><strong>Emmet:</strong><br>快速编写HTML+CSS代码，快捷键<strong>ctrl+E</strong><br><a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"external\">关于如何速写的教程</a></li>\n<li><strong>All Autocomplete:</strong><br>搜索所有打开的文件来寻找匹配的提示词</li>\n<li><strong>AutoFileName:</strong><br>自动检索并补齐文件路径</li>\n<li><strong>CSScomb:</strong><br>使用指定排序方法对CSS的属性进行排序，快捷键<strong>ctrl+alt+C</strong><br>虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法</li>\n<li><strong>HTML-CSS-JS Prettify:</strong><br>美化代码格式，需要安装node.js才能使用，快捷键<strong>ctrl+alt+H</strong>，可以自动对齐</li>\n<li><strong>ColorHighlighter:</strong><br>可以显示颜色代码的颜色，看上去一目了然</li>\n<li><strong>BracketHighlighter:</strong><br>括号以及标签层级显示</li>\n<li><strong>Sidebarenhancements:</strong><br>扩展鼠标右键菜单，可以直接open with浏览器，超方便</li>\n<li><strong>SublimeCodeIntel:</strong><br>可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上</li>\n</ul>\n<p>打开<em>Package Settings &gt; SublimeCodeIntel &gt; Key Bindings - User</em>,输入代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">\t&#123; </div><div class=\"line\">\t\t<span class=\"string\">\"keys\"</span>: [<span class=\"string\">\";\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"run_macro_file\"</span>, </div><div class=\"line\">\t  \t<span class=\"string\">\"args\"</span>: &#123;<span class=\"string\">\"file\"</span>: <span class=\"string\">\"Packages/User/unAutoSemiColon.sublime-macro\"</span>&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>然后打开 <em>Preferences &gt; Browser Package &gt; User</em>，保存文件名为<em>unAutoSemiColon.sublime-macro</em><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"args\"</span>:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"characters\"</span>: <span class=\"string\">\";\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"command\"</span>: <span class=\"string\">\"insert\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>之后打分号再也不会出现提示啦！！</p>\n<ul>\n<li><strong>SublimeTmpl:</strong><br>可以快速创建代码模板<br><strong>ctrl+shift+H</strong> HTML模板<br><strong>ctrl+shift+C</strong> CSS模板<br><strong>ctrl+shift+J</strong> Javascript模板<br><strong>ctrl+shift+P</strong> php模板</li>\n<li><strong>Colorsublime:</strong><br>更换主题的插件，含有很多主题配色方案，偶尔转换一下心情</li>\n</ul>\n<hr>"},{"title":"这磨人的小妖精","date":"2017-02-27T18:17:03.000Z","_content":"\n终于！把！这个！磨人的！小妖精！建好了！！\n超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=\n大概是我太蠢了才会弄这么久哦，好气哦\n好了我要努力读书去了\n\n<!--more-->\n","source":"_posts/17-02-28-1.md","raw":"---\ntitle: 这磨人的小妖精\ndate: 2017-02-28 02:17:03\n---\n\n终于！把！这个！磨人的！小妖精！建好了！！\n超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=\n大概是我太蠢了才会弄这么久哦，好气哦\n好了我要努力读书去了\n\n<!--more-->\n","slug":"17-02-28-1","published":1,"updated":"2017-07-15T06:43:09.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8i00013ocg8i4dgc8a","content":"<p>终于！把！这个！磨人的！小妖精！建好了！！<br>超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=<br>大概是我太蠢了才会弄这么久哦，好气哦<br>好了我要努力读书去了</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>终于！把！这个！磨人的！小妖精！建好了！！<br>超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=<br>大概是我太蠢了才会弄这么久哦，好气哦<br>好了我要努力读书去了</p>","more":""},{"title":"关于HTTP请求小记","date":"2017-03-20T07:31:38.000Z","_content":"* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","source":"_posts/17-03-20-4.md","raw":"---\ntitle: 关于HTTP请求小记\ndate: 2017-03-20 15:31:38\n---\n* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","slug":"17-03-20-4","published":1,"updated":"2017-07-15T07:47:44.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8n00023ocgqtwdughl","content":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /login.php HTTP/1.1 //请求地址</div><div class=\"line\"></div><div class=\"line\">//请求头</div><div class=\"line\">Host:localhost</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Accept:text/javascript,application/javascript,application/ecmascript,</div><div class=\"line\">application/x-ecmascript,*/*;</div><div class=\"line\">q=0.01</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</div><div class=\"line\"></div><div class=\"line\">//请求体</div><div class=\"line\">username=admin&amp;password=123456</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</div><div class=\"line\">Server:Apache</div><div class=\"line\">Content-Encoding:gzip</div><div class=\"line\">Content-Length:7112</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Content-Type:application/javascript</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /login.php HTTP/1.1 //请求地址</div><div class=\"line\"></div><div class=\"line\">//请求头</div><div class=\"line\">Host:localhost</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Accept:text/javascript,application/javascript,application/ecmascript,</div><div class=\"line\">application/x-ecmascript,*/*;</div><div class=\"line\">q=0.01</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</div><div class=\"line\"></div><div class=\"line\">//请求体</div><div class=\"line\">username=admin&amp;password=123456</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</div><div class=\"line\">Server:Apache</div><div class=\"line\">Content-Encoding:gzip</div><div class=\"line\">Content-Length:7112</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Content-Type:application/javascript</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>"},{"title":"AJAX学习笔记","date":"2017-03-21T08:21:19.000Z","_content":"> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","source":"_posts/17-03-21-5.md","raw":"---\ntitle: AJAX学习笔记\ndate: 2017-03-21 16:21:19\n---\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","slug":"17-03-21-5","published":1,"updated":"2017-07-15T07:47:49.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8p00033ocgpj2d8mqs","content":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建信息</span></div><div class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></div><div class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"number\">123</span></div><div class=\"line\">\t\tnumber:<span class=\"number\">123</span></div><div class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></div><div class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">在www.aaa.com中</div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\"> \talert(json[<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> 在www.bbb.com中</div><div class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></div><div class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>","more":"<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建信息</span></div><div class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></div><div class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"number\">123</span></div><div class=\"line\">\t\tnumber:<span class=\"number\">123</span></div><div class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></div><div class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">在www.aaa.com中</div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\"> \talert(json[<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> 在www.bbb.com中</div><div class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></div><div class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>"},{"title":"JSON学习笔记","date":"2017-03-21T10:16:43.000Z","_content":"> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","source":"_posts/17-03-21-6.md","raw":"---\ntitle: JSON学习笔记\ndate: 2017-03-21 18:16:43\n---\n> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","slug":"17-03-21-6","published":1,"updated":"2017-07-15T07:47:53.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8q00043ocgwr6x26ch","content":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</div><div class=\"line\"><span class=\"comment\">//解析完毕</span></div><div class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</div><div class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>","more":"<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</div><div class=\"line\"><span class=\"comment\">//解析完毕</span></div><div class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</div><div class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"title":"iconfont使用方法","date":"2017-03-26T01:12:56.000Z","_content":"实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","source":"_posts/17-03-26-7.md","raw":"---\ntitle: iconfont使用方法\ndate: 2017-03-26 09:12:56\n---\n实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","slug":"17-03-26-7","published":1,"updated":"2017-07-15T07:47:56.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8v00053ocgtnxqcmcr","content":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt=\"\"></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt=\"\"></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</div><div class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </div><div class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt=\"\"><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>\n","site":{"data":{}},"excerpt":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt=\"\"></p>","more":"<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt=\"\"></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt=\"\"></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</div><div class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </div><div class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt=\"\"><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>"},{"title":"从零开始的backbone.js（一）","date":"2017-03-28T08:24:10.000Z","_content":"实习项目用的框架：backbone.js\n\n> Backbone.js为复杂WEB应用程序提供**模型(models)**、**集合(collections)**、**视图(views)**的结构。\n\n<!--more-->\n\n## Backbone.Model（模型）\n* Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。\n```javascript\n//相当于public class ...\n//可以存放基本的数值以及方法\nvar Man = Backbone.Model.extend({\n\t//模型在服务器上位置的url\n\t//调用save方法时会post对象的所有属性到server端，数据形式是json\n\turl: '/man/',\n\t//定义了一个Model，实现了初始化方法（initialize函数）\n\tinitialize: function() {\n\t\talert('Hey,you create me!');\n\t\t//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个\n\t\t//当name发生改变时触发该函数\n\t\tthis.bind(\"change:name\",function(){\n\t\t\tvar name = this.get(\"name\");\n\t\t\talert(\"you change the name:\" + name);\n\t\t});\n\t\tthis.bind(\"invalid\",function(model,error){\n\t\t\talert(error);\n\t\t\t//error是来自validate校验的错误\n\t\t})\n\t},\n\t//定义默认值（属性）name & age\n\tdefaults: {\n\t\tname: 'tom',\n\t\tage: '18'\n\t},\n\t//Model.validate(attributes, options)，默认为未定义\n\t//默认在save之前调用，如果{validate:true}，则也能在set之前调用\n\t//当校验失败时，会触发\"invalid\"事件\n\tvalidate: function(attributes) {\n\t\tif(attributes.name == '') return \"name不能为空\";\n\t},\n\t//定义了名为aboutMe的一个方法（函数）\n\taboutMe: function() {\n\t\treturn \"I'm\" + this.get('name') + \",\" + this.get('age') \n\t\t+ \"years old.\";\n\t}\n});\n//实例化Model，并会直接调用initialize函数\nvar man = new Man;\n//Model.set(attribute),用来给Model修改或设置属性\n//改变了name的值，可以触发change事件，alert\nman.set({name : 'jane'});\n//设置时并不会触发校验\nman.set({name : ''});\n//model.save(attributes, options)，保存模型到数据库\n//如果验证成功，返回jqXHR，否则false\n//触发校验，根据验证规则弹出错误提示。\nman.save();\n//从服务器端获取数据\nvar man1 = new Man;\n//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作\nman1.fetch();\n//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json\nman1.fetch({url : '/man/'});\n//在服务器端返回数据的方法：\nman1.fetch({url:'/man/',success:function(model,response) {\n\t\t//model为获取到的数据\n\t\talert('success');\n\t\talert(model.get('name'));\n\t},error:function(){\n\t\t//当返回格式不正确或不是json数据时，会执行此方法\n\t\talert('error');\n\t}\n});\n```\n* **tip：** 关于`$(selector).bind(event,data,function)`\nevent：必填项，可以添加一个或多个，用空格隔开。\ndata：可以填可以不填，用来传递额外的数据\nfunction：必填项，事件发生时运行的函数\n[关于jQuery的事件方法](http://www.w3school.com.cn/jquery/jquery_ref_events.asp)\n\n","source":"_posts/17-03-28-8.md","raw":"---\ntitle: 从零开始的backbone.js（一）\ndate: 2017-03-28 16:24:10\n---\n实习项目用的框架：backbone.js\n\n> Backbone.js为复杂WEB应用程序提供**模型(models)**、**集合(collections)**、**视图(views)**的结构。\n\n<!--more-->\n\n## Backbone.Model（模型）\n* Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。\n```javascript\n//相当于public class ...\n//可以存放基本的数值以及方法\nvar Man = Backbone.Model.extend({\n\t//模型在服务器上位置的url\n\t//调用save方法时会post对象的所有属性到server端，数据形式是json\n\turl: '/man/',\n\t//定义了一个Model，实现了初始化方法（initialize函数）\n\tinitialize: function() {\n\t\talert('Hey,you create me!');\n\t\t//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个\n\t\t//当name发生改变时触发该函数\n\t\tthis.bind(\"change:name\",function(){\n\t\t\tvar name = this.get(\"name\");\n\t\t\talert(\"you change the name:\" + name);\n\t\t});\n\t\tthis.bind(\"invalid\",function(model,error){\n\t\t\talert(error);\n\t\t\t//error是来自validate校验的错误\n\t\t})\n\t},\n\t//定义默认值（属性）name & age\n\tdefaults: {\n\t\tname: 'tom',\n\t\tage: '18'\n\t},\n\t//Model.validate(attributes, options)，默认为未定义\n\t//默认在save之前调用，如果{validate:true}，则也能在set之前调用\n\t//当校验失败时，会触发\"invalid\"事件\n\tvalidate: function(attributes) {\n\t\tif(attributes.name == '') return \"name不能为空\";\n\t},\n\t//定义了名为aboutMe的一个方法（函数）\n\taboutMe: function() {\n\t\treturn \"I'm\" + this.get('name') + \",\" + this.get('age') \n\t\t+ \"years old.\";\n\t}\n});\n//实例化Model，并会直接调用initialize函数\nvar man = new Man;\n//Model.set(attribute),用来给Model修改或设置属性\n//改变了name的值，可以触发change事件，alert\nman.set({name : 'jane'});\n//设置时并不会触发校验\nman.set({name : ''});\n//model.save(attributes, options)，保存模型到数据库\n//如果验证成功，返回jqXHR，否则false\n//触发校验，根据验证规则弹出错误提示。\nman.save();\n//从服务器端获取数据\nvar man1 = new Man;\n//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作\nman1.fetch();\n//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json\nman1.fetch({url : '/man/'});\n//在服务器端返回数据的方法：\nman1.fetch({url:'/man/',success:function(model,response) {\n\t\t//model为获取到的数据\n\t\talert('success');\n\t\talert(model.get('name'));\n\t},error:function(){\n\t\t//当返回格式不正确或不是json数据时，会执行此方法\n\t\talert('error');\n\t}\n});\n```\n* **tip：** 关于`$(selector).bind(event,data,function)`\nevent：必填项，可以添加一个或多个，用空格隔开。\ndata：可以填可以不填，用来传递额外的数据\nfunction：必填项，事件发生时运行的函数\n[关于jQuery的事件方法](http://www.w3school.com.cn/jquery/jquery_ref_events.asp)\n\n","slug":"17-03-28-8","published":1,"updated":"2017-07-15T07:47:59.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq8z00063ocgm5dnj2hi","content":"<p>实习项目用的框架：backbone.js</p>\n<blockquote>\n<p>Backbone.js为复杂WEB应用程序提供<strong>模型(models)</strong>、<strong>集合(collections)</strong>、<strong>视图(views)</strong>的结构。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Backbone-Model（模型）\"><a href=\"#Backbone-Model（模型）\" class=\"headerlink\" title=\"Backbone.Model（模型）\"></a>Backbone.Model（模型）</h2><ul>\n<li><p>Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//相当于public class ...</span></div><div class=\"line\"><span class=\"comment\">//可以存放基本的数值以及方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> Man = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//模型在服务器上位置的url</span></div><div class=\"line\">\t<span class=\"comment\">//调用save方法时会post对象的所有属性到server端，数据形式是json</span></div><div class=\"line\">\turl: <span class=\"string\">'/man/'</span>,</div><div class=\"line\">\t<span class=\"comment\">//定义了一个Model，实现了初始化方法（initialize函数）</span></div><div class=\"line\">\tinitialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">'Hey,you create me!'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个</span></div><div class=\"line\">\t\t<span class=\"comment\">//当name发生改变时触发该函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"change:name\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.get(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">\t\t\talert(<span class=\"string\">\"you change the name:\"</span> + name);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"invalid\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,error</span>)</span>&#123;</div><div class=\"line\">\t\t\talert(error);</div><div class=\"line\">\t\t\t<span class=\"comment\">//error是来自validate校验的错误</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义默认值（属性）name &amp; age</span></div><div class=\"line\">\tdefaults: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">'tom'</span>,</div><div class=\"line\">\t\t<span class=\"attr\">age</span>: <span class=\"string\">'18'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//Model.validate(attributes, options)，默认为未定义</span></div><div class=\"line\">\t<span class=\"comment\">//默认在save之前调用，如果&#123;validate:true&#125;，则也能在set之前调用</span></div><div class=\"line\">\t<span class=\"comment\">//当校验失败时，会触发\"invalid\"事件</span></div><div class=\"line\">\tvalidate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">attributes</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(attributes.name == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"name不能为空\"</span>;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义了名为aboutMe的一个方法（函数）</span></div><div class=\"line\">\taboutMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"I'm\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'name'</span>) + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'age'</span>) </div><div class=\"line\">\t\t+ <span class=\"string\">\"years old.\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化Model，并会直接调用initialize函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> man = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//Model.set(attribute),用来给Model修改或设置属性</span></div><div class=\"line\"><span class=\"comment\">//改变了name的值，可以触发change事件，alert</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'jane'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//设置时并不会触发校验</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">''</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//model.save(attributes, options)，保存模型到数据库</span></div><div class=\"line\"><span class=\"comment\">//如果验证成功，返回jqXHR，否则false</span></div><div class=\"line\"><span class=\"comment\">//触发校验，根据验证规则弹出错误提示。</span></div><div class=\"line\">man.save();</div><div class=\"line\"><span class=\"comment\">//从服务器端获取数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> man1 = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作</span></div><div class=\"line\">man1.fetch();</div><div class=\"line\"><span class=\"comment\">//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span> : <span class=\"string\">'/man/'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//在服务器端返回数据的方法：</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span>:<span class=\"string\">'/man/'</span>,<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,response</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//model为获取到的数据</span></div><div class=\"line\">\t\talert(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t\talert(model.get(<span class=\"string\">'name'</span>));</div><div class=\"line\">\t&#125;,<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//当返回格式不正确或不是json数据时，会执行此方法</span></div><div class=\"line\">\t\talert(<span class=\"string\">'error'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> 关于<code>$(selector).bind(event,data,function)</code><br>event：必填项，可以添加一个或多个，用空格隔开。<br>data：可以填可以不填，用来传递额外的数据<br>function：必填项，事件发生时运行的函数<br><a href=\"http://www.w3school.com.cn/jquery/jquery_ref_events.asp\" target=\"_blank\" rel=\"external\">关于jQuery的事件方法</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>实习项目用的框架：backbone.js</p>\n<blockquote>\n<p>Backbone.js为复杂WEB应用程序提供<strong>模型(models)</strong>、<strong>集合(collections)</strong>、<strong>视图(views)</strong>的结构。</p>\n</blockquote>","more":"<h2 id=\"Backbone-Model（模型）\"><a href=\"#Backbone-Model（模型）\" class=\"headerlink\" title=\"Backbone.Model（模型）\"></a>Backbone.Model（模型）</h2><ul>\n<li><p>Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//相当于public class ...</span></div><div class=\"line\"><span class=\"comment\">//可以存放基本的数值以及方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> Man = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//模型在服务器上位置的url</span></div><div class=\"line\">\t<span class=\"comment\">//调用save方法时会post对象的所有属性到server端，数据形式是json</span></div><div class=\"line\">\turl: <span class=\"string\">'/man/'</span>,</div><div class=\"line\">\t<span class=\"comment\">//定义了一个Model，实现了初始化方法（initialize函数）</span></div><div class=\"line\">\tinitialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">'Hey,you create me!'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个</span></div><div class=\"line\">\t\t<span class=\"comment\">//当name发生改变时触发该函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"change:name\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.get(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">\t\t\talert(<span class=\"string\">\"you change the name:\"</span> + name);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"invalid\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,error</span>)</span>&#123;</div><div class=\"line\">\t\t\talert(error);</div><div class=\"line\">\t\t\t<span class=\"comment\">//error是来自validate校验的错误</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义默认值（属性）name &amp; age</span></div><div class=\"line\">\tdefaults: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">'tom'</span>,</div><div class=\"line\">\t\t<span class=\"attr\">age</span>: <span class=\"string\">'18'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//Model.validate(attributes, options)，默认为未定义</span></div><div class=\"line\">\t<span class=\"comment\">//默认在save之前调用，如果&#123;validate:true&#125;，则也能在set之前调用</span></div><div class=\"line\">\t<span class=\"comment\">//当校验失败时，会触发\"invalid\"事件</span></div><div class=\"line\">\tvalidate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">attributes</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(attributes.name == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"name不能为空\"</span>;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义了名为aboutMe的一个方法（函数）</span></div><div class=\"line\">\taboutMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"I'm\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'name'</span>) + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'age'</span>) </div><div class=\"line\">\t\t+ <span class=\"string\">\"years old.\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化Model，并会直接调用initialize函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> man = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//Model.set(attribute),用来给Model修改或设置属性</span></div><div class=\"line\"><span class=\"comment\">//改变了name的值，可以触发change事件，alert</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'jane'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//设置时并不会触发校验</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">''</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//model.save(attributes, options)，保存模型到数据库</span></div><div class=\"line\"><span class=\"comment\">//如果验证成功，返回jqXHR，否则false</span></div><div class=\"line\"><span class=\"comment\">//触发校验，根据验证规则弹出错误提示。</span></div><div class=\"line\">man.save();</div><div class=\"line\"><span class=\"comment\">//从服务器端获取数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> man1 = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作</span></div><div class=\"line\">man1.fetch();</div><div class=\"line\"><span class=\"comment\">//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span> : <span class=\"string\">'/man/'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//在服务器端返回数据的方法：</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span>:<span class=\"string\">'/man/'</span>,<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,response</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//model为获取到的数据</span></div><div class=\"line\">\t\talert(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t\talert(model.get(<span class=\"string\">'name'</span>));</div><div class=\"line\">\t&#125;,<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//当返回格式不正确或不是json数据时，会执行此方法</span></div><div class=\"line\">\t\talert(<span class=\"string\">'error'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> 关于<code>$(selector).bind(event,data,function)</code><br>event：必填项，可以添加一个或多个，用空格隔开。<br>data：可以填可以不填，用来传递额外的数据<br>function：必填项，事件发生时运行的函数<br><a href=\"http://www.w3school.com.cn/jquery/jquery_ref_events.asp\" target=\"_blank\" rel=\"external\">关于jQuery的事件方法</a></p>\n</li>\n</ul>"},{"title":"从零开始的backbone.js（二）","date":"2017-03-29T08:06:16.000Z","_content":"## Backbone.View（视图）\n* view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。\n* 相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。\n\n<!--more-->\n\n```javascript\nvar searchView = Backbone.View.extend({\n\t//引用的DOM元素（没有指定也会指向一个空的div）\n\tel:\"#search_container\",\n\t//绑定事件\n\tevents:{\n\t\t\"click input[type=button]\":\"doSearch\"\n\t\t//当点击input时，会调用doSearch\n\t},\n\t//初始化函数（一开始就会调用）\n\tinitialize:function() {\n\t\t//调用render渲染页面\n\t\tthis.render({search_label:\"搜索按钮\"});\n\t},\n\t//渲染页面函数\n\trender:function(context) {\n\t\t//html模板\n\t\tvar template = _.template($(\"#search_template\").html());\n\t\t$(this.el).html(template(context));\n\t},\n\t//doSearch函数定义\n\tdoSearch:function(){\n\t\talert(\"search for\" + $(\"#search_input\").val());\n\t}\n});\n//实例化\nvar SearchView = new searchView();\n```\n","source":"_posts/17-03-29-9.md","raw":"---\ntitle: 从零开始的backbone.js（二）\ndate: 2017-03-29 16:06:16\n---\n## Backbone.View（视图）\n* view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。\n* 相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。\n\n<!--more-->\n\n```javascript\nvar searchView = Backbone.View.extend({\n\t//引用的DOM元素（没有指定也会指向一个空的div）\n\tel:\"#search_container\",\n\t//绑定事件\n\tevents:{\n\t\t\"click input[type=button]\":\"doSearch\"\n\t\t//当点击input时，会调用doSearch\n\t},\n\t//初始化函数（一开始就会调用）\n\tinitialize:function() {\n\t\t//调用render渲染页面\n\t\tthis.render({search_label:\"搜索按钮\"});\n\t},\n\t//渲染页面函数\n\trender:function(context) {\n\t\t//html模板\n\t\tvar template = _.template($(\"#search_template\").html());\n\t\t$(this.el).html(template(context));\n\t},\n\t//doSearch函数定义\n\tdoSearch:function(){\n\t\talert(\"search for\" + $(\"#search_input\").val());\n\t}\n});\n//实例化\nvar SearchView = new searchView();\n```\n","slug":"17-03-29-9","published":1,"updated":"2017-07-15T07:48:03.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9100073ocg7fxku0kd","content":"<h2 id=\"Backbone-View（视图）\"><a href=\"#Backbone-View（视图）\" class=\"headerlink\" title=\"Backbone.View（视图）\"></a>Backbone.View（视图）</h2><ul>\n<li>view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。</li>\n<li>相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> searchView = Backbone.View.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//引用的DOM元素（没有指定也会指向一个空的div）</span></div><div class=\"line\">\tel:<span class=\"string\">\"#search_container\"</span>,</div><div class=\"line\">\t<span class=\"comment\">//绑定事件</span></div><div class=\"line\">\tevents:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"click input[type=button]\"</span>:<span class=\"string\">\"doSearch\"</span></div><div class=\"line\">\t\t<span class=\"comment\">//当点击input时，会调用doSearch</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//初始化函数（一开始就会调用）</span></div><div class=\"line\">\tinitialize:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//调用render渲染页面</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.render(&#123;<span class=\"attr\">search_label</span>:<span class=\"string\">\"搜索按钮\"</span>&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//渲染页面函数</span></div><div class=\"line\">\trender:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//html模板</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> template = _.template($(<span class=\"string\">\"#search_template\"</span>).html());</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.el).html(template(context));</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//doSearch函数定义</span></div><div class=\"line\">\tdoSearch:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"search for\"</span> + $(<span class=\"string\">\"#search_input\"</span>).val());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> SearchView = <span class=\"keyword\">new</span> searchView();</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Backbone-View（视图）\"><a href=\"#Backbone-View（视图）\" class=\"headerlink\" title=\"Backbone.View（视图）\"></a>Backbone.View（视图）</h2><ul>\n<li>view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。</li>\n<li>相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。</li>\n</ul>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> searchView = Backbone.View.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//引用的DOM元素（没有指定也会指向一个空的div）</span></div><div class=\"line\">\tel:<span class=\"string\">\"#search_container\"</span>,</div><div class=\"line\">\t<span class=\"comment\">//绑定事件</span></div><div class=\"line\">\tevents:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"click input[type=button]\"</span>:<span class=\"string\">\"doSearch\"</span></div><div class=\"line\">\t\t<span class=\"comment\">//当点击input时，会调用doSearch</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//初始化函数（一开始就会调用）</span></div><div class=\"line\">\tinitialize:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//调用render渲染页面</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.render(&#123;<span class=\"attr\">search_label</span>:<span class=\"string\">\"搜索按钮\"</span>&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//渲染页面函数</span></div><div class=\"line\">\trender:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//html模板</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> template = _.template($(<span class=\"string\">\"#search_template\"</span>).html());</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.el).html(template(context));</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//doSearch函数定义</span></div><div class=\"line\">\tdoSearch:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"search for\"</span> + $(<span class=\"string\">\"#search_input\"</span>).val());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> SearchView = <span class=\"keyword\">new</span> searchView();</div></pre></td></tr></table></figure>"},{"title":"从零开始的backbone.js（三）","date":"2017-04-06T05:47:54.000Z","_content":"## Backbone.Collection（集合）\n* model是现实中物体的抽象，而collection则是model对象的一个有序的集合\n\n<!--more-->\n\n```javascript\nvar Book = Backbone.Model.extend({\n\tdefaults:{\n\t\ttitle:\"default\"\n\t},\n\tinitialize:function(){\n\t\talert(this.title);\n\t}\n});\n\nvar BookShelf = Backbone.Collection.extend({\n\t//model Book的集合\n\tmodel:Book;\n});\n\n//创建三个Book model\nvar book1 = new Book({title:\"book1\"});\nvar book2 = new Book({title:\"book2\"});\nvar book3 = new Book({title:\"book3\"});\n//创建一个bookShelf数组集合\nvar bookShelf = new BookShelf([book1,book2,book3]);\n//或者，可以使用add将book1,book2,book3加入到集合中\n/*\nbookShelf.add(book1);\nbookShelf.add(book2);\nbookShelf.add(book3);\n*/\n//还可以对里面的model进行其他操作\nbookShelf.remove(book3);\n//可以用each对其进行遍历\nbookShelf.each(function(book){\n\talert(book.get(\"title\"));\n});\n//相当于ajax的操作\nbookShelf.url = '/books/'\nbookShelf.fetch({\n\tsuccess:function(){\n\t\t//...\n\t},\n\terror:function(){\n\t\t//...\n\t}\n});\n//create方法，将model对象（json数据）POST到对应的url上\nvar NewBooks = Backbone.Collection.extend({\n\tmodel:Book,\n\turl:'/books/'\n});\nvar books =  new NewBooks;\nvar onebook = books.create({\n\ttitle: \"I'm coming\"\n});\n```","source":"_posts/17-04-06-11.md","raw":"---\ntitle: 从零开始的backbone.js（三）\ndate: 2017-04-06 13:47:54\n---\n## Backbone.Collection（集合）\n* model是现实中物体的抽象，而collection则是model对象的一个有序的集合\n\n<!--more-->\n\n```javascript\nvar Book = Backbone.Model.extend({\n\tdefaults:{\n\t\ttitle:\"default\"\n\t},\n\tinitialize:function(){\n\t\talert(this.title);\n\t}\n});\n\nvar BookShelf = Backbone.Collection.extend({\n\t//model Book的集合\n\tmodel:Book;\n});\n\n//创建三个Book model\nvar book1 = new Book({title:\"book1\"});\nvar book2 = new Book({title:\"book2\"});\nvar book3 = new Book({title:\"book3\"});\n//创建一个bookShelf数组集合\nvar bookShelf = new BookShelf([book1,book2,book3]);\n//或者，可以使用add将book1,book2,book3加入到集合中\n/*\nbookShelf.add(book1);\nbookShelf.add(book2);\nbookShelf.add(book3);\n*/\n//还可以对里面的model进行其他操作\nbookShelf.remove(book3);\n//可以用each对其进行遍历\nbookShelf.each(function(book){\n\talert(book.get(\"title\"));\n});\n//相当于ajax的操作\nbookShelf.url = '/books/'\nbookShelf.fetch({\n\tsuccess:function(){\n\t\t//...\n\t},\n\terror:function(){\n\t\t//...\n\t}\n});\n//create方法，将model对象（json数据）POST到对应的url上\nvar NewBooks = Backbone.Collection.extend({\n\tmodel:Book,\n\turl:'/books/'\n});\nvar books =  new NewBooks;\nvar onebook = books.create({\n\ttitle: \"I'm coming\"\n});\n```","slug":"17-04-06-11","published":1,"updated":"2017-07-15T07:48:06.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9900083ocgbaqgpll5","content":"<h2 id=\"Backbone-Collection（集合）\"><a href=\"#Backbone-Collection（集合）\" class=\"headerlink\" title=\"Backbone.Collection（集合）\"></a>Backbone.Collection（集合）</h2><ul>\n<li>model是现实中物体的抽象，而collection则是model对象的一个有序的集合</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">defaults</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">title</span>:<span class=\"string\">\"default\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.title);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BookShelf = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//model Book的集合</span></div><div class=\"line\">\tmodel:Book;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建三个Book model</span></div><div class=\"line\"><span class=\"keyword\">var</span> book1 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book1\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book2\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book3 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book3\"</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//创建一个bookShelf数组集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> bookShelf = <span class=\"keyword\">new</span> BookShelf([book1,book2,book3]);</div><div class=\"line\"><span class=\"comment\">//或者，可以使用add将book1,book2,book3加入到集合中</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">bookShelf.add(book1);</div><div class=\"line\">bookShelf.add(book2);</div><div class=\"line\">bookShelf.add(book3);</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"comment\">//还可以对里面的model进行其他操作</span></div><div class=\"line\">bookShelf.remove(book3);</div><div class=\"line\"><span class=\"comment\">//可以用each对其进行遍历</span></div><div class=\"line\">bookShelf.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>)</span>&#123;</div><div class=\"line\">\talert(book.get(<span class=\"string\">\"title\"</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//相当于ajax的操作</span></div><div class=\"line\">bookShelf.url = <span class=\"string\">'/books/'</span></div><div class=\"line\">bookShelf.fetch(&#123;</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//create方法，将model对象（json数据）POST到对应的url上</span></div><div class=\"line\"><span class=\"keyword\">var</span> NewBooks = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">model</span>:Book,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">'/books/'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> books =  <span class=\"keyword\">new</span> NewBooks;</div><div class=\"line\"><span class=\"keyword\">var</span> onebook = books.create(&#123;</div><div class=\"line\">\t<span class=\"attr\">title</span>: <span class=\"string\">\"I'm coming\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Backbone-Collection（集合）\"><a href=\"#Backbone-Collection（集合）\" class=\"headerlink\" title=\"Backbone.Collection（集合）\"></a>Backbone.Collection（集合）</h2><ul>\n<li>model是现实中物体的抽象，而collection则是model对象的一个有序的集合</li>\n</ul>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">defaults</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">title</span>:<span class=\"string\">\"default\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.title);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BookShelf = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//model Book的集合</span></div><div class=\"line\">\tmodel:Book;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建三个Book model</span></div><div class=\"line\"><span class=\"keyword\">var</span> book1 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book1\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book2\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book3 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book3\"</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//创建一个bookShelf数组集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> bookShelf = <span class=\"keyword\">new</span> BookShelf([book1,book2,book3]);</div><div class=\"line\"><span class=\"comment\">//或者，可以使用add将book1,book2,book3加入到集合中</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">bookShelf.add(book1);</div><div class=\"line\">bookShelf.add(book2);</div><div class=\"line\">bookShelf.add(book3);</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"comment\">//还可以对里面的model进行其他操作</span></div><div class=\"line\">bookShelf.remove(book3);</div><div class=\"line\"><span class=\"comment\">//可以用each对其进行遍历</span></div><div class=\"line\">bookShelf.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>)</span>&#123;</div><div class=\"line\">\talert(book.get(<span class=\"string\">\"title\"</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//相当于ajax的操作</span></div><div class=\"line\">bookShelf.url = <span class=\"string\">'/books/'</span></div><div class=\"line\">bookShelf.fetch(&#123;</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//create方法，将model对象（json数据）POST到对应的url上</span></div><div class=\"line\"><span class=\"keyword\">var</span> NewBooks = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">model</span>:Book,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">'/books/'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> books =  <span class=\"keyword\">new</span> NewBooks;</div><div class=\"line\"><span class=\"keyword\">var</span> onebook = books.create(&#123;</div><div class=\"line\">\t<span class=\"attr\">title</span>: <span class=\"string\">\"I'm coming\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"前端模块化","date":"2017-04-06T06:46:01.000Z","_content":"## AMD\n\n* AMD 即`Asynchronous Module Definition`，中文名是**异步模块定义**的意思。它是一个在浏览器端模块化开发的规范。\n\n<!--more-->\n\n* 应用：**RequireJS**\n  解决的主要问题：\n\t* 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\t* js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n* `define([id], [dependencies], factory);`\n\t* id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\t* dependencies：是一个当前模块依赖的模块名称数组\n\t* factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n* `require([dependencies], function(){});`\n\t* dependencies：一个数组，表示所依赖的模块\n\t* function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\t* `require()`函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n* 使用例子：\n```javascript\n// 定义模块 myModule.js\ndefine(['dependency'], function(){\n    var name = 'Byron';\n    function printName(){\n        console.log(name);\n    }\n    return {\n        printName: printName\n    };\n});\n\n// 加载模块\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n## CMD\n\n* CMD 即`Common Module Definition`通用模块定义\n* 应用：**SeaJS**\n  SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n* `define([id],[deps],factory)`\n\t* 一个文件一个模块，所以经常就用文件名作为模块id\n\t* CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\t* factory有三个参数：`function(require, exports, module)`\n* `require(id)`\n\t* require 是一个方法，接受**模块标识**作为唯一参数，用来获取其他模块提供的接口\n* `exports`\n\t* exports 是一个对象，用来向外提供模块接口\n* `module`\n\t* module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n* 使用例子：\n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n\n});\n```\n\n## AMD与CMD的区别\n\n> AMD 是提前执行，CMD 是延迟执行\n> 在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require","source":"_posts/17-04-06-12.md","raw":"---\ntitle: 前端模块化\ndate: 2017-04-06 14:46:01\n---\n## AMD\n\n* AMD 即`Asynchronous Module Definition`，中文名是**异步模块定义**的意思。它是一个在浏览器端模块化开发的规范。\n\n<!--more-->\n\n* 应用：**RequireJS**\n  解决的主要问题：\n\t* 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\t* js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n* `define([id], [dependencies], factory);`\n\t* id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\t* dependencies：是一个当前模块依赖的模块名称数组\n\t* factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n* `require([dependencies], function(){});`\n\t* dependencies：一个数组，表示所依赖的模块\n\t* function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\t* `require()`函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n* 使用例子：\n```javascript\n// 定义模块 myModule.js\ndefine(['dependency'], function(){\n    var name = 'Byron';\n    function printName(){\n        console.log(name);\n    }\n    return {\n        printName: printName\n    };\n});\n\n// 加载模块\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n## CMD\n\n* CMD 即`Common Module Definition`通用模块定义\n* 应用：**SeaJS**\n  SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n* `define([id],[deps],factory)`\n\t* 一个文件一个模块，所以经常就用文件名作为模块id\n\t* CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\t* factory有三个参数：`function(require, exports, module)`\n* `require(id)`\n\t* require 是一个方法，接受**模块标识**作为唯一参数，用来获取其他模块提供的接口\n* `exports`\n\t* exports 是一个对象，用来向外提供模块接口\n* `module`\n\t* module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n* 使用例子：\n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n\n});\n```\n\n## AMD与CMD的区别\n\n> AMD 是提前执行，CMD 是延迟执行\n> 在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require","slug":"17-04-06-12","published":1,"updated":"2017-07-15T07:48:09.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9a00093ocgou9d4cbd","content":"<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><ul>\n<li>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>应用：<strong>RequireJS</strong><br>解决的主要问题：<ul>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ul>\n</li>\n<li><code>define([id], [dependencies], factory);</code><ul>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ul>\n</li>\n<li><code>require([dependencies], function(){});</code><ul>\n<li>dependencies：一个数组，表示所依赖的模块</li>\n<li>function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n<li><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块 myModule.js</span></div><div class=\"line\">define([<span class=\"string\">'dependency'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Byron'</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">printName</span>: printName</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'myModule'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\">　 my.printName();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><ul>\n<li>CMD 即<code>Common Module Definition</code>通用模块定义</li>\n<li>应用：<strong>SeaJS</strong><br>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</li>\n<li><code>define([id],[deps],factory)</code><ul>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n<li>factory有三个参数：<code>function(require, exports, module)</code></li>\n</ul>\n</li>\n<li><code>require(id)</code><ul>\n<li>require 是一个方法，接受<strong>模块标识</strong>作为唯一参数，用来获取其他模块提供的接口</li>\n</ul>\n</li>\n<li><code>exports</code><ul>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n</ul>\n</li>\n<li><code>module</code><ul>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块  myModule.js</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</div><div class=\"line\">  $(<span class=\"string\">'div'</span>).addClass(<span class=\"string\">'active'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\">seajs.use([<span class=\"string\">'myModule.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"AMD与CMD的区别\"><a href=\"#AMD与CMD的区别\" class=\"headerlink\" title=\"AMD与CMD的区别\"></a>AMD与CMD的区别</h2><blockquote>\n<p>AMD 是提前执行，CMD 是延迟执行<br>在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><ul>\n<li>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范。</li>\n</ul>","more":"<ul>\n<li>应用：<strong>RequireJS</strong><br>解决的主要问题：<ul>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ul>\n</li>\n<li><code>define([id], [dependencies], factory);</code><ul>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ul>\n</li>\n<li><code>require([dependencies], function(){});</code><ul>\n<li>dependencies：一个数组，表示所依赖的模块</li>\n<li>function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n<li><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块 myModule.js</span></div><div class=\"line\">define([<span class=\"string\">'dependency'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Byron'</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">printName</span>: printName</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'myModule'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\">　 my.printName();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><ul>\n<li>CMD 即<code>Common Module Definition</code>通用模块定义</li>\n<li>应用：<strong>SeaJS</strong><br>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</li>\n<li><code>define([id],[deps],factory)</code><ul>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n<li>factory有三个参数：<code>function(require, exports, module)</code></li>\n</ul>\n</li>\n<li><code>require(id)</code><ul>\n<li>require 是一个方法，接受<strong>模块标识</strong>作为唯一参数，用来获取其他模块提供的接口</li>\n</ul>\n</li>\n<li><code>exports</code><ul>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n</ul>\n</li>\n<li><code>module</code><ul>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块  myModule.js</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</div><div class=\"line\">  $(<span class=\"string\">'div'</span>).addClass(<span class=\"string\">'active'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\">seajs.use([<span class=\"string\">'myModule.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"AMD与CMD的区别\"><a href=\"#AMD与CMD的区别\" class=\"headerlink\" title=\"AMD与CMD的区别\"></a>AMD与CMD的区别</h2><blockquote>\n<p>AMD 是提前执行，CMD 是延迟执行<br>在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>"},{"title":"有关CSS的tip","date":"2017-04-10T02:16:38.000Z","_content":"#### position的值，relative和absolute分别是相对于谁进行定位的？\n* `absolute` 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。\n* `fixed` （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。\n* `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。\n* `static` 默认值。没有定位，元素出现在正常的流中\n\n<!--more-->\n\n#### display:none和visibility:hidden的区别？\n* `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n* `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n#### position:absolute和float属性的异同\n* 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n* 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。\n\n#### CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n* 选择符\n```\n1.id选择器（ #myid）\n\n2.类选择器（.myclassname）\n\n3.标签选择器（div, h1, p）\n\n4.相邻选择器（h1 + p）\n\n5.子选择器（ul > li）\n\n6.后代选择器（li a）\n\n7.通配符选择器（ * ）\n\n8.属性选择器（a[rel = \"external\"]）\n\n9.伪类选择器（a: hover, li:nth-child）\n```\n* 继承\n\t* **不可继承：** display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi\n\t* **所有元素可继承：** visibility、cursor\n\t* **内联元素可继承：** letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction\n\t* **终端块状元素可继承：** text-indent和text-align\n\t* **列表元素可继承：** list-style、list-style-type、list-style-position、list-style-image\n* 优先级\n```\n!important > id > class > tag\n```\n* 新增伪类\n```\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\np:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:enabled  :disabled 控制表单控件的禁用状态。\n\n:checked        单选框或复选框被选中。\n```\n\n#### CSS3有哪些新特性？\n```\nCSS3实现圆角（border-radius）\n\n阴影（box-shadow）\n\n对文字加特效（text-shadow）\n\n线性渐变（gradient）\n\n动画（animation）\n\n变换（transform）\n\ntransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n//旋转,缩放,定位,倾斜\n\n增加了更多的CSS选择器  多背景 rgba\n\n在CSS3中唯一引入的伪元素是::selection.\n\n媒体查询，多栏布局\n\nborder-image\n\n盒模型计算方式（box-sizing）\n```\n\n#### 有关盒模型计算\n* **content-box（默认）**\n\n布局所占宽度Width：\n```\nWidth = width + padding-left + padding-right + border-left + border-right\n```\n布局所占高度Height：\n```\nHeight = height + padding-top + padding-bottom + border-top + border-bottom\n```\n\n* **padding-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right) + border-top + border-bottom\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom) + border-top + border-bottom\n```\n\n* **border-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right + border-left + border-right)\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom + border-top + border-bottom)\n```\n\n#### 清除浮动的技巧\n* **使用空标签清除浮动。**\n这种方法是在所有浮动标签后面添加一个空标签，定义css `clear:both` ，弊端就是增加了无意义。\n* **使用overflow。**\n给包含浮动元素的父标签添加css属性 `overflow:auto; zoom:1; zoom:1` 用于兼容IE6。\n* **使用after伪对象清除浮动。**\n该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n```css\n#parent:after{\n\tcontent:\".\";\n\theight:0;\n\tvisibility:hidden;\n\tdisplay:block;\n\tclear:both;\n}\n```\n\n#### 浮动元素引起的问题和解决办法\n* 浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n* 解决办法：\n（1）使用CSS中的`clear:both;`属性来清除元素的浮动可解决2、3问题\n（2）对于问题1，添加如下样式，给父元素添加`clearfix`样式：\n```css\n.clearfix:after{\n\tcontent: \".\";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix{\n\tdisplay: inline-block;\n} /* for IE/Mac */\n```","source":"_posts/17-04-10-13.md","raw":"---\ntitle: 有关CSS的tip\ndate: 2017-04-10 10:16:38\n---\n#### position的值，relative和absolute分别是相对于谁进行定位的？\n* `absolute` 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。\n* `fixed` （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。\n* `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。\n* `static` 默认值。没有定位，元素出现在正常的流中\n\n<!--more-->\n\n#### display:none和visibility:hidden的区别？\n* `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n* `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n#### position:absolute和float属性的异同\n* 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n* 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。\n\n#### CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n* 选择符\n```\n1.id选择器（ #myid）\n\n2.类选择器（.myclassname）\n\n3.标签选择器（div, h1, p）\n\n4.相邻选择器（h1 + p）\n\n5.子选择器（ul > li）\n\n6.后代选择器（li a）\n\n7.通配符选择器（ * ）\n\n8.属性选择器（a[rel = \"external\"]）\n\n9.伪类选择器（a: hover, li:nth-child）\n```\n* 继承\n\t* **不可继承：** display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi\n\t* **所有元素可继承：** visibility、cursor\n\t* **内联元素可继承：** letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction\n\t* **终端块状元素可继承：** text-indent和text-align\n\t* **列表元素可继承：** list-style、list-style-type、list-style-position、list-style-image\n* 优先级\n```\n!important > id > class > tag\n```\n* 新增伪类\n```\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\np:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:enabled  :disabled 控制表单控件的禁用状态。\n\n:checked        单选框或复选框被选中。\n```\n\n#### CSS3有哪些新特性？\n```\nCSS3实现圆角（border-radius）\n\n阴影（box-shadow）\n\n对文字加特效（text-shadow）\n\n线性渐变（gradient）\n\n动画（animation）\n\n变换（transform）\n\ntransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n//旋转,缩放,定位,倾斜\n\n增加了更多的CSS选择器  多背景 rgba\n\n在CSS3中唯一引入的伪元素是::selection.\n\n媒体查询，多栏布局\n\nborder-image\n\n盒模型计算方式（box-sizing）\n```\n\n#### 有关盒模型计算\n* **content-box（默认）**\n\n布局所占宽度Width：\n```\nWidth = width + padding-left + padding-right + border-left + border-right\n```\n布局所占高度Height：\n```\nHeight = height + padding-top + padding-bottom + border-top + border-bottom\n```\n\n* **padding-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right) + border-top + border-bottom\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom) + border-top + border-bottom\n```\n\n* **border-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right + border-left + border-right)\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom + border-top + border-bottom)\n```\n\n#### 清除浮动的技巧\n* **使用空标签清除浮动。**\n这种方法是在所有浮动标签后面添加一个空标签，定义css `clear:both` ，弊端就是增加了无意义。\n* **使用overflow。**\n给包含浮动元素的父标签添加css属性 `overflow:auto; zoom:1; zoom:1` 用于兼容IE6。\n* **使用after伪对象清除浮动。**\n该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n```css\n#parent:after{\n\tcontent:\".\";\n\theight:0;\n\tvisibility:hidden;\n\tdisplay:block;\n\tclear:both;\n}\n```\n\n#### 浮动元素引起的问题和解决办法\n* 浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n* 解决办法：\n（1）使用CSS中的`clear:both;`属性来清除元素的浮动可解决2、3问题\n（2）对于问题1，添加如下样式，给父元素添加`clearfix`样式：\n```css\n.clearfix:after{\n\tcontent: \".\";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix{\n\tdisplay: inline-block;\n} /* for IE/Mac */\n```","slug":"17-04-10-13","published":1,"updated":"2017-07-15T07:48:13.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9c000a3ocgd4w3l7i3","content":"<h4 id=\"position的值，relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值，relative和absolute分别是相对于谁进行定位的？\"></a>position的值，relative和absolute分别是相对于谁进行定位的？</h4><ul>\n<li><code>absolute</code> 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。</li>\n<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h4><ul>\n<li><code>display:none</code> 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>\n<li><code>visibility:hidden</code> 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>\n</ul>\n<h4 id=\"position-absolute和float属性的异同\"><a href=\"#position-absolute和float属性的异同\" class=\"headerlink\" title=\"position:absolute和float属性的异同\"></a>position:absolute和float属性的异同</h4><ul>\n<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>\n<li>不同点：float仍会占据位置，position会覆盖文档流中的其他元素。</li>\n</ul>\n<h4 id=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\"><a href=\"#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><ul>\n<li><p>选择符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.id选择器（ #myid）</div><div class=\"line\"></div><div class=\"line\">2.类选择器（.myclassname）</div><div class=\"line\"></div><div class=\"line\">3.标签选择器（div, h1, p）</div><div class=\"line\"></div><div class=\"line\">4.相邻选择器（h1 + p）</div><div class=\"line\"></div><div class=\"line\">5.子选择器（ul &gt; li）</div><div class=\"line\"></div><div class=\"line\">6.后代选择器（li a）</div><div class=\"line\"></div><div class=\"line\">7.通配符选择器（ * ）</div><div class=\"line\"></div><div class=\"line\">8.属性选择器（a[rel = &quot;external&quot;]）</div><div class=\"line\"></div><div class=\"line\">9.伪类选择器（a: hover, li:nth-child）</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承</p>\n<ul>\n<li><strong>不可继承：</strong> display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li>\n<li><strong>所有元素可继承：</strong> visibility、cursor</li>\n<li><strong>内联元素可继承：</strong> letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</li>\n<li><strong>终端块状元素可继承：</strong> text-indent和text-align</li>\n<li><strong>列表元素可继承：</strong> list-style、list-style-type、list-style-position、list-style-image</li>\n</ul>\n</li>\n<li><p>优先级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">!important &gt; id &gt; class &gt; tag</div></pre></td></tr></table></figure>\n</li>\n<li><p>新增伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">:enabled  :disabled 控制表单控件的禁用状态。</div><div class=\"line\"></div><div class=\"line\">:checked        单选框或复选框被选中。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSS3实现圆角（border-radius）</div><div class=\"line\"></div><div class=\"line\">阴影（box-shadow）</div><div class=\"line\"></div><div class=\"line\">对文字加特效（text-shadow）</div><div class=\"line\"></div><div class=\"line\">线性渐变（gradient）</div><div class=\"line\"></div><div class=\"line\">动画（animation）</div><div class=\"line\"></div><div class=\"line\">变换（transform）</div><div class=\"line\"></div><div class=\"line\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);</div><div class=\"line\">//旋转,缩放,定位,倾斜</div><div class=\"line\"></div><div class=\"line\">增加了更多的CSS选择器  多背景 rgba</div><div class=\"line\"></div><div class=\"line\">在CSS3中唯一引入的伪元素是::selection.</div><div class=\"line\"></div><div class=\"line\">媒体查询，多栏布局</div><div class=\"line\"></div><div class=\"line\">border-image</div><div class=\"line\"></div><div class=\"line\">盒模型计算方式（box-sizing）</div></pre></td></tr></table></figure>\n<h4 id=\"有关盒模型计算\"><a href=\"#有关盒模型计算\" class=\"headerlink\" title=\"有关盒模型计算\"></a>有关盒模型计算</h4><ul>\n<li><strong>content-box（默认）</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>padding-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>border-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure></p>\n<h4 id=\"清除浮动的技巧\"><a href=\"#清除浮动的技巧\" class=\"headerlink\" title=\"清除浮动的技巧\"></a>清除浮动的技巧</h4><ul>\n<li><strong>使用空标签清除浮动。</strong><br>这种方法是在所有浮动标签后面添加一个空标签，定义css <code>clear:both</code> ，弊端就是增加了无意义。</li>\n<li><strong>使用overflow。</strong><br>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1; zoom:1</code> 用于兼容IE6。</li>\n<li><strong>使用after伪对象清除浮动。</strong><br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#parent</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>:hidden;</div><div class=\"line\">\t<span class=\"attribute\">display</span>:block;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>:both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"浮动元素引起的问题和解决办法\"><a href=\"#浮动元素引起的问题和解决办法\" class=\"headerlink\" title=\"浮动元素引起的问题和解决办法\"></a>浮动元素引起的问题和解决办法</h4><ul>\n<li>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n<li>解决办法：<br>（1）使用CSS中的<code>clear:both;</code>属性来清除元素的浮动可解决2、3问题<br>（2）对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>: both;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">&#125; <span class=\"comment\">/* for IE/Mac */</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"position的值，relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值，relative和absolute分别是相对于谁进行定位的？\"></a>position的值，relative和absolute分别是相对于谁进行定位的？</h4><ul>\n<li><code>absolute</code> 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。</li>\n<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n</ul>","more":"<h4 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h4><ul>\n<li><code>display:none</code> 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>\n<li><code>visibility:hidden</code> 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>\n</ul>\n<h4 id=\"position-absolute和float属性的异同\"><a href=\"#position-absolute和float属性的异同\" class=\"headerlink\" title=\"position:absolute和float属性的异同\"></a>position:absolute和float属性的异同</h4><ul>\n<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>\n<li>不同点：float仍会占据位置，position会覆盖文档流中的其他元素。</li>\n</ul>\n<h4 id=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\"><a href=\"#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><ul>\n<li><p>选择符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.id选择器（ #myid）</div><div class=\"line\"></div><div class=\"line\">2.类选择器（.myclassname）</div><div class=\"line\"></div><div class=\"line\">3.标签选择器（div, h1, p）</div><div class=\"line\"></div><div class=\"line\">4.相邻选择器（h1 + p）</div><div class=\"line\"></div><div class=\"line\">5.子选择器（ul &gt; li）</div><div class=\"line\"></div><div class=\"line\">6.后代选择器（li a）</div><div class=\"line\"></div><div class=\"line\">7.通配符选择器（ * ）</div><div class=\"line\"></div><div class=\"line\">8.属性选择器（a[rel = &quot;external&quot;]）</div><div class=\"line\"></div><div class=\"line\">9.伪类选择器（a: hover, li:nth-child）</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承</p>\n<ul>\n<li><strong>不可继承：</strong> display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li>\n<li><strong>所有元素可继承：</strong> visibility、cursor</li>\n<li><strong>内联元素可继承：</strong> letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</li>\n<li><strong>终端块状元素可继承：</strong> text-indent和text-align</li>\n<li><strong>列表元素可继承：</strong> list-style、list-style-type、list-style-position、list-style-image</li>\n</ul>\n</li>\n<li><p>优先级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">!important &gt; id &gt; class &gt; tag</div></pre></td></tr></table></figure>\n</li>\n<li><p>新增伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">:enabled  :disabled 控制表单控件的禁用状态。</div><div class=\"line\"></div><div class=\"line\">:checked        单选框或复选框被选中。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSS3实现圆角（border-radius）</div><div class=\"line\"></div><div class=\"line\">阴影（box-shadow）</div><div class=\"line\"></div><div class=\"line\">对文字加特效（text-shadow）</div><div class=\"line\"></div><div class=\"line\">线性渐变（gradient）</div><div class=\"line\"></div><div class=\"line\">动画（animation）</div><div class=\"line\"></div><div class=\"line\">变换（transform）</div><div class=\"line\"></div><div class=\"line\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);</div><div class=\"line\">//旋转,缩放,定位,倾斜</div><div class=\"line\"></div><div class=\"line\">增加了更多的CSS选择器  多背景 rgba</div><div class=\"line\"></div><div class=\"line\">在CSS3中唯一引入的伪元素是::selection.</div><div class=\"line\"></div><div class=\"line\">媒体查询，多栏布局</div><div class=\"line\"></div><div class=\"line\">border-image</div><div class=\"line\"></div><div class=\"line\">盒模型计算方式（box-sizing）</div></pre></td></tr></table></figure>\n<h4 id=\"有关盒模型计算\"><a href=\"#有关盒模型计算\" class=\"headerlink\" title=\"有关盒模型计算\"></a>有关盒模型计算</h4><ul>\n<li><strong>content-box（默认）</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>padding-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>border-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure></p>\n<h4 id=\"清除浮动的技巧\"><a href=\"#清除浮动的技巧\" class=\"headerlink\" title=\"清除浮动的技巧\"></a>清除浮动的技巧</h4><ul>\n<li><strong>使用空标签清除浮动。</strong><br>这种方法是在所有浮动标签后面添加一个空标签，定义css <code>clear:both</code> ，弊端就是增加了无意义。</li>\n<li><strong>使用overflow。</strong><br>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1; zoom:1</code> 用于兼容IE6。</li>\n<li><strong>使用after伪对象清除浮动。</strong><br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#parent</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>:hidden;</div><div class=\"line\">\t<span class=\"attribute\">display</span>:block;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>:both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"浮动元素引起的问题和解决办法\"><a href=\"#浮动元素引起的问题和解决办法\" class=\"headerlink\" title=\"浮动元素引起的问题和解决办法\"></a>浮动元素引起的问题和解决办法</h4><ul>\n<li>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n<li>解决办法：<br>（1）使用CSS中的<code>clear:both;</code>属性来清除元素的浮动可解决2、3问题<br>（2）对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>: both;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">&#125; <span class=\"comment\">/* for IE/Mac */</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"title":"JavaScript正则表达式","date":"2017-04-21T07:22:18.000Z","_content":">正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n<!--more-->\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","source":"_posts/17-04-21-14.md","raw":"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n<!--more-->\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","slug":"17-04-21-14","published":1,"updated":"2017-07-15T07:48:17.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9f000b3ocgj7bh37nr","content":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\0\t匹配null字符(\\u0000)</div><div class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</div><div class=\"line\">\\t  \t匹配制表符tab(\\u0009)</div><div class=\"line\">\\n  \t匹配换行符(\\u000A)</div><div class=\"line\">\\v      匹配垂直制表符(\\u000B)</div><div class=\"line\">\\f\t匹配换页符(\\u000C)</div><div class=\"line\">\\r\t匹配回车键(\\u000D)</div><div class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</div><div class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</div><div class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</div></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...]   匹配方括号内的任意字符</div><div class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</div><div class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</div><div class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</div><div class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</div><div class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</div><div class=\"line\">\\s \t任何Unicode空白符</div><div class=\"line\">\\S\t任何非Unicode空白符的字符</div><div class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</div><div class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</div></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</div><div class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</div><div class=\"line\">&#123;n&#125; \t匹配前一项n次</div><div class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</div><div class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</div><div class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</div></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</div><div class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</div><div class=\"line\">(...) \t把单独的项组合成子表达式</div><div class=\"line\">\\n\t引用第n个带括号的子表达式</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></div><div class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></div></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</div><div class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</div><div class=\"line\">\\b \t匹配一个单词的边界</div><div class=\"line\">\\B \t匹配非单词边界的位置</div><div class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</div><div class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">i \t执行不区分大小写的匹配</div><div class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</div><div class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</div><div class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></div></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第二个参数：</div><div class=\"line\">$`\t指代匹配结果前面的文本</div><div class=\"line\">$&apos;\t指代匹配结果后面的文本</div><div class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</div><div class=\"line\">$$ \t指代美元符号$</div></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></div></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>","more":"<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\0\t匹配null字符(\\u0000)</div><div class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</div><div class=\"line\">\\t  \t匹配制表符tab(\\u0009)</div><div class=\"line\">\\n  \t匹配换行符(\\u000A)</div><div class=\"line\">\\v      匹配垂直制表符(\\u000B)</div><div class=\"line\">\\f\t匹配换页符(\\u000C)</div><div class=\"line\">\\r\t匹配回车键(\\u000D)</div><div class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</div><div class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</div><div class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</div></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...]   匹配方括号内的任意字符</div><div class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</div><div class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</div><div class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</div><div class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</div><div class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</div><div class=\"line\">\\s \t任何Unicode空白符</div><div class=\"line\">\\S\t任何非Unicode空白符的字符</div><div class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</div><div class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</div></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</div><div class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</div><div class=\"line\">&#123;n&#125; \t匹配前一项n次</div><div class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</div><div class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</div><div class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</div></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</div><div class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</div><div class=\"line\">(...) \t把单独的项组合成子表达式</div><div class=\"line\">\\n\t引用第n个带括号的子表达式</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></div><div class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></div></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</div><div class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</div><div class=\"line\">\\b \t匹配一个单词的边界</div><div class=\"line\">\\B \t匹配非单词边界的位置</div><div class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</div><div class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">i \t执行不区分大小写的匹配</div><div class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</div><div class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</div><div class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></div></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第二个参数：</div><div class=\"line\">$`\t指代匹配结果前面的文本</div><div class=\"line\">$&apos;\t指代匹配结果后面的文本</div><div class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</div><div class=\"line\">$$ \t指代美元符号$</div></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></div></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>"},{"title":"Vue.js学习笔记（一）","date":"2017-05-11T13:25:58.000Z","_content":"> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API\n\n<!--more-->\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- 默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`\n```js\n//import表示导入组件\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n``` ","source":"_posts/17-05-11-16.md","raw":"---\ntitle: Vue.js学习笔记（一）\ndate: 2017-05-11 21:25:58\n---\n> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API\n\n<!--more-->\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- 默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`\n```js\n//import表示导入组件\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n``` ","slug":"17-05-11-16","published":1,"updated":"2017-07-15T07:48:20.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9i000c3ocg19cx1ka8","content":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装vue-cli</span></div><div class=\"line\">$ cnpm install -g vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖</span></div><div class=\"line\">$ cd my-project</div><div class=\"line\">$ cnmp install</div><div class=\"line\"><span class=\"comment\"># 开启项目</span></div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 默认调用src里的main.js --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code></p>\n<pre><code class=\"js\"><span class=\"comment\">//import表示导入组件</span>\n<span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span>\n<span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span>\n<span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span>\n\n\nVue.config.productionTip = <span class=\"literal\">false</span>\n\n<span class=\"comment\">/* eslint-disable no-new */</span>\n<span class=\"keyword\">new</span> Vue({\n  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,\n  router,\n  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;App/&gt;'</span>,\n  <span class=\"attr\">components</span>: { App }  <span class=\"comment\">//注册一个app</span>\n})\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API</p>\n</blockquote>","more":"<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装vue-cli</span></div><div class=\"line\">$ cnpm install -g vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖</span></div><div class=\"line\">$ cd my-project</div><div class=\"line\">$ cnmp install</div><div class=\"line\"><span class=\"comment\"># 开启项目</span></div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 默认调用src里的main.js --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code></p>\n<pre><code class=\"js\"><span class=\"comment\">//import表示导入组件</span>\n<span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span>\n<span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span>\n<span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span>\n\n\nVue.config.productionTip = <span class=\"literal\">false</span>\n\n<span class=\"comment\">/* eslint-disable no-new */</span>\n<span class=\"keyword\">new</span> Vue({\n  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,\n  router,\n  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;App/&gt;'</span>,\n  <span class=\"attr\">components</span>: { App }  <span class=\"comment\">//注册一个app</span>\n})\n</code></pre>"},{"title":"JS继承笔记","date":"2017-07-07T14:02:11.000Z","_content":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n<!--more-->\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n\tthis.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n\tthis.name = name;\n\tthis.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n\tAnimal.apply(this.arguments);\n\tthis.name = name;\n\tthis.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n\tvar temp = function() {};\n\ttemp.prototype = parent.prototype;\n\tchild.prototype = new temp();\n\tchild.prototype.constructor = child;\n\tchild.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","source":"_posts/17-07-07-17.md","raw":"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n<!--more-->\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n\tthis.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n\tthis.name = name;\n\tthis.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n\tAnimal.apply(this.arguments);\n\tthis.name = name;\n\tthis.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n\tvar temp = function() {};\n\ttemp.prototype = parent.prototype;\n\tchild.prototype = new temp();\n\tchild.prototype.constructor = child;\n\tchild.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","slug":"17-07-07-17","published":1,"updated":"2017-07-15T08:06:43.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9k000d3ocgoozp7g2i","content":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<a id=\"more\"></a>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt=\"\"><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//现有两个构造函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">\tAnimal.apply(<span class=\"keyword\">this</span>.arguments);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div><div class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></div><div class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">funtion Animal() &#123;&#125;</div><div class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">F.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\ttemp.prototype = parent.prototype;</div><div class=\"line\">\tchild.prototype = <span class=\"keyword\">new</span> temp();</div><div class=\"line\">\tchild.prototype.constructor = child;</div><div class=\"line\">\tchild.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>","more":"<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt=\"\"><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//现有两个构造函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">\tAnimal.apply(<span class=\"keyword\">this</span>.arguments);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div><div class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></div><div class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">funtion Animal() &#123;&#125;</div><div class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">F.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\ttemp.prototype = parent.prototype;</div><div class=\"line\">\tchild.prototype = <span class=\"keyword\">new</span> temp();</div><div class=\"line\">\tchild.prototype.constructor = child;</div><div class=\"line\">\tchild.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt=\"\"></p>"},{"title":"JS之this指针笔记","date":"2017-07-08T05:48:43.000Z","_content":"## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!--more-->\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n\tthis.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n\talert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n\ttest: function () {\n\t\tthis.x = 1;\n\t} //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n\ttest: function () {\n\t\t//在构造函数的时候也会调用其他的函数，所以this的指向就会变\n\t\t$(this.xx).on(\"click\",function(){\n\t\t\t//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n\t\t})\n\t} \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n\tname: \"小明\",\n\tsex: \"男\",\n\tage: \"18\",\n\tsay: function() {\n\t\talert(this.name + \",\" + this.sex + \",\" + this.age);\n\t}\n}\n\nvar xh = {\n\tname: \"小红\",\n\tsex: \"女\",\n\tage: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n\tthis.txt = \"这是一个对象属性\";\n\t$(\"div\").click($.proxy(this.myClick,this));\n\t//本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n\talert(this.txt);\n\talert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","source":"_posts/17-07-08-18.md","raw":"---\ntitle: JS之this指针笔记\ndate: 2017-07-08 13:48:43\n---\n## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!--more-->\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n\tthis.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n\talert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n\ttest: function () {\n\t\tthis.x = 1;\n\t} //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n\ttest: function () {\n\t\t//在构造函数的时候也会调用其他的函数，所以this的指向就会变\n\t\t$(this.xx).on(\"click\",function(){\n\t\t\t//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n\t\t})\n\t} \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n\tname: \"小明\",\n\tsex: \"男\",\n\tage: \"18\",\n\tsay: function() {\n\t\talert(this.name + \",\" + this.sex + \",\" + this.age);\n\t}\n}\n\nvar xh = {\n\tname: \"小红\",\n\tsex: \"女\",\n\tage: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n\tthis.txt = \"这是一个对象属性\";\n\t$(\"div\").click($.proxy(this.myClick,this));\n\t//本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n\talert(this.txt);\n\talert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","slug":"17-07-08-18","published":1,"updated":"2017-07-15T08:06:56.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9o000e3ocgx4qfvrj7","content":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></div><div class=\"line\">&#125;</div><div class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">\t<span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">\t&#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">\t<span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">\t<span class=\"attr\">sex</span>: <span class=\"string\">\"男\"</span>,</div><div class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"string\">\"18\"</span>,</div><div class=\"line\">\t<span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">\"小红\"</span>,</div><div class=\"line\">\t<span class=\"attr\">sex</span>: <span class=\"string\">\"女\"</span>,</div><div class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</div><div class=\"line\">\t$(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</div><div class=\"line\">\t<span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"keyword\">this</span>.txt);</div><div class=\"line\">\talert(event.currentTarget.nodeName);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>","more":"<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></div><div class=\"line\">&#125;</div><div class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">\t<span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">\t&#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">\t<span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">\t<span class=\"attr\">sex</span>: <span class=\"string\">\"男\"</span>,</div><div class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"string\">\"18\"</span>,</div><div class=\"line\">\t<span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">\"小红\"</span>,</div><div class=\"line\">\t<span class=\"attr\">sex</span>: <span class=\"string\">\"女\"</span>,</div><div class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</div><div class=\"line\">\t$(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</div><div class=\"line\">\t<span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"keyword\">this</span>.txt);</div><div class=\"line\">\talert(event.currentTarget.nodeName);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"搭建Hexo博客之后","date":"2017-07-15T06:59:11.000Z","_content":"\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!--more-->\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n#### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n#### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n#### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n#### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n## git指令整理\n\n因为公司写代码用的工具是git，命令太多记不太清，做个记录\n[git命令大全](http://www.cnblogs.com/cspku/articles/Git_cmds.html)\n\n","source":"_posts/17-07-15-19.md","raw":"---\ntitle: 搭建Hexo博客之后\ndate: 2017-07-15 14:59:11\n---\n\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!--more-->\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n#### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n#### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n#### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n#### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n## git指令整理\n\n因为公司写代码用的工具是git，命令太多记不太清，做个记录\n[git命令大全](http://www.cnblogs.com/cspku/articles/Git_cmds.html)\n\n","slug":"17-07-15-19","published":1,"updated":"2017-07-15T07:53:31.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj565qq9q000f3ocg7p8zzbah","content":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>\n<a id=\"more\"></a>\n<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch README.md</div><div class=\"line\">$ git init </div><div class=\"line\">$ git add README.md</div><div class=\"line\">$ git commit -m &quot;first commit&quot;</div><div class=\"line\">$ git remote add origin 你的项目地址</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull --rebase origin master</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h4 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch hexo</div><div class=\"line\">$ git push origin hexo</div></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h4 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div><div class=\"line\">$ npm install hexo</div><div class=\"line\">$ hexo init</div><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h4><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></div><div class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></div><div class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></div><div class=\"line\"><span class=\"attr\">backup:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span></div><div class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g </div><div class=\"line\">$ hexo d //部署博客</div><div class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h2 id=\"git指令整理\"><a href=\"#git指令整理\" class=\"headerlink\" title=\"git指令整理\"></a>git指令整理</h2><p>因为公司写代码用的工具是git，命令太多记不太清，做个记录<br><a href=\"http://www.cnblogs.com/cspku/articles/Git_cmds.html\" target=\"_blank\" rel=\"external\">git命令大全</a></p>\n","site":{"data":{}},"excerpt":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>","more":"<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch README.md</div><div class=\"line\">$ git init </div><div class=\"line\">$ git add README.md</div><div class=\"line\">$ git commit -m &quot;first commit&quot;</div><div class=\"line\">$ git remote add origin 你的项目地址</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull --rebase origin master</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h4 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch hexo</div><div class=\"line\">$ git push origin hexo</div></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h4 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div><div class=\"line\">$ npm install hexo</div><div class=\"line\">$ hexo init</div><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h4><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></div><div class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></div><div class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></div><div class=\"line\"><span class=\"attr\">backup:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span></div><div class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g </div><div class=\"line\">$ hexo d //部署博客</div><div class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h2 id=\"git指令整理\"><a href=\"#git指令整理\" class=\"headerlink\" title=\"git指令整理\"></a>git指令整理</h2><p>因为公司写代码用的工具是git，命令太多记不太清，做个记录<br><a href=\"http://www.cnblogs.com/cspku/articles/Git_cmds.html\" target=\"_blank\" rel=\"external\">git命令大全</a></p>"},{"title":"异步编程之promise与trigger","date":"2017-07-15T08:13:01.000Z","_content":"这周的学习任务：`promise`与`trigger`\n<!--more-->\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\n\n#### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n#### deferred对象的应用场景\n\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n\n#### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","source":"_posts/17-07-15-20.md","raw":"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\n---\n这周的学习任务：`promise`与`trigger`\n<!--more-->\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\n\n#### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n#### deferred对象的应用场景\n\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n\n#### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","slug":"17-07-15-20","published":1,"updated":"2017-08-16T12:18:13.242Z","_id":"cj565qq9r000g3ocg5la18kmm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code><br><a id=\"more\"></a></p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h4 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h4><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></div><div class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div><div class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  callback();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1(f2);</div><div class=\"line\">f3();</div></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1().then(f2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</div><div class=\"line\">　<span class=\"comment\">// f1的任务代码</span></div><div class=\"line\">　dfd.resolve();</div><div class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h4 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h4><ul>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">      <span class=\"attr\">url</span>: ...,</div><div class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        ....</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"...\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  dosth();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n</ul>\n<h4 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h4><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code><br>","more":"</p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h4 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h4><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></div><div class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div><div class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  callback();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1(f2);</div><div class=\"line\">f3();</div></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1().then(f2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</div><div class=\"line\">　<span class=\"comment\">// f1的任务代码</span></div><div class=\"line\">　dfd.resolve();</div><div class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h4 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h4><ul>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">      <span class=\"attr\">url</span>: ...,</div><div class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        ....</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"...\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  dosth();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n</ul>\n<h4 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h4><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}