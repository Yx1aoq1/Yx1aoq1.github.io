{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/canvas-img-1.png","path":"images/canvas-img-1.png","modified":0,"renderable":0},{"_id":"source/images/dom-1.png","path":"images/dom-1.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/http-2.png","path":"images/http-2.png","modified":0,"renderable":0},{"_id":"source/images/http.png","path":"images/http.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-2.png","path":"images/iconfont-img-2.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-3.png","path":"images/iconfont-img-3.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-4.png","path":"images/iconfont-img-4.png","modified":0,"renderable":0},{"_id":"source/images/jicheng-2.png","path":"images/jicheng-2.png","modified":0,"renderable":0},{"_id":"source/images/jicheng-1.png","path":"images/jicheng-1.png","modified":0,"renderable":0},{"_id":"source/images/osi.png","path":"images/osi.png","modified":0,"renderable":0},{"_id":"source/images/stack&heap-1.png","path":"images/stack&heap-1.png","modified":0,"renderable":0},{"_id":"source/images/stack&heap-3.png","path":"images/stack&heap-3.png","modified":0,"renderable":0},{"_id":"source/images/stack&heap-2.png","path":"images/stack&heap-2.png","modified":0,"renderable":0},{"_id":"source/images/tcp-ip.png","path":"images/tcp-ip.png","modified":0,"renderable":0},{"_id":"source/images/variable-1.png","path":"images/variable-1.png","modified":0,"renderable":0},{"_id":"source/images/dom-2.png","path":"images/dom-2.png","modified":0,"renderable":0},{"_id":"source/images/iconfont-img-1.png","path":"images/iconfont-img-1.png","modified":0,"renderable":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"source/images/prototype.png","path":"images/prototype.png","modified":0,"renderable":0},{"_id":"source/images/settimeout.png","path":"images/settimeout.png","modified":0,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"d6cc8c2730e89bbee83e01a5a4490f8dbf12c332","modified":1507219435899},{"_id":"themes/apollo/_config.yml","hash":"e32d62a2327fa0916cd9fb1a52161e0a01e84984","modified":1507219435909},{"_id":"source/favicon.ico","hash":"9ff098fa25054b2bfd02874e7c2ba35e11643396","modified":1507219435867},{"_id":"themes/apollo/package.json","hash":"2e81f69d66c01a6bfaacbd8bd7324b370acbed88","modified":1507219435980},{"_id":"source/_posts/17-02-28-2.md","hash":"18f2800a3a15952fd5b6d0b92f0b44a118a46013","modified":1507639146641},{"_id":"themes/apollo/gulpfile.js","hash":"3bf61bca569665944cc61ac0483c9d568a4f58d7","modified":1507219435923},{"_id":"themes/apollo/README.md","hash":"bee45e9d6e41f6b9c01bc38f26bc60ba19c825f7","modified":1507219435906},{"_id":"themes/apollo/LICENSE","hash":"1588511f0c37609ebfb55298b83a77ae5afca870","modified":1507219435903},{"_id":"source/_posts/17-02-28-1.md","hash":"6a4a0f3b143b9c61362bc53357c9c21c45651568","modified":1507219435674},{"_id":"source/_posts/17-03-20-4.md","hash":"70eaa8c4cbf81d244b8153823e4aeeb9631e6e5a","modified":1507219435684},{"_id":"source/_posts/17-03-26-7.md","hash":"2dbd62ba5129297c32985ae74f7538b5ea60fbc0","modified":1507219435706},{"_id":"source/_posts/17-03-21-6.md","hash":"9daa8a06832210a623ad1116670e3801ed73f8eb","modified":1507219435702},{"_id":"source/_posts/17-04-06-11.md","hash":"0566f209c73ee57c86e9c2d56dc3d074150e8693","modified":1507219435728},{"_id":"source/_posts/17-03-21-5.md","hash":"d8f446f1a6d6caa9d0d46905dcbe23e846585a18","modified":1507219435696},{"_id":"source/_posts/17-03-29-9.md","hash":"412289216b91e99ac8ef5da186fc9a8576495520","modified":1507219435721},{"_id":"source/_posts/17-05-11-16.md","hash":"f50d9742265e0384e19f05056e0c50cafee3cc21","modified":1507219435754},{"_id":"source/_posts/17-03-28-8.md","hash":"1b082aa80496a1c7d174d59cf77f5098ad25c1a1","modified":1507219435715},{"_id":"source/_posts/17-04-06-12.md","hash":"a96769ac6b1185d1fb453d1350245afa929cfb60","modified":1507219435736},{"_id":"source/_posts/17-04-10-13.md","hash":"60724dc672b2828b91e832d8ca26fa6de8cdcaaa","modified":1507219435743},{"_id":"source/_posts/17-04-21-14.md","hash":"d88c54f8823c164f81018918a0261c50813ecffb","modified":1507219435748},{"_id":"source/_posts/17-07-15-19.md","hash":"593b32769e510c7c957466e23cafe71abc8d8971","modified":1507219435777},{"_id":"source/_posts/17-07-15-20.md","hash":"cc507febe58ab004fd51fc31132bd880b8bf629a","modified":1507219435784},{"_id":"source/_posts/17-07-07-17.md","hash":"78c02ffd08e4b52eaa1b9c8fd5fc6ff986502853","modified":1507219435761},{"_id":"source/_posts/17-07-08-18.md","hash":"8b6c808086e8a9e21450253d67479505182f624f","modified":1507219435773},{"_id":"source/_posts/17-08-15-21.md","hash":"d075124a8c69f275cea1cff623a44ad552acd7e2","modified":1507219435793},{"_id":"source/_posts/17-08-17-23.md","hash":"e4b139a7e3b32966c41cb48a2600d44d17f33a0c","modified":1507219435801},{"_id":"source/_posts/17-08-16-22.md","hash":"941193abe5079bfe65a44ce25abd2ca37bfe40a0","modified":1507219435798},{"_id":"source/_posts/17-10-02-27.md","hash":"b6349f4b0a3d6a829a61b24d61ca6900242e9bea","modified":1507219435854},{"_id":"source/_posts/17-10-02-28.md","hash":"c7ca2ff921b6363c2971438291c4877edb8b4ca6","modified":1507639953536},{"_id":"source/_posts/17-10-10-29.md","hash":"1bd780ac2778153c1014b9379a33539d32136011","modified":1507950793358},{"_id":"source/_posts/17-10-14-30.md","hash":"a160848828966557410a066062c95d95404206a1","modified":1507963529112},{"_id":"source/_posts/17-08-24-25.md","hash":"72853b7996a51056e143581a76271c2f87607a8b","modified":1507219435838},{"_id":"source/images/canvas-img-1.png","hash":"79357cc2687e1f19ebb11c7f5d3ed032ecaf9ee7","modified":1507219435873},{"_id":"source/images/dom-1.png","hash":"d72db475c0f66b0e504ee8a8d4a4aa81e22e1da6","modified":1507219435874},{"_id":"source/images/avatar.jpg","hash":"b2cd72c603ca58a27504c4744bb78de605adf456","modified":1507219435872},{"_id":"source/images/http-2.png","hash":"a52a2cc5f95862f59c494c4f285098bca833f2f6","modified":1507219435877},{"_id":"source/_posts/17-09-25-26.md","hash":"8029a57a56cf578dec26d7f32ebcb9fc1ddda261","modified":1507219435846},{"_id":"source/images/http.png","hash":"8bd1247192e8b695a72657fec3c44b95092dcdf5","modified":1507219435878},{"_id":"source/images/iconfont-img-2.png","hash":"4f9c43a8d9b5a498dadcd1e7982d8c464b60462b","modified":1507219435882},{"_id":"source/images/iconfont-img-3.png","hash":"379845359d10d9578bff906cc328b00f18683b34","modified":1507219435883},{"_id":"source/images/iconfont-img-4.png","hash":"32eac83fe1450db586186a0e51e83f68db694ca3","modified":1507219435884},{"_id":"source/images/jicheng-2.png","hash":"35606fc921e2a7f254235f72234add1136ca7fb9","modified":1507219435887},{"_id":"source/_posts/17-08-19-24.md","hash":"124c7a490a1c47fdc4d92d7b43f9478ad0ef68e9","modified":1507219435831},{"_id":"source/images/jicheng-1.png","hash":"405f7177225c5f12a289603689ccbb51a428a80f","modified":1507219435886},{"_id":"source/images/osi.png","hash":"0c7e06a9aa0dfd19968cfcf18cddf4ed82ee1da1","modified":1507219435889},{"_id":"source/images/stack&heap-1.png","hash":"4ed0fef087862dff2c7aa0d39e475a89f508e08e","modified":1507219435893},{"_id":"source/images/stack&heap-3.png","hash":"436d00a04593ec48893bf28136880239e0f6da39","modified":1507219435895},{"_id":"source/images/stack&heap-2.png","hash":"e8413df1ec7ce0649f2fa65bce3eafd6502fd2f5","modified":1507219435894},{"_id":"source/images/tcp-ip.png","hash":"04690e3f9af90a60215b9a6a729cf005b5375100","modified":1507219435896},{"_id":"source/images/variable-1.png","hash":"426cb0d62af8bf6fa08b56e56b9fd91de9d5401e","modified":1507219435897},{"_id":"themes/apollo/languages/en.yml","hash":"29b8e211d422cb846af005bd1c21435b45ed6457","modified":1507219435927},{"_id":"themes/apollo/doc/doc-en.md","hash":"123aa670151db03ba5b1a20eaeef2cd3c9bec2b9","modified":1507219435914},{"_id":"themes/apollo/doc/doc-zh.md","hash":"f2ef939e9b39d4d150d613f68a80ca65425d406a","modified":1507219435917},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"05ef430fa5586e919839bad35aba4a9690e8e672","modified":1507219435930},{"_id":"themes/apollo/layout/archive.jade","hash":"a993dddad0213cfc4adbf5d25597b7effac758b0","modified":1507219435934},{"_id":"themes/apollo/layout/index.jade","hash":"fd11746c566d9fb6de1224a2992e3e443a83c139","modified":1507219435937},{"_id":"source/images/dom-2.png","hash":"21fe948dddf19361d725b4bba6f1e0388c4d4f26","modified":1507219435876},{"_id":"source/images/iconfont-img-1.png","hash":"845102fc4a31fb67e15b1395f99b3d7aeec307e2","modified":1507219435881},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1507219435987},{"_id":"source/images/prototype.png","hash":"99ddac4ff9725edf9afb918ba03f7773655391d0","modified":1507219435890},{"_id":"themes/apollo/layout/post.jade","hash":"ada9f5f76819ff76d2c37c893431dfdb808e19b7","modified":1507219435977},{"_id":"source/images/settimeout.png","hash":"3fb1d61e1f94468e8dfcb23b3dd7d5a2dacc38eb","modified":1507219435892},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"a9bd772bb172ba0c54d872d2d3364ff89d762ffb","modified":1507219435954},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"b9a6ca7d8769312cef09c86dbd6828bc04663ca2","modified":1507219435946},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"47712f8bb3d84ff6a2742f923626d568779fc45a","modified":1507219435940},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"185aa2a3f86176b4924adac06ef576b365440c20","modified":1507219435958},{"_id":"themes/apollo/layout/partial/head.jade","hash":"bc1fb13056ea07b3832ed563c680ffe619d44dd9","modified":1507219435961},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"b43b1166601669cd6467bebf343efc1e5a253d64","modified":1507219435968},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"a49c19346dee6886ac8b37a1321ce170e627129a","modified":1507219435965},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"e309aff22fa5823aa65667cf2f189bd05adeb62a","modified":1507219435974},{"_id":"themes/apollo/source/css/apollo.css","hash":"a9072992f3a03003fb0ada9fb2d6d76386f066ad","modified":1507219435986},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1507219435994},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1507219435991},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"bea961e9c85a0eba26b34d5568f165f48fbc9bdb","modified":1507219436029},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"3003361c281d7aa1cfed944ad0da180ac05f2c32","modified":1507219435998},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"4ede69b12919439b4ae404a1e1d498cb8fd2932a","modified":1507219436001},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"8cd2631d46be05a9518f1966bd84e1a8b0270857","modified":1507219436007},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"658eef39c7cf6f730f784751c2e4701e8eb02e0d","modified":1507219436013},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"a6aeb5177f370f984565f7b6f0a18fe27545d34d","modified":1507219436010},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"e87b144a8389eefeab4f50c353eef18c428a761c","modified":1507219436004},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"25f38fb71ade373416af569558d56e4c2e692700","modified":1507219436018},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"85e5dded04b7229ab4345e53473d4e9e9cbdbfb5","modified":1507219436028},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"612b367b0e9a0b9f66d37694ee64ce896c552967","modified":1507219436023},{"_id":"public/atom.xml","hash":"71e81732fd1b6f2f22bdd7e89b7953e1a42c3671","modified":1507963651778},{"_id":"public/sitemap.xml","hash":"b5fb5bbbcbfceff24f418a2a07ffc58e8e5b9201","modified":1507963651783},{"_id":"public/2017/10/02/17-10-02-27/index.html","hash":"2e12c950f53ff81bc6aaf89c17fa06582848aa5d","modified":1507963651787},{"_id":"public/2017/09/25/17-09-25-26/index.html","hash":"fc04233442509164008b48e08a1609f86c023719","modified":1507963651787},{"_id":"public/2017/08/24/17-08-24-25/index.html","hash":"80fae1f616a15a233f23bd57b59c8317fd57d68f","modified":1507963651787},{"_id":"public/2017/08/16/17-08-16-22/index.html","hash":"2b0a006f1e1faa1dc69b48306057b6e743359b53","modified":1507963651787},{"_id":"public/2017/07/15/17-07-15-20/index.html","hash":"0d854f41521846d85b93a5fa49336ea330240d5e","modified":1507963651787},{"_id":"public/2017/07/15/17-07-15-19/index.html","hash":"7a552d1168378a684500bd84a4822c909e5b0e4b","modified":1507963651787},{"_id":"public/2017/07/08/17-07-08-18/index.html","hash":"9f8f48016df361f0ed526c32eb3744dc7d4a9fda","modified":1507963651788},{"_id":"public/2017/07/07/17-07-07-17/index.html","hash":"c0df68e8658d6033a0a90844a52d9336922a2783","modified":1507963651788},{"_id":"public/2017/05/11/17-05-11-16/index.html","hash":"86757b60a97118f4ba538d0a42752373a33107bb","modified":1507963651788},{"_id":"public/2017/04/10/17-04-10-13/index.html","hash":"068ae85de13c908a5fc17620d8eaa49f171b6a24","modified":1507963651788},{"_id":"public/2017/04/06/17-04-06-12/index.html","hash":"87338edcec2d6044ff28764a517e0af2241a9a49","modified":1507963651788},{"_id":"public/2017/04/06/17-04-06-11/index.html","hash":"d5cbced19c58e2b7759a31b3fdf2bb8ab92ea460","modified":1507963651788},{"_id":"public/2017/03/29/17-03-29-9/index.html","hash":"c0381757407f9aec5e3d4b60455adf5c7fd8ac4e","modified":1507963651788},{"_id":"public/2017/03/28/17-03-28-8/index.html","hash":"358585f1805693883707ea403fce4478563da0ba","modified":1507963651788},{"_id":"public/2017/03/26/17-03-26-7/index.html","hash":"22b6c475928a7b47f8b123e3f8d2fa140c1eda92","modified":1507963651788},{"_id":"public/2017/03/21/17-03-21-6/index.html","hash":"bdc441b3cd2e6a3dcf3a04274fc9f27e6e331cbd","modified":1507963651788},{"_id":"public/2017/03/21/17-03-21-5/index.html","hash":"ad22553ca4b1859195712bdbcfe0e84828da5f2d","modified":1507963651788},{"_id":"public/2017/03/20/17-03-20-4/index.html","hash":"7cfa19b9c8890b919cd641cbb97a352acb97655c","modified":1507963651789},{"_id":"public/2017/02/28/17-02-28-2/index.html","hash":"5e9c573e13d68ca137a664c55c37bf66815b07d9","modified":1507963651789},{"_id":"public/2017/02/28/17-02-28-1/index.html","hash":"6f013984b1afde6675c98e60316f1c9de20c3094","modified":1507963651789},{"_id":"public/archives/index.html","hash":"6e60fe1de5cba8872b23ec0a78f4c1403815c0c3","modified":1507963651789},{"_id":"public/index.html","hash":"25724806afe414920a4567522f3ee2fff8645789","modified":1507963651789},{"_id":"public/page/3/index.html","hash":"a7db9ab8f24a651a9ff561ab1a77d9716ecb70f1","modified":1507963651789},{"_id":"public/page/2/index.html","hash":"23a868ae1e6326e1790f4a038aced4c17d269d57","modified":1507963651789},{"_id":"public/2017/10/10/17-10-10-29/index.html","hash":"a4375b820561c1d0110e494ebcf429f0c6257b62","modified":1507963651789},{"_id":"public/2017/10/02/17-10-02-28/index.html","hash":"c48c9ea60d3b27d13def7902683c2dcee7b498c6","modified":1507963651789},{"_id":"public/2017/08/19/17-08-19-24/index.html","hash":"dad5b437efdd45a7d82883fa3fdb6a147c9d6ac4","modified":1507963651789},{"_id":"public/2017/08/17/17-08-17-23/index.html","hash":"4022a0253b148d5a810bcebace31b6de5d4e209e","modified":1507963651790},{"_id":"public/2017/08/15/17-08-15-21/index.html","hash":"bc82b045ec1b0dcc54cfd405b185d02afb60f680","modified":1507963651790},{"_id":"public/2017/04/21/17-04-21-14/index.html","hash":"b3baf7f752f30b73d2ec7f9df797c311acfc5c4e","modified":1507963651790},{"_id":"public/2017/10/14/17-10-14-30/index.html","hash":"e132c171b13849fd737fe068411d121412db8e44","modified":1507963651794}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Sublime Text3前端插件分享","date":"2017-02-28T08:05:18.000Z","_content":"\n自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利\n\n<!--more-->\n\n***\n* **Emmet:**\n快速编写HTML+CSS代码，快捷键**ctrl+E**\n[关于如何速写的教程](http://www.iteye.com/news/27580)\n* **JSFormat:**\nJavascript的代码格式化插件\n* **Less:**\nLESS高亮插件\n* **All Autocomplete:**\n搜索所有打开的文件来寻找匹配的提示词\n* **AutoFileName:**\n自动检索并补齐文件路径\n* **CSScomb:**\n使用指定排序方法对CSS的属性进行排序，快捷键**ctrl+alt+C**\n虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法\n* **Doc​Blockr:**\n生成优美注释,输入`/*`、`/**`然后回车\n* **ConvertToUTF8:**\n通过本插件，您可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等\n* **Nodejs:**\nnode代码提示\n* **Trailing spaces:**\n检测并一键去除代码中多余的空格,一键删除多余空格：CTRL+SHITF+T（需配置）\n* **FileDiffs:**\n比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。可配置为显示差别在外部比较工具，精确到行\n* **HTML-CSS-JS Prettify:**\n美化代码格式，需要安装node.js才能使用，快捷键**ctrl+alt+H**，可以自动对齐\n* **ColorHighlighter:**\n可以显示颜色代码的颜色，看上去一目了然\n* **ChineseLocalization:**\n汉化插件\n* **BracketHighlighter:**\n括号以及标签层级显示\n* **Sidebarenhancements:**\n扩展鼠标右键菜单，可以直接open with浏览器，超方便\n* **SublimeCodeIntel:**\n可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上\n打开*Package Settings > SublimeCodeIntel > Key Bindings - User*,输入代码\n\n```python\n[\n\t{\n\t\t\"keys\": [\";\"], \"command\": \"run_macro_file\",\n\t  \t\"args\": {\"file\": \"Packages/User/unAutoSemiColon.sublime-macro\"}\n\t}\n]\n```\n然后打开 *Preferences > Browser Package > User*，保存文件名为*unAutoSemiColon.sublime-macro*\n```python\n[\n    {\n        \"args\":\n        {\n            \"characters\": \";\"\n        },\n        \"command\": \"insert\"\n    }\n]\n```\n之后打分号再也不会出现提示啦！！\n* **SublimeTmpl:**\n可以快速创建代码模板\n**ctrl+shift+H** HTML模板\n**ctrl+shift+C** CSS模板\n**ctrl+shift+J** Javascript模板\n**ctrl+shift+P** php模板\n*  **Colorsublime:**\n更换主题的插件，含有很多主题配色方案，偶尔转换一下心情\n***\n","source":"_posts/17-02-28-2.md","raw":"---\ntitle: Sublime Text3前端插件分享\ndate: 2017-02-28 16:05:18\n---\n\n自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利\n\n<!--more-->\n\n***\n* **Emmet:**\n快速编写HTML+CSS代码，快捷键**ctrl+E**\n[关于如何速写的教程](http://www.iteye.com/news/27580)\n* **JSFormat:**\nJavascript的代码格式化插件\n* **Less:**\nLESS高亮插件\n* **All Autocomplete:**\n搜索所有打开的文件来寻找匹配的提示词\n* **AutoFileName:**\n自动检索并补齐文件路径\n* **CSScomb:**\n使用指定排序方法对CSS的属性进行排序，快捷键**ctrl+alt+C**\n虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法\n* **Doc​Blockr:**\n生成优美注释,输入`/*`、`/**`然后回车\n* **ConvertToUTF8:**\n通过本插件，您可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等\n* **Nodejs:**\nnode代码提示\n* **Trailing spaces:**\n检测并一键去除代码中多余的空格,一键删除多余空格：CTRL+SHITF+T（需配置）\n* **FileDiffs:**\n比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。可配置为显示差别在外部比较工具，精确到行\n* **HTML-CSS-JS Prettify:**\n美化代码格式，需要安装node.js才能使用，快捷键**ctrl+alt+H**，可以自动对齐\n* **ColorHighlighter:**\n可以显示颜色代码的颜色，看上去一目了然\n* **ChineseLocalization:**\n汉化插件\n* **BracketHighlighter:**\n括号以及标签层级显示\n* **Sidebarenhancements:**\n扩展鼠标右键菜单，可以直接open with浏览器，超方便\n* **SublimeCodeIntel:**\n可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上\n打开*Package Settings > SublimeCodeIntel > Key Bindings - User*,输入代码\n\n```python\n[\n\t{\n\t\t\"keys\": [\";\"], \"command\": \"run_macro_file\",\n\t  \t\"args\": {\"file\": \"Packages/User/unAutoSemiColon.sublime-macro\"}\n\t}\n]\n```\n然后打开 *Preferences > Browser Package > User*，保存文件名为*unAutoSemiColon.sublime-macro*\n```python\n[\n    {\n        \"args\":\n        {\n            \"characters\": \";\"\n        },\n        \"command\": \"insert\"\n    }\n]\n```\n之后打分号再也不会出现提示啦！！\n* **SublimeTmpl:**\n可以快速创建代码模板\n**ctrl+shift+H** HTML模板\n**ctrl+shift+C** CSS模板\n**ctrl+shift+J** Javascript模板\n**ctrl+shift+P** php模板\n*  **Colorsublime:**\n更换主题的插件，含有很多主题配色方案，偶尔转换一下心情\n***\n","slug":"17-02-28-2","published":1,"updated":"2017-10-10T12:39:06.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2s60000bgujn1ohz7vp","content":"<p>自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利</p>\n<a id=\"more\"></a>\n<hr>\n<ul>\n<li><strong>Emmet:</strong><br>快速编写HTML+CSS代码，快捷键<strong>ctrl+E</strong><br><a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"external\">关于如何速写的教程</a></li>\n<li><strong>JSFormat:</strong><br>Javascript的代码格式化插件</li>\n<li><strong>Less:</strong><br>LESS高亮插件</li>\n<li><strong>All Autocomplete:</strong><br>搜索所有打开的文件来寻找匹配的提示词</li>\n<li><strong>AutoFileName:</strong><br>自动检索并补齐文件路径</li>\n<li><strong>CSScomb:</strong><br>使用指定排序方法对CSS的属性进行排序，快捷键<strong>ctrl+alt+C</strong><br>虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法</li>\n<li><strong>Doc​Blockr:</strong><br>生成优美注释,输入<code>/*</code>、<code>/**</code>然后回车</li>\n<li><strong>ConvertToUTF8:</strong><br>通过本插件，您可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等</li>\n<li><strong>Nodejs:</strong><br>node代码提示</li>\n<li><strong>Trailing spaces:</strong><br>检测并一键去除代码中多余的空格,一键删除多余空格：CTRL+SHITF+T（需配置）</li>\n<li><strong>FileDiffs:</strong><br>比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。可配置为显示差别在外部比较工具，精确到行</li>\n<li><strong>HTML-CSS-JS Prettify:</strong><br>美化代码格式，需要安装node.js才能使用，快捷键<strong>ctrl+alt+H</strong>，可以自动对齐</li>\n<li><strong>ColorHighlighter:</strong><br>可以显示颜色代码的颜色，看上去一目了然</li>\n<li><strong>ChineseLocalization:</strong><br>汉化插件</li>\n<li><strong>BracketHighlighter:</strong><br>括号以及标签层级显示</li>\n<li><strong>Sidebarenhancements:</strong><br>扩展鼠标右键菜单，可以直接open with浏览器，超方便</li>\n<li><strong>SublimeCodeIntel:</strong><br>可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上<br>打开<em>Package Settings &gt; SublimeCodeIntel &gt; Key Bindings - User</em>,输入代码</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"keys\"</span>: [<span class=\"string\">\";\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"run_macro_file\"</span>,</div><div class=\"line\">\t  \t<span class=\"string\">\"args\"</span>: &#123;<span class=\"string\">\"file\"</span>: <span class=\"string\">\"Packages/User/unAutoSemiColon.sublime-macro\"</span>&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>然后打开 <em>Preferences &gt; Browser Package &gt; User</em>，保存文件名为<em>unAutoSemiColon.sublime-macro</em><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"args\"</span>:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"characters\"</span>: <span class=\"string\">\";\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"command\"</span>: <span class=\"string\">\"insert\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>之后打分号再也不会出现提示啦！！</p>\n<ul>\n<li><strong>SublimeTmpl:</strong><br>可以快速创建代码模板<br><strong>ctrl+shift+H</strong> HTML模板<br><strong>ctrl+shift+C</strong> CSS模板<br><strong>ctrl+shift+J</strong> Javascript模板<br><strong>ctrl+shift+P</strong> php模板</li>\n<li><strong>Colorsublime:</strong><br>更换主题的插件，含有很多主题配色方案，偶尔转换一下心情</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<p>自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利</p>","more":"<hr>\n<ul>\n<li><strong>Emmet:</strong><br>快速编写HTML+CSS代码，快捷键<strong>ctrl+E</strong><br><a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"external\">关于如何速写的教程</a></li>\n<li><strong>JSFormat:</strong><br>Javascript的代码格式化插件</li>\n<li><strong>Less:</strong><br>LESS高亮插件</li>\n<li><strong>All Autocomplete:</strong><br>搜索所有打开的文件来寻找匹配的提示词</li>\n<li><strong>AutoFileName:</strong><br>自动检索并补齐文件路径</li>\n<li><strong>CSScomb:</strong><br>使用指定排序方法对CSS的属性进行排序，快捷键<strong>ctrl+alt+C</strong><br>虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法</li>\n<li><strong>Doc​Blockr:</strong><br>生成优美注释,输入<code>/*</code>、<code>/**</code>然后回车</li>\n<li><strong>ConvertToUTF8:</strong><br>通过本插件，您可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等</li>\n<li><strong>Nodejs:</strong><br>node代码提示</li>\n<li><strong>Trailing spaces:</strong><br>检测并一键去除代码中多余的空格,一键删除多余空格：CTRL+SHITF+T（需配置）</li>\n<li><strong>FileDiffs:</strong><br>比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。可配置为显示差别在外部比较工具，精确到行</li>\n<li><strong>HTML-CSS-JS Prettify:</strong><br>美化代码格式，需要安装node.js才能使用，快捷键<strong>ctrl+alt+H</strong>，可以自动对齐</li>\n<li><strong>ColorHighlighter:</strong><br>可以显示颜色代码的颜色，看上去一目了然</li>\n<li><strong>ChineseLocalization:</strong><br>汉化插件</li>\n<li><strong>BracketHighlighter:</strong><br>括号以及标签层级显示</li>\n<li><strong>Sidebarenhancements:</strong><br>扩展鼠标右键菜单，可以直接open with浏览器，超方便</li>\n<li><strong>SublimeCodeIntel:</strong><br>可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上<br>打开<em>Package Settings &gt; SublimeCodeIntel &gt; Key Bindings - User</em>,输入代码</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"keys\"</span>: [<span class=\"string\">\";\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"run_macro_file\"</span>,</div><div class=\"line\">\t  \t<span class=\"string\">\"args\"</span>: &#123;<span class=\"string\">\"file\"</span>: <span class=\"string\">\"Packages/User/unAutoSemiColon.sublime-macro\"</span>&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>然后打开 <em>Preferences &gt; Browser Package &gt; User</em>，保存文件名为<em>unAutoSemiColon.sublime-macro</em><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"args\"</span>:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"characters\"</span>: <span class=\"string\">\";\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"command\"</span>: <span class=\"string\">\"insert\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>之后打分号再也不会出现提示啦！！</p>\n<ul>\n<li><strong>SublimeTmpl:</strong><br>可以快速创建代码模板<br><strong>ctrl+shift+H</strong> HTML模板<br><strong>ctrl+shift+C</strong> CSS模板<br><strong>ctrl+shift+J</strong> Javascript模板<br><strong>ctrl+shift+P</strong> php模板</li>\n<li><strong>Colorsublime:</strong><br>更换主题的插件，含有很多主题配色方案，偶尔转换一下心情</li>\n</ul>\n<hr>"},{"title":"这磨人的小妖精","date":"2017-02-27T18:17:03.000Z","_content":"\n终于！把！这个！磨人的！小妖精！建好了！！\n超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=\n大概是我太蠢了才会弄这么久哦，好气哦\n好了我要努力读书去了\n\n<!--more-->\n","source":"_posts/17-02-28-1.md","raw":"---\ntitle: 这磨人的小妖精\ndate: 2017-02-28 02:17:03\n---\n\n终于！把！这个！磨人的！小妖精！建好了！！\n超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=\n大概是我太蠢了才会弄这么久哦，好气哦\n好了我要努力读书去了\n\n<!--more-->\n","slug":"17-02-28-1","published":1,"updated":"2017-10-05T16:03:55.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2s90001bguj1nv3c16d","content":"<p>终于！把！这个！磨人的！小妖精！建好了！！<br>超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=<br>大概是我太蠢了才会弄这么久哦，好气哦<br>好了我要努力读书去了</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>终于！把！这个！磨人的！小妖精！建好了！！<br>超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=<br>大概是我太蠢了才会弄这么久哦，好气哦<br>好了我要努力读书去了</p>","more":""},{"title":"iconfont使用方法","date":"2017-03-26T01:12:56.000Z","_content":"实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","source":"_posts/17-03-26-7.md","raw":"---\ntitle: iconfont使用方法\ndate: 2017-03-26 09:12:56\n---\n实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","slug":"17-03-26-7","published":1,"updated":"2017-10-05T16:03:55.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sb0002bguj21040jey","content":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt=\"\"></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt=\"\"></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</div><div class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </div><div class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt=\"\"><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>\n","site":{"data":{}},"excerpt":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt=\"\"></p>","more":"<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt=\"\"></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt=\"\"></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</div><div class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </div><div class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt=\"\"><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>"},{"title":"关于HTTP请求小记","date":"2017-03-20T07:31:38.000Z","_content":"* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","source":"_posts/17-03-20-4.md","raw":"---\ntitle: 关于HTTP请求小记\ndate: 2017-03-20 15:31:38\n---\n* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","slug":"17-03-20-4","published":1,"updated":"2017-10-05T16:03:55.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2se0003bgujvochv1yd","content":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /login.php HTTP/1.1 //请求地址</div><div class=\"line\"></div><div class=\"line\">//请求头</div><div class=\"line\">Host:localhost</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Accept:text/javascript,application/javascript,application/ecmascript,</div><div class=\"line\">application/x-ecmascript,*/*;</div><div class=\"line\">q=0.01</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</div><div class=\"line\"></div><div class=\"line\">//请求体</div><div class=\"line\">username=admin&amp;password=123456</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</div><div class=\"line\">Server:Apache</div><div class=\"line\">Content-Encoding:gzip</div><div class=\"line\">Content-Length:7112</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Content-Type:application/javascript</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /login.php HTTP/1.1 //请求地址</div><div class=\"line\"></div><div class=\"line\">//请求头</div><div class=\"line\">Host:localhost</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Accept:text/javascript,application/javascript,application/ecmascript,</div><div class=\"line\">application/x-ecmascript,*/*;</div><div class=\"line\">q=0.01</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</div><div class=\"line\"></div><div class=\"line\">//请求体</div><div class=\"line\">username=admin&amp;password=123456</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</div><div class=\"line\">Server:Apache</div><div class=\"line\">Content-Encoding:gzip</div><div class=\"line\">Content-Length:7112</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Content-Type:application/javascript</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>"},{"title":"JSON学习笔记","date":"2017-03-21T10:16:43.000Z","_content":"> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","source":"_posts/17-03-21-6.md","raw":"---\ntitle: JSON学习笔记\ndate: 2017-03-21 18:16:43\n---\n> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","slug":"17-03-21-6","published":1,"updated":"2017-10-05T16:03:55.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sg0004bgujebe13ne0","content":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</div><div class=\"line\"><span class=\"comment\">//解析完毕</span></div><div class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</div><div class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>","more":"<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</div><div class=\"line\"><span class=\"comment\">//解析完毕</span></div><div class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</div><div class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"title":"从零开始的backbone.js（三）","date":"2017-04-06T05:47:54.000Z","_content":"## Backbone.Collection（集合）\n* model是现实中物体的抽象，而collection则是model对象的一个有序的集合\n\n<!--more-->\n\n```javascript\nvar Book = Backbone.Model.extend({\n\tdefaults:{\n\t\ttitle:\"default\"\n\t},\n\tinitialize:function(){\n\t\talert(this.title);\n\t}\n});\n\nvar BookShelf = Backbone.Collection.extend({\n\t//model Book的集合\n\tmodel:Book;\n});\n\n//创建三个Book model\nvar book1 = new Book({title:\"book1\"});\nvar book2 = new Book({title:\"book2\"});\nvar book3 = new Book({title:\"book3\"});\n//创建一个bookShelf数组集合\nvar bookShelf = new BookShelf([book1,book2,book3]);\n//或者，可以使用add将book1,book2,book3加入到集合中\n/*\nbookShelf.add(book1);\nbookShelf.add(book2);\nbookShelf.add(book3);\n*/\n//还可以对里面的model进行其他操作\nbookShelf.remove(book3);\n//可以用each对其进行遍历\nbookShelf.each(function(book){\n\talert(book.get(\"title\"));\n});\n//相当于ajax的操作\nbookShelf.url = '/books/'\nbookShelf.fetch({\n\tsuccess:function(){\n\t\t//...\n\t},\n\terror:function(){\n\t\t//...\n\t}\n});\n//create方法，将model对象（json数据）POST到对应的url上\nvar NewBooks = Backbone.Collection.extend({\n\tmodel:Book,\n\turl:'/books/'\n});\nvar books =  new NewBooks;\nvar onebook = books.create({\n\ttitle: \"I'm coming\"\n});\n```","source":"_posts/17-04-06-11.md","raw":"---\ntitle: 从零开始的backbone.js（三）\ndate: 2017-04-06 13:47:54\n---\n## Backbone.Collection（集合）\n* model是现实中物体的抽象，而collection则是model对象的一个有序的集合\n\n<!--more-->\n\n```javascript\nvar Book = Backbone.Model.extend({\n\tdefaults:{\n\t\ttitle:\"default\"\n\t},\n\tinitialize:function(){\n\t\talert(this.title);\n\t}\n});\n\nvar BookShelf = Backbone.Collection.extend({\n\t//model Book的集合\n\tmodel:Book;\n});\n\n//创建三个Book model\nvar book1 = new Book({title:\"book1\"});\nvar book2 = new Book({title:\"book2\"});\nvar book3 = new Book({title:\"book3\"});\n//创建一个bookShelf数组集合\nvar bookShelf = new BookShelf([book1,book2,book3]);\n//或者，可以使用add将book1,book2,book3加入到集合中\n/*\nbookShelf.add(book1);\nbookShelf.add(book2);\nbookShelf.add(book3);\n*/\n//还可以对里面的model进行其他操作\nbookShelf.remove(book3);\n//可以用each对其进行遍历\nbookShelf.each(function(book){\n\talert(book.get(\"title\"));\n});\n//相当于ajax的操作\nbookShelf.url = '/books/'\nbookShelf.fetch({\n\tsuccess:function(){\n\t\t//...\n\t},\n\terror:function(){\n\t\t//...\n\t}\n});\n//create方法，将model对象（json数据）POST到对应的url上\nvar NewBooks = Backbone.Collection.extend({\n\tmodel:Book,\n\turl:'/books/'\n});\nvar books =  new NewBooks;\nvar onebook = books.create({\n\ttitle: \"I'm coming\"\n});\n```","slug":"17-04-06-11","published":1,"updated":"2017-10-05T16:03:55.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sh0005bgujdsj3lyr6","content":"<h2 id=\"Backbone-Collection（集合）\"><a href=\"#Backbone-Collection（集合）\" class=\"headerlink\" title=\"Backbone.Collection（集合）\"></a>Backbone.Collection（集合）</h2><ul>\n<li>model是现实中物体的抽象，而collection则是model对象的一个有序的集合</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">defaults</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">title</span>:<span class=\"string\">\"default\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.title);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BookShelf = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//model Book的集合</span></div><div class=\"line\">\tmodel:Book;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建三个Book model</span></div><div class=\"line\"><span class=\"keyword\">var</span> book1 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book1\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book2\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book3 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book3\"</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//创建一个bookShelf数组集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> bookShelf = <span class=\"keyword\">new</span> BookShelf([book1,book2,book3]);</div><div class=\"line\"><span class=\"comment\">//或者，可以使用add将book1,book2,book3加入到集合中</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">bookShelf.add(book1);</div><div class=\"line\">bookShelf.add(book2);</div><div class=\"line\">bookShelf.add(book3);</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"comment\">//还可以对里面的model进行其他操作</span></div><div class=\"line\">bookShelf.remove(book3);</div><div class=\"line\"><span class=\"comment\">//可以用each对其进行遍历</span></div><div class=\"line\">bookShelf.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>)</span>&#123;</div><div class=\"line\">\talert(book.get(<span class=\"string\">\"title\"</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//相当于ajax的操作</span></div><div class=\"line\">bookShelf.url = <span class=\"string\">'/books/'</span></div><div class=\"line\">bookShelf.fetch(&#123;</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//create方法，将model对象（json数据）POST到对应的url上</span></div><div class=\"line\"><span class=\"keyword\">var</span> NewBooks = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">model</span>:Book,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">'/books/'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> books =  <span class=\"keyword\">new</span> NewBooks;</div><div class=\"line\"><span class=\"keyword\">var</span> onebook = books.create(&#123;</div><div class=\"line\">\t<span class=\"attr\">title</span>: <span class=\"string\">\"I'm coming\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Backbone-Collection（集合）\"><a href=\"#Backbone-Collection（集合）\" class=\"headerlink\" title=\"Backbone.Collection（集合）\"></a>Backbone.Collection（集合）</h2><ul>\n<li>model是现实中物体的抽象，而collection则是model对象的一个有序的集合</li>\n</ul>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">defaults</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">title</span>:<span class=\"string\">\"default\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.title);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BookShelf = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//model Book的集合</span></div><div class=\"line\">\tmodel:Book;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建三个Book model</span></div><div class=\"line\"><span class=\"keyword\">var</span> book1 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book1\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book2\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book3 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book3\"</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//创建一个bookShelf数组集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> bookShelf = <span class=\"keyword\">new</span> BookShelf([book1,book2,book3]);</div><div class=\"line\"><span class=\"comment\">//或者，可以使用add将book1,book2,book3加入到集合中</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">bookShelf.add(book1);</div><div class=\"line\">bookShelf.add(book2);</div><div class=\"line\">bookShelf.add(book3);</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"comment\">//还可以对里面的model进行其他操作</span></div><div class=\"line\">bookShelf.remove(book3);</div><div class=\"line\"><span class=\"comment\">//可以用each对其进行遍历</span></div><div class=\"line\">bookShelf.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>)</span>&#123;</div><div class=\"line\">\talert(book.get(<span class=\"string\">\"title\"</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//相当于ajax的操作</span></div><div class=\"line\">bookShelf.url = <span class=\"string\">'/books/'</span></div><div class=\"line\">bookShelf.fetch(&#123;</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//create方法，将model对象（json数据）POST到对应的url上</span></div><div class=\"line\"><span class=\"keyword\">var</span> NewBooks = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">model</span>:Book,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">'/books/'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> books =  <span class=\"keyword\">new</span> NewBooks;</div><div class=\"line\"><span class=\"keyword\">var</span> onebook = books.create(&#123;</div><div class=\"line\">\t<span class=\"attr\">title</span>: <span class=\"string\">\"I'm coming\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"Vue.js学习笔记（一）","date":"2017-05-11T13:25:58.000Z","_content":"> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API\n\n<!--more-->\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- 默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`\n```js\n//import表示导入组件\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n``` ","source":"_posts/17-05-11-16.md","raw":"---\ntitle: Vue.js学习笔记（一）\ndate: 2017-05-11 21:25:58\n---\n> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API\n\n<!--more-->\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- 默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`\n```js\n//import表示导入组件\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n``` ","slug":"17-05-11-16","published":1,"updated":"2017-10-05T16:03:55.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2si0006bgujyuwya37y","content":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装vue-cli</span></div><div class=\"line\">$ cnpm install -g vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖</span></div><div class=\"line\">$ cd my-project</div><div class=\"line\">$ cnmp install</div><div class=\"line\"><span class=\"comment\"># 开启项目</span></div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 默认调用src里的main.js --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code></p>\n<pre><code class=\"js\"><span class=\"comment\">//import表示导入组件</span>\n<span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span>\n<span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span>\n<span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span>\n\n\nVue.config.productionTip = <span class=\"literal\">false</span>\n\n<span class=\"comment\">/* eslint-disable no-new */</span>\n<span class=\"keyword\">new</span> Vue({\n  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,\n  router,\n  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;App/&gt;'</span>,\n  <span class=\"attr\">components</span>: { App }  <span class=\"comment\">//注册一个app</span>\n})\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API</p>\n</blockquote>","more":"<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装vue-cli</span></div><div class=\"line\">$ cnpm install -g vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖</span></div><div class=\"line\">$ cd my-project</div><div class=\"line\">$ cnmp install</div><div class=\"line\"><span class=\"comment\"># 开启项目</span></div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 默认调用src里的main.js --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code></p>\n<pre><code class=\"js\"><span class=\"comment\">//import表示导入组件</span>\n<span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span>\n<span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span>\n<span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span>\n\n\nVue.config.productionTip = <span class=\"literal\">false</span>\n\n<span class=\"comment\">/* eslint-disable no-new */</span>\n<span class=\"keyword\">new</span> Vue({\n  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,\n  router,\n  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;App/&gt;'</span>,\n  <span class=\"attr\">components</span>: { App }  <span class=\"comment\">//注册一个app</span>\n})\n</code></pre>"},{"title":"从零开始的backbone.js（二）","date":"2017-03-29T08:06:16.000Z","_content":"## Backbone.View（视图）\n* view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。\n* 相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。\n\n<!--more-->\n\n```javascript\nvar searchView = Backbone.View.extend({\n\t//引用的DOM元素（没有指定也会指向一个空的div）\n\tel:\"#search_container\",\n\t//绑定事件\n\tevents:{\n\t\t\"click input[type=button]\":\"doSearch\"\n\t\t//当点击input时，会调用doSearch\n\t},\n\t//初始化函数（一开始就会调用）\n\tinitialize:function() {\n\t\t//调用render渲染页面\n\t\tthis.render({search_label:\"搜索按钮\"});\n\t},\n\t//渲染页面函数\n\trender:function(context) {\n\t\t//html模板\n\t\tvar template = _.template($(\"#search_template\").html());\n\t\t$(this.el).html(template(context));\n\t},\n\t//doSearch函数定义\n\tdoSearch:function(){\n\t\talert(\"search for\" + $(\"#search_input\").val());\n\t}\n});\n//实例化\nvar SearchView = new searchView();\n```\n","source":"_posts/17-03-29-9.md","raw":"---\ntitle: 从零开始的backbone.js（二）\ndate: 2017-03-29 16:06:16\n---\n## Backbone.View（视图）\n* view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。\n* 相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。\n\n<!--more-->\n\n```javascript\nvar searchView = Backbone.View.extend({\n\t//引用的DOM元素（没有指定也会指向一个空的div）\n\tel:\"#search_container\",\n\t//绑定事件\n\tevents:{\n\t\t\"click input[type=button]\":\"doSearch\"\n\t\t//当点击input时，会调用doSearch\n\t},\n\t//初始化函数（一开始就会调用）\n\tinitialize:function() {\n\t\t//调用render渲染页面\n\t\tthis.render({search_label:\"搜索按钮\"});\n\t},\n\t//渲染页面函数\n\trender:function(context) {\n\t\t//html模板\n\t\tvar template = _.template($(\"#search_template\").html());\n\t\t$(this.el).html(template(context));\n\t},\n\t//doSearch函数定义\n\tdoSearch:function(){\n\t\talert(\"search for\" + $(\"#search_input\").val());\n\t}\n});\n//实例化\nvar SearchView = new searchView();\n```\n","slug":"17-03-29-9","published":1,"updated":"2017-10-05T16:03:55.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sj0007bguj8es7l8rr","content":"<h2 id=\"Backbone-View（视图）\"><a href=\"#Backbone-View（视图）\" class=\"headerlink\" title=\"Backbone.View（视图）\"></a>Backbone.View（视图）</h2><ul>\n<li>view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。</li>\n<li>相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> searchView = Backbone.View.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//引用的DOM元素（没有指定也会指向一个空的div）</span></div><div class=\"line\">\tel:<span class=\"string\">\"#search_container\"</span>,</div><div class=\"line\">\t<span class=\"comment\">//绑定事件</span></div><div class=\"line\">\tevents:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"click input[type=button]\"</span>:<span class=\"string\">\"doSearch\"</span></div><div class=\"line\">\t\t<span class=\"comment\">//当点击input时，会调用doSearch</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//初始化函数（一开始就会调用）</span></div><div class=\"line\">\tinitialize:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//调用render渲染页面</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.render(&#123;<span class=\"attr\">search_label</span>:<span class=\"string\">\"搜索按钮\"</span>&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//渲染页面函数</span></div><div class=\"line\">\trender:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//html模板</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> template = _.template($(<span class=\"string\">\"#search_template\"</span>).html());</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.el).html(template(context));</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//doSearch函数定义</span></div><div class=\"line\">\tdoSearch:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"search for\"</span> + $(<span class=\"string\">\"#search_input\"</span>).val());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> SearchView = <span class=\"keyword\">new</span> searchView();</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Backbone-View（视图）\"><a href=\"#Backbone-View（视图）\" class=\"headerlink\" title=\"Backbone.View（视图）\"></a>Backbone.View（视图）</h2><ul>\n<li>view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。</li>\n<li>相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。</li>\n</ul>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> searchView = Backbone.View.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//引用的DOM元素（没有指定也会指向一个空的div）</span></div><div class=\"line\">\tel:<span class=\"string\">\"#search_container\"</span>,</div><div class=\"line\">\t<span class=\"comment\">//绑定事件</span></div><div class=\"line\">\tevents:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"click input[type=button]\"</span>:<span class=\"string\">\"doSearch\"</span></div><div class=\"line\">\t\t<span class=\"comment\">//当点击input时，会调用doSearch</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//初始化函数（一开始就会调用）</span></div><div class=\"line\">\tinitialize:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//调用render渲染页面</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.render(&#123;<span class=\"attr\">search_label</span>:<span class=\"string\">\"搜索按钮\"</span>&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//渲染页面函数</span></div><div class=\"line\">\trender:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//html模板</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> template = _.template($(<span class=\"string\">\"#search_template\"</span>).html());</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.el).html(template(context));</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//doSearch函数定义</span></div><div class=\"line\">\tdoSearch:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"search for\"</span> + $(<span class=\"string\">\"#search_input\"</span>).val());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> SearchView = <span class=\"keyword\">new</span> searchView();</div></pre></td></tr></table></figure>"},{"title":"AJAX学习笔记","date":"2017-03-21T08:21:19.000Z","_content":"> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","source":"_posts/17-03-21-5.md","raw":"---\ntitle: AJAX学习笔记\ndate: 2017-03-21 16:21:19\n---\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","slug":"17-03-21-5","published":1,"updated":"2017-10-05T16:03:55.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sk0008bgujzlid61gb","content":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建信息</span></div><div class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></div><div class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"number\">123</span></div><div class=\"line\">\t\tnumber:<span class=\"number\">123</span></div><div class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></div><div class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">在www.aaa.com中</div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\"> \talert(json[<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> 在www.bbb.com中</div><div class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></div><div class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>","more":"<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建信息</span></div><div class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></div><div class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"number\">123</span></div><div class=\"line\">\t\tnumber:<span class=\"number\">123</span></div><div class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></div><div class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">在www.aaa.com中</div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\"> \talert(json[<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> 在www.bbb.com中</div><div class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></div><div class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>"},{"title":"前端模块化","date":"2017-04-06T06:46:01.000Z","_content":"## AMD\n\n* AMD 即`Asynchronous Module Definition`，中文名是**异步模块定义**的意思。它是一个在浏览器端模块化开发的规范。\n\n<!--more-->\n\n* 应用：**RequireJS**\n  解决的主要问题：\n\t* 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\t* js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n* `define([id], [dependencies], factory);`\n\t* id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\t* dependencies：是一个当前模块依赖的模块名称数组\n\t* factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n* `require([dependencies], function(){});`\n\t* dependencies：一个数组，表示所依赖的模块\n\t* function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\t* `require()`函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n* 使用例子：\n```javascript\n// 定义模块 myModule.js\ndefine(['dependency'], function(){\n    var name = 'Byron';\n    function printName(){\n        console.log(name);\n    }\n    return {\n        printName: printName\n    };\n});\n\n// 加载模块\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n## CMD\n\n* CMD 即`Common Module Definition`通用模块定义\n* 应用：**SeaJS**\n  SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n* `define([id],[deps],factory)`\n\t* 一个文件一个模块，所以经常就用文件名作为模块id\n\t* CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\t* factory有三个参数：`function(require, exports, module)`\n* `require(id)`\n\t* require 是一个方法，接受**模块标识**作为唯一参数，用来获取其他模块提供的接口\n* `exports`\n\t* exports 是一个对象，用来向外提供模块接口\n* `module`\n\t* module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n* 使用例子：\n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n\n});\n```\n\n## AMD与CMD的区别\n\n> AMD 是提前执行，CMD 是延迟执行\n> 在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require","source":"_posts/17-04-06-12.md","raw":"---\ntitle: 前端模块化\ndate: 2017-04-06 14:46:01\n---\n## AMD\n\n* AMD 即`Asynchronous Module Definition`，中文名是**异步模块定义**的意思。它是一个在浏览器端模块化开发的规范。\n\n<!--more-->\n\n* 应用：**RequireJS**\n  解决的主要问题：\n\t* 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\t* js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n* `define([id], [dependencies], factory);`\n\t* id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\t* dependencies：是一个当前模块依赖的模块名称数组\n\t* factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n* `require([dependencies], function(){});`\n\t* dependencies：一个数组，表示所依赖的模块\n\t* function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\t* `require()`函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n* 使用例子：\n```javascript\n// 定义模块 myModule.js\ndefine(['dependency'], function(){\n    var name = 'Byron';\n    function printName(){\n        console.log(name);\n    }\n    return {\n        printName: printName\n    };\n});\n\n// 加载模块\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n## CMD\n\n* CMD 即`Common Module Definition`通用模块定义\n* 应用：**SeaJS**\n  SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n* `define([id],[deps],factory)`\n\t* 一个文件一个模块，所以经常就用文件名作为模块id\n\t* CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\t* factory有三个参数：`function(require, exports, module)`\n* `require(id)`\n\t* require 是一个方法，接受**模块标识**作为唯一参数，用来获取其他模块提供的接口\n* `exports`\n\t* exports 是一个对象，用来向外提供模块接口\n* `module`\n\t* module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n* 使用例子：\n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n\n});\n```\n\n## AMD与CMD的区别\n\n> AMD 是提前执行，CMD 是延迟执行\n> 在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require","slug":"17-04-06-12","published":1,"updated":"2017-10-05T16:03:55.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sl0009bguj21i27bgr","content":"<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><ul>\n<li>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>应用：<strong>RequireJS</strong><br>解决的主要问题：<ul>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ul>\n</li>\n<li><code>define([id], [dependencies], factory);</code><ul>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ul>\n</li>\n<li><code>require([dependencies], function(){});</code><ul>\n<li>dependencies：一个数组，表示所依赖的模块</li>\n<li>function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n<li><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块 myModule.js</span></div><div class=\"line\">define([<span class=\"string\">'dependency'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Byron'</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">printName</span>: printName</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'myModule'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\">　 my.printName();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><ul>\n<li>CMD 即<code>Common Module Definition</code>通用模块定义</li>\n<li>应用：<strong>SeaJS</strong><br>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</li>\n<li><code>define([id],[deps],factory)</code><ul>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n<li>factory有三个参数：<code>function(require, exports, module)</code></li>\n</ul>\n</li>\n<li><code>require(id)</code><ul>\n<li>require 是一个方法，接受<strong>模块标识</strong>作为唯一参数，用来获取其他模块提供的接口</li>\n</ul>\n</li>\n<li><code>exports</code><ul>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n</ul>\n</li>\n<li><code>module</code><ul>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块  myModule.js</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</div><div class=\"line\">  $(<span class=\"string\">'div'</span>).addClass(<span class=\"string\">'active'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\">seajs.use([<span class=\"string\">'myModule.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"AMD与CMD的区别\"><a href=\"#AMD与CMD的区别\" class=\"headerlink\" title=\"AMD与CMD的区别\"></a>AMD与CMD的区别</h2><blockquote>\n<p>AMD 是提前执行，CMD 是延迟执行<br>在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><ul>\n<li>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范。</li>\n</ul>","more":"<ul>\n<li>应用：<strong>RequireJS</strong><br>解决的主要问题：<ul>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ul>\n</li>\n<li><code>define([id], [dependencies], factory);</code><ul>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ul>\n</li>\n<li><code>require([dependencies], function(){});</code><ul>\n<li>dependencies：一个数组，表示所依赖的模块</li>\n<li>function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n<li><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块 myModule.js</span></div><div class=\"line\">define([<span class=\"string\">'dependency'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Byron'</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">printName</span>: printName</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'myModule'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\">　 my.printName();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><ul>\n<li>CMD 即<code>Common Module Definition</code>通用模块定义</li>\n<li>应用：<strong>SeaJS</strong><br>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</li>\n<li><code>define([id],[deps],factory)</code><ul>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n<li>factory有三个参数：<code>function(require, exports, module)</code></li>\n</ul>\n</li>\n<li><code>require(id)</code><ul>\n<li>require 是一个方法，接受<strong>模块标识</strong>作为唯一参数，用来获取其他模块提供的接口</li>\n</ul>\n</li>\n<li><code>exports</code><ul>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n</ul>\n</li>\n<li><code>module</code><ul>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块  myModule.js</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</div><div class=\"line\">  $(<span class=\"string\">'div'</span>).addClass(<span class=\"string\">'active'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\">seajs.use([<span class=\"string\">'myModule.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"AMD与CMD的区别\"><a href=\"#AMD与CMD的区别\" class=\"headerlink\" title=\"AMD与CMD的区别\"></a>AMD与CMD的区别</h2><blockquote>\n<p>AMD 是提前执行，CMD 是延迟执行<br>在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>"},{"title":"从零开始的backbone.js（一）","date":"2017-03-28T08:24:10.000Z","_content":"实习项目用的框架：backbone.js\n\n> Backbone.js为复杂WEB应用程序提供**模型(models)**、**集合(collections)**、**视图(views)**的结构。\n\n<!--more-->\n\n## Backbone.Model（模型）\n* Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。\n```javascript\n//相当于public class ...\n//可以存放基本的数值以及方法\nvar Man = Backbone.Model.extend({\n\t//模型在服务器上位置的url\n\t//调用save方法时会post对象的所有属性到server端，数据形式是json\n\turl: '/man/',\n\t//定义了一个Model，实现了初始化方法（initialize函数）\n\tinitialize: function() {\n\t\talert('Hey,you create me!');\n\t\t//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个\n\t\t//当name发生改变时触发该函数\n\t\tthis.bind(\"change:name\",function(){\n\t\t\tvar name = this.get(\"name\");\n\t\t\talert(\"you change the name:\" + name);\n\t\t});\n\t\tthis.bind(\"invalid\",function(model,error){\n\t\t\talert(error);\n\t\t\t//error是来自validate校验的错误\n\t\t})\n\t},\n\t//定义默认值（属性）name & age\n\tdefaults: {\n\t\tname: 'tom',\n\t\tage: '18'\n\t},\n\t//Model.validate(attributes, options)，默认为未定义\n\t//默认在save之前调用，如果{validate:true}，则也能在set之前调用\n\t//当校验失败时，会触发\"invalid\"事件\n\tvalidate: function(attributes) {\n\t\tif(attributes.name == '') return \"name不能为空\";\n\t},\n\t//定义了名为aboutMe的一个方法（函数）\n\taboutMe: function() {\n\t\treturn \"I'm\" + this.get('name') + \",\" + this.get('age') \n\t\t+ \"years old.\";\n\t}\n});\n//实例化Model，并会直接调用initialize函数\nvar man = new Man;\n//Model.set(attribute),用来给Model修改或设置属性\n//改变了name的值，可以触发change事件，alert\nman.set({name : 'jane'});\n//设置时并不会触发校验\nman.set({name : ''});\n//model.save(attributes, options)，保存模型到数据库\n//如果验证成功，返回jqXHR，否则false\n//触发校验，根据验证规则弹出错误提示。\nman.save();\n//从服务器端获取数据\nvar man1 = new Man;\n//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作\nman1.fetch();\n//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json\nman1.fetch({url : '/man/'});\n//在服务器端返回数据的方法：\nman1.fetch({url:'/man/',success:function(model,response) {\n\t\t//model为获取到的数据\n\t\talert('success');\n\t\talert(model.get('name'));\n\t},error:function(){\n\t\t//当返回格式不正确或不是json数据时，会执行此方法\n\t\talert('error');\n\t}\n});\n```\n* **tip：** 关于`$(selector).bind(event,data,function)`\nevent：必填项，可以添加一个或多个，用空格隔开。\ndata：可以填可以不填，用来传递额外的数据\nfunction：必填项，事件发生时运行的函数\n[关于jQuery的事件方法](http://www.w3school.com.cn/jquery/jquery_ref_events.asp)\n\n","source":"_posts/17-03-28-8.md","raw":"---\ntitle: 从零开始的backbone.js（一）\ndate: 2017-03-28 16:24:10\n---\n实习项目用的框架：backbone.js\n\n> Backbone.js为复杂WEB应用程序提供**模型(models)**、**集合(collections)**、**视图(views)**的结构。\n\n<!--more-->\n\n## Backbone.Model（模型）\n* Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。\n```javascript\n//相当于public class ...\n//可以存放基本的数值以及方法\nvar Man = Backbone.Model.extend({\n\t//模型在服务器上位置的url\n\t//调用save方法时会post对象的所有属性到server端，数据形式是json\n\turl: '/man/',\n\t//定义了一个Model，实现了初始化方法（initialize函数）\n\tinitialize: function() {\n\t\talert('Hey,you create me!');\n\t\t//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个\n\t\t//当name发生改变时触发该函数\n\t\tthis.bind(\"change:name\",function(){\n\t\t\tvar name = this.get(\"name\");\n\t\t\talert(\"you change the name:\" + name);\n\t\t});\n\t\tthis.bind(\"invalid\",function(model,error){\n\t\t\talert(error);\n\t\t\t//error是来自validate校验的错误\n\t\t})\n\t},\n\t//定义默认值（属性）name & age\n\tdefaults: {\n\t\tname: 'tom',\n\t\tage: '18'\n\t},\n\t//Model.validate(attributes, options)，默认为未定义\n\t//默认在save之前调用，如果{validate:true}，则也能在set之前调用\n\t//当校验失败时，会触发\"invalid\"事件\n\tvalidate: function(attributes) {\n\t\tif(attributes.name == '') return \"name不能为空\";\n\t},\n\t//定义了名为aboutMe的一个方法（函数）\n\taboutMe: function() {\n\t\treturn \"I'm\" + this.get('name') + \",\" + this.get('age') \n\t\t+ \"years old.\";\n\t}\n});\n//实例化Model，并会直接调用initialize函数\nvar man = new Man;\n//Model.set(attribute),用来给Model修改或设置属性\n//改变了name的值，可以触发change事件，alert\nman.set({name : 'jane'});\n//设置时并不会触发校验\nman.set({name : ''});\n//model.save(attributes, options)，保存模型到数据库\n//如果验证成功，返回jqXHR，否则false\n//触发校验，根据验证规则弹出错误提示。\nman.save();\n//从服务器端获取数据\nvar man1 = new Man;\n//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作\nman1.fetch();\n//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json\nman1.fetch({url : '/man/'});\n//在服务器端返回数据的方法：\nman1.fetch({url:'/man/',success:function(model,response) {\n\t\t//model为获取到的数据\n\t\talert('success');\n\t\talert(model.get('name'));\n\t},error:function(){\n\t\t//当返回格式不正确或不是json数据时，会执行此方法\n\t\talert('error');\n\t}\n});\n```\n* **tip：** 关于`$(selector).bind(event,data,function)`\nevent：必填项，可以添加一个或多个，用空格隔开。\ndata：可以填可以不填，用来传递额外的数据\nfunction：必填项，事件发生时运行的函数\n[关于jQuery的事件方法](http://www.w3school.com.cn/jquery/jquery_ref_events.asp)\n\n","slug":"17-03-28-8","published":1,"updated":"2017-10-05T16:03:55.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sm000abguj7gpenl5v","content":"<p>实习项目用的框架：backbone.js</p>\n<blockquote>\n<p>Backbone.js为复杂WEB应用程序提供<strong>模型(models)</strong>、<strong>集合(collections)</strong>、<strong>视图(views)</strong>的结构。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Backbone-Model（模型）\"><a href=\"#Backbone-Model（模型）\" class=\"headerlink\" title=\"Backbone.Model（模型）\"></a>Backbone.Model（模型）</h2><ul>\n<li><p>Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//相当于public class ...</span></div><div class=\"line\"><span class=\"comment\">//可以存放基本的数值以及方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> Man = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//模型在服务器上位置的url</span></div><div class=\"line\">\t<span class=\"comment\">//调用save方法时会post对象的所有属性到server端，数据形式是json</span></div><div class=\"line\">\turl: <span class=\"string\">'/man/'</span>,</div><div class=\"line\">\t<span class=\"comment\">//定义了一个Model，实现了初始化方法（initialize函数）</span></div><div class=\"line\">\tinitialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">'Hey,you create me!'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个</span></div><div class=\"line\">\t\t<span class=\"comment\">//当name发生改变时触发该函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"change:name\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.get(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">\t\t\talert(<span class=\"string\">\"you change the name:\"</span> + name);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"invalid\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,error</span>)</span>&#123;</div><div class=\"line\">\t\t\talert(error);</div><div class=\"line\">\t\t\t<span class=\"comment\">//error是来自validate校验的错误</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义默认值（属性）name &amp; age</span></div><div class=\"line\">\tdefaults: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">'tom'</span>,</div><div class=\"line\">\t\t<span class=\"attr\">age</span>: <span class=\"string\">'18'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//Model.validate(attributes, options)，默认为未定义</span></div><div class=\"line\">\t<span class=\"comment\">//默认在save之前调用，如果&#123;validate:true&#125;，则也能在set之前调用</span></div><div class=\"line\">\t<span class=\"comment\">//当校验失败时，会触发\"invalid\"事件</span></div><div class=\"line\">\tvalidate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">attributes</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(attributes.name == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"name不能为空\"</span>;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义了名为aboutMe的一个方法（函数）</span></div><div class=\"line\">\taboutMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"I'm\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'name'</span>) + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'age'</span>) </div><div class=\"line\">\t\t+ <span class=\"string\">\"years old.\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化Model，并会直接调用initialize函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> man = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//Model.set(attribute),用来给Model修改或设置属性</span></div><div class=\"line\"><span class=\"comment\">//改变了name的值，可以触发change事件，alert</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'jane'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//设置时并不会触发校验</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">''</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//model.save(attributes, options)，保存模型到数据库</span></div><div class=\"line\"><span class=\"comment\">//如果验证成功，返回jqXHR，否则false</span></div><div class=\"line\"><span class=\"comment\">//触发校验，根据验证规则弹出错误提示。</span></div><div class=\"line\">man.save();</div><div class=\"line\"><span class=\"comment\">//从服务器端获取数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> man1 = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作</span></div><div class=\"line\">man1.fetch();</div><div class=\"line\"><span class=\"comment\">//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span> : <span class=\"string\">'/man/'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//在服务器端返回数据的方法：</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span>:<span class=\"string\">'/man/'</span>,<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,response</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//model为获取到的数据</span></div><div class=\"line\">\t\talert(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t\talert(model.get(<span class=\"string\">'name'</span>));</div><div class=\"line\">\t&#125;,<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//当返回格式不正确或不是json数据时，会执行此方法</span></div><div class=\"line\">\t\talert(<span class=\"string\">'error'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> 关于<code>$(selector).bind(event,data,function)</code><br>event：必填项，可以添加一个或多个，用空格隔开。<br>data：可以填可以不填，用来传递额外的数据<br>function：必填项，事件发生时运行的函数<br><a href=\"http://www.w3school.com.cn/jquery/jquery_ref_events.asp\" target=\"_blank\" rel=\"external\">关于jQuery的事件方法</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>实习项目用的框架：backbone.js</p>\n<blockquote>\n<p>Backbone.js为复杂WEB应用程序提供<strong>模型(models)</strong>、<strong>集合(collections)</strong>、<strong>视图(views)</strong>的结构。</p>\n</blockquote>","more":"<h2 id=\"Backbone-Model（模型）\"><a href=\"#Backbone-Model（模型）\" class=\"headerlink\" title=\"Backbone.Model（模型）\"></a>Backbone.Model（模型）</h2><ul>\n<li><p>Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//相当于public class ...</span></div><div class=\"line\"><span class=\"comment\">//可以存放基本的数值以及方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> Man = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//模型在服务器上位置的url</span></div><div class=\"line\">\t<span class=\"comment\">//调用save方法时会post对象的所有属性到server端，数据形式是json</span></div><div class=\"line\">\turl: <span class=\"string\">'/man/'</span>,</div><div class=\"line\">\t<span class=\"comment\">//定义了一个Model，实现了初始化方法（initialize函数）</span></div><div class=\"line\">\tinitialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">'Hey,you create me!'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个</span></div><div class=\"line\">\t\t<span class=\"comment\">//当name发生改变时触发该函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"change:name\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.get(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">\t\t\talert(<span class=\"string\">\"you change the name:\"</span> + name);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"invalid\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,error</span>)</span>&#123;</div><div class=\"line\">\t\t\talert(error);</div><div class=\"line\">\t\t\t<span class=\"comment\">//error是来自validate校验的错误</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义默认值（属性）name &amp; age</span></div><div class=\"line\">\tdefaults: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">'tom'</span>,</div><div class=\"line\">\t\t<span class=\"attr\">age</span>: <span class=\"string\">'18'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//Model.validate(attributes, options)，默认为未定义</span></div><div class=\"line\">\t<span class=\"comment\">//默认在save之前调用，如果&#123;validate:true&#125;，则也能在set之前调用</span></div><div class=\"line\">\t<span class=\"comment\">//当校验失败时，会触发\"invalid\"事件</span></div><div class=\"line\">\tvalidate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">attributes</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(attributes.name == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"name不能为空\"</span>;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义了名为aboutMe的一个方法（函数）</span></div><div class=\"line\">\taboutMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"I'm\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'name'</span>) + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'age'</span>) </div><div class=\"line\">\t\t+ <span class=\"string\">\"years old.\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化Model，并会直接调用initialize函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> man = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//Model.set(attribute),用来给Model修改或设置属性</span></div><div class=\"line\"><span class=\"comment\">//改变了name的值，可以触发change事件，alert</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'jane'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//设置时并不会触发校验</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">''</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//model.save(attributes, options)，保存模型到数据库</span></div><div class=\"line\"><span class=\"comment\">//如果验证成功，返回jqXHR，否则false</span></div><div class=\"line\"><span class=\"comment\">//触发校验，根据验证规则弹出错误提示。</span></div><div class=\"line\">man.save();</div><div class=\"line\"><span class=\"comment\">//从服务器端获取数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> man1 = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作</span></div><div class=\"line\">man1.fetch();</div><div class=\"line\"><span class=\"comment\">//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span> : <span class=\"string\">'/man/'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//在服务器端返回数据的方法：</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span>:<span class=\"string\">'/man/'</span>,<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,response</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//model为获取到的数据</span></div><div class=\"line\">\t\talert(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t\talert(model.get(<span class=\"string\">'name'</span>));</div><div class=\"line\">\t&#125;,<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//当返回格式不正确或不是json数据时，会执行此方法</span></div><div class=\"line\">\t\talert(<span class=\"string\">'error'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> 关于<code>$(selector).bind(event,data,function)</code><br>event：必填项，可以添加一个或多个，用空格隔开。<br>data：可以填可以不填，用来传递额外的数据<br>function：必填项，事件发生时运行的函数<br><a href=\"http://www.w3school.com.cn/jquery/jquery_ref_events.asp\" target=\"_blank\" rel=\"external\">关于jQuery的事件方法</a></p>\n</li>\n</ul>"},{"title":"有关CSS的tip","date":"2017-04-10T02:16:38.000Z","_content":"#### position的值，relative和absolute分别是相对于谁进行定位的？\n* `absolute` 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。\n* `fixed` （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。\n* `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。\n* `static` 默认值。没有定位，元素出现在正常的流中\n\n<!--more-->\n\n#### display:none和visibility:hidden的区别？\n* `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n* `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n#### position:absolute和float属性的异同\n* 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n* 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。\n\n#### CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n* 选择符\n```\n1.id选择器（ #myid）\n\n2.类选择器（.myclassname）\n\n3.标签选择器（div, h1, p）\n\n4.相邻选择器（h1 + p）\n\n5.子选择器（ul > li）\n\n6.后代选择器（li a）\n\n7.通配符选择器（ * ）\n\n8.属性选择器（a[rel = \"external\"]）\n\n9.伪类选择器（a: hover, li:nth-child）\n```\n* 继承\n\t* **不可继承：** display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi\n\t* **所有元素可继承：** visibility、cursor\n\t* **内联元素可继承：** letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction\n\t* **终端块状元素可继承：** text-indent和text-align\n\t* **列表元素可继承：** list-style、list-style-type、list-style-position、list-style-image\n* 优先级\n```\n!important > id > class > tag\n```\n* 新增伪类\n```\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\np:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:enabled  :disabled 控制表单控件的禁用状态。\n\n:checked        单选框或复选框被选中。\n```\n\n#### CSS3有哪些新特性？\n```\nCSS3实现圆角（border-radius）\n\n阴影（box-shadow）\n\n对文字加特效（text-shadow）\n\n线性渐变（gradient）\n\n动画（animation）\n\n变换（transform）\n\ntransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n//旋转,缩放,定位,倾斜\n\n增加了更多的CSS选择器  多背景 rgba\n\n在CSS3中唯一引入的伪元素是::selection.\n\n媒体查询，多栏布局\n\nborder-image\n\n盒模型计算方式（box-sizing）\n```\n\n#### 有关盒模型计算\n* **content-box（默认）**\n\n布局所占宽度Width：\n```\nWidth = width + padding-left + padding-right + border-left + border-right\n```\n布局所占高度Height：\n```\nHeight = height + padding-top + padding-bottom + border-top + border-bottom\n```\n\n* **padding-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right) + border-top + border-bottom\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom) + border-top + border-bottom\n```\n\n* **border-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right + border-left + border-right)\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom + border-top + border-bottom)\n```\n\n#### 清除浮动的技巧\n* **使用空标签清除浮动。**\n这种方法是在所有浮动标签后面添加一个空标签，定义css `clear:both` ，弊端就是增加了无意义。\n* **使用overflow。**\n给包含浮动元素的父标签添加css属性 `overflow:auto; zoom:1; zoom:1` 用于兼容IE6。\n* **使用after伪对象清除浮动。**\n该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n```css\n#parent:after{\n\tcontent:\".\";\n\theight:0;\n\tvisibility:hidden;\n\tdisplay:block;\n\tclear:both;\n}\n```\n\n#### 浮动元素引起的问题和解决办法\n* 浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n* 解决办法：\n（1）使用CSS中的`clear:both;`属性来清除元素的浮动可解决2、3问题\n（2）对于问题1，添加如下样式，给父元素添加`clearfix`样式：\n```css\n.clearfix:after{\n\tcontent: \".\";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix{\n\tdisplay: inline-block;\n} /* for IE/Mac */\n```","source":"_posts/17-04-10-13.md","raw":"---\ntitle: 有关CSS的tip\ndate: 2017-04-10 10:16:38\n---\n#### position的值，relative和absolute分别是相对于谁进行定位的？\n* `absolute` 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。\n* `fixed` （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。\n* `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。\n* `static` 默认值。没有定位，元素出现在正常的流中\n\n<!--more-->\n\n#### display:none和visibility:hidden的区别？\n* `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n* `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n#### position:absolute和float属性的异同\n* 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n* 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。\n\n#### CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n* 选择符\n```\n1.id选择器（ #myid）\n\n2.类选择器（.myclassname）\n\n3.标签选择器（div, h1, p）\n\n4.相邻选择器（h1 + p）\n\n5.子选择器（ul > li）\n\n6.后代选择器（li a）\n\n7.通配符选择器（ * ）\n\n8.属性选择器（a[rel = \"external\"]）\n\n9.伪类选择器（a: hover, li:nth-child）\n```\n* 继承\n\t* **不可继承：** display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi\n\t* **所有元素可继承：** visibility、cursor\n\t* **内联元素可继承：** letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction\n\t* **终端块状元素可继承：** text-indent和text-align\n\t* **列表元素可继承：** list-style、list-style-type、list-style-position、list-style-image\n* 优先级\n```\n!important > id > class > tag\n```\n* 新增伪类\n```\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\np:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:enabled  :disabled 控制表单控件的禁用状态。\n\n:checked        单选框或复选框被选中。\n```\n\n#### CSS3有哪些新特性？\n```\nCSS3实现圆角（border-radius）\n\n阴影（box-shadow）\n\n对文字加特效（text-shadow）\n\n线性渐变（gradient）\n\n动画（animation）\n\n变换（transform）\n\ntransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n//旋转,缩放,定位,倾斜\n\n增加了更多的CSS选择器  多背景 rgba\n\n在CSS3中唯一引入的伪元素是::selection.\n\n媒体查询，多栏布局\n\nborder-image\n\n盒模型计算方式（box-sizing）\n```\n\n#### 有关盒模型计算\n* **content-box（默认）**\n\n布局所占宽度Width：\n```\nWidth = width + padding-left + padding-right + border-left + border-right\n```\n布局所占高度Height：\n```\nHeight = height + padding-top + padding-bottom + border-top + border-bottom\n```\n\n* **padding-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right) + border-top + border-bottom\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom) + border-top + border-bottom\n```\n\n* **border-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right + border-left + border-right)\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom + border-top + border-bottom)\n```\n\n#### 清除浮动的技巧\n* **使用空标签清除浮动。**\n这种方法是在所有浮动标签后面添加一个空标签，定义css `clear:both` ，弊端就是增加了无意义。\n* **使用overflow。**\n给包含浮动元素的父标签添加css属性 `overflow:auto; zoom:1; zoom:1` 用于兼容IE6。\n* **使用after伪对象清除浮动。**\n该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n```css\n#parent:after{\n\tcontent:\".\";\n\theight:0;\n\tvisibility:hidden;\n\tdisplay:block;\n\tclear:both;\n}\n```\n\n#### 浮动元素引起的问题和解决办法\n* 浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n* 解决办法：\n（1）使用CSS中的`clear:both;`属性来清除元素的浮动可解决2、3问题\n（2）对于问题1，添加如下样式，给父元素添加`clearfix`样式：\n```css\n.clearfix:after{\n\tcontent: \".\";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix{\n\tdisplay: inline-block;\n} /* for IE/Mac */\n```","slug":"17-04-10-13","published":1,"updated":"2017-10-05T16:03:55.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sm000bbgujfcg6epa4","content":"<h4 id=\"position的值，relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值，relative和absolute分别是相对于谁进行定位的？\"></a>position的值，relative和absolute分别是相对于谁进行定位的？</h4><ul>\n<li><code>absolute</code> 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。</li>\n<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h4><ul>\n<li><code>display:none</code> 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>\n<li><code>visibility:hidden</code> 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>\n</ul>\n<h4 id=\"position-absolute和float属性的异同\"><a href=\"#position-absolute和float属性的异同\" class=\"headerlink\" title=\"position:absolute和float属性的异同\"></a>position:absolute和float属性的异同</h4><ul>\n<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>\n<li>不同点：float仍会占据位置，position会覆盖文档流中的其他元素。</li>\n</ul>\n<h4 id=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\"><a href=\"#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><ul>\n<li><p>选择符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.id选择器（ #myid）</div><div class=\"line\"></div><div class=\"line\">2.类选择器（.myclassname）</div><div class=\"line\"></div><div class=\"line\">3.标签选择器（div, h1, p）</div><div class=\"line\"></div><div class=\"line\">4.相邻选择器（h1 + p）</div><div class=\"line\"></div><div class=\"line\">5.子选择器（ul &gt; li）</div><div class=\"line\"></div><div class=\"line\">6.后代选择器（li a）</div><div class=\"line\"></div><div class=\"line\">7.通配符选择器（ * ）</div><div class=\"line\"></div><div class=\"line\">8.属性选择器（a[rel = &quot;external&quot;]）</div><div class=\"line\"></div><div class=\"line\">9.伪类选择器（a: hover, li:nth-child）</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承</p>\n<ul>\n<li><strong>不可继承：</strong> display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li>\n<li><strong>所有元素可继承：</strong> visibility、cursor</li>\n<li><strong>内联元素可继承：</strong> letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</li>\n<li><strong>终端块状元素可继承：</strong> text-indent和text-align</li>\n<li><strong>列表元素可继承：</strong> list-style、list-style-type、list-style-position、list-style-image</li>\n</ul>\n</li>\n<li><p>优先级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">!important &gt; id &gt; class &gt; tag</div></pre></td></tr></table></figure>\n</li>\n<li><p>新增伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">:enabled  :disabled 控制表单控件的禁用状态。</div><div class=\"line\"></div><div class=\"line\">:checked        单选框或复选框被选中。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSS3实现圆角（border-radius）</div><div class=\"line\"></div><div class=\"line\">阴影（box-shadow）</div><div class=\"line\"></div><div class=\"line\">对文字加特效（text-shadow）</div><div class=\"line\"></div><div class=\"line\">线性渐变（gradient）</div><div class=\"line\"></div><div class=\"line\">动画（animation）</div><div class=\"line\"></div><div class=\"line\">变换（transform）</div><div class=\"line\"></div><div class=\"line\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);</div><div class=\"line\">//旋转,缩放,定位,倾斜</div><div class=\"line\"></div><div class=\"line\">增加了更多的CSS选择器  多背景 rgba</div><div class=\"line\"></div><div class=\"line\">在CSS3中唯一引入的伪元素是::selection.</div><div class=\"line\"></div><div class=\"line\">媒体查询，多栏布局</div><div class=\"line\"></div><div class=\"line\">border-image</div><div class=\"line\"></div><div class=\"line\">盒模型计算方式（box-sizing）</div></pre></td></tr></table></figure>\n<h4 id=\"有关盒模型计算\"><a href=\"#有关盒模型计算\" class=\"headerlink\" title=\"有关盒模型计算\"></a>有关盒模型计算</h4><ul>\n<li><strong>content-box（默认）</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>padding-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>border-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure></p>\n<h4 id=\"清除浮动的技巧\"><a href=\"#清除浮动的技巧\" class=\"headerlink\" title=\"清除浮动的技巧\"></a>清除浮动的技巧</h4><ul>\n<li><strong>使用空标签清除浮动。</strong><br>这种方法是在所有浮动标签后面添加一个空标签，定义css <code>clear:both</code> ，弊端就是增加了无意义。</li>\n<li><strong>使用overflow。</strong><br>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1; zoom:1</code> 用于兼容IE6。</li>\n<li><strong>使用after伪对象清除浮动。</strong><br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#parent</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>:hidden;</div><div class=\"line\">\t<span class=\"attribute\">display</span>:block;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>:both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"浮动元素引起的问题和解决办法\"><a href=\"#浮动元素引起的问题和解决办法\" class=\"headerlink\" title=\"浮动元素引起的问题和解决办法\"></a>浮动元素引起的问题和解决办法</h4><ul>\n<li>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n<li>解决办法：<br>（1）使用CSS中的<code>clear:both;</code>属性来清除元素的浮动可解决2、3问题<br>（2）对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>: both;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">&#125; <span class=\"comment\">/* for IE/Mac */</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"position的值，relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值，relative和absolute分别是相对于谁进行定位的？\"></a>position的值，relative和absolute分别是相对于谁进行定位的？</h4><ul>\n<li><code>absolute</code> 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。</li>\n<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n</ul>","more":"<h4 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h4><ul>\n<li><code>display:none</code> 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>\n<li><code>visibility:hidden</code> 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>\n</ul>\n<h4 id=\"position-absolute和float属性的异同\"><a href=\"#position-absolute和float属性的异同\" class=\"headerlink\" title=\"position:absolute和float属性的异同\"></a>position:absolute和float属性的异同</h4><ul>\n<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>\n<li>不同点：float仍会占据位置，position会覆盖文档流中的其他元素。</li>\n</ul>\n<h4 id=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\"><a href=\"#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><ul>\n<li><p>选择符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.id选择器（ #myid）</div><div class=\"line\"></div><div class=\"line\">2.类选择器（.myclassname）</div><div class=\"line\"></div><div class=\"line\">3.标签选择器（div, h1, p）</div><div class=\"line\"></div><div class=\"line\">4.相邻选择器（h1 + p）</div><div class=\"line\"></div><div class=\"line\">5.子选择器（ul &gt; li）</div><div class=\"line\"></div><div class=\"line\">6.后代选择器（li a）</div><div class=\"line\"></div><div class=\"line\">7.通配符选择器（ * ）</div><div class=\"line\"></div><div class=\"line\">8.属性选择器（a[rel = &quot;external&quot;]）</div><div class=\"line\"></div><div class=\"line\">9.伪类选择器（a: hover, li:nth-child）</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承</p>\n<ul>\n<li><strong>不可继承：</strong> display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li>\n<li><strong>所有元素可继承：</strong> visibility、cursor</li>\n<li><strong>内联元素可继承：</strong> letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</li>\n<li><strong>终端块状元素可继承：</strong> text-indent和text-align</li>\n<li><strong>列表元素可继承：</strong> list-style、list-style-type、list-style-position、list-style-image</li>\n</ul>\n</li>\n<li><p>优先级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">!important &gt; id &gt; class &gt; tag</div></pre></td></tr></table></figure>\n</li>\n<li><p>新增伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">:enabled  :disabled 控制表单控件的禁用状态。</div><div class=\"line\"></div><div class=\"line\">:checked        单选框或复选框被选中。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSS3实现圆角（border-radius）</div><div class=\"line\"></div><div class=\"line\">阴影（box-shadow）</div><div class=\"line\"></div><div class=\"line\">对文字加特效（text-shadow）</div><div class=\"line\"></div><div class=\"line\">线性渐变（gradient）</div><div class=\"line\"></div><div class=\"line\">动画（animation）</div><div class=\"line\"></div><div class=\"line\">变换（transform）</div><div class=\"line\"></div><div class=\"line\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);</div><div class=\"line\">//旋转,缩放,定位,倾斜</div><div class=\"line\"></div><div class=\"line\">增加了更多的CSS选择器  多背景 rgba</div><div class=\"line\"></div><div class=\"line\">在CSS3中唯一引入的伪元素是::selection.</div><div class=\"line\"></div><div class=\"line\">媒体查询，多栏布局</div><div class=\"line\"></div><div class=\"line\">border-image</div><div class=\"line\"></div><div class=\"line\">盒模型计算方式（box-sizing）</div></pre></td></tr></table></figure>\n<h4 id=\"有关盒模型计算\"><a href=\"#有关盒模型计算\" class=\"headerlink\" title=\"有关盒模型计算\"></a>有关盒模型计算</h4><ul>\n<li><strong>content-box（默认）</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>padding-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>border-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure></p>\n<h4 id=\"清除浮动的技巧\"><a href=\"#清除浮动的技巧\" class=\"headerlink\" title=\"清除浮动的技巧\"></a>清除浮动的技巧</h4><ul>\n<li><strong>使用空标签清除浮动。</strong><br>这种方法是在所有浮动标签后面添加一个空标签，定义css <code>clear:both</code> ，弊端就是增加了无意义。</li>\n<li><strong>使用overflow。</strong><br>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1; zoom:1</code> 用于兼容IE6。</li>\n<li><strong>使用after伪对象清除浮动。</strong><br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#parent</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>:hidden;</div><div class=\"line\">\t<span class=\"attribute\">display</span>:block;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>:both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"浮动元素引起的问题和解决办法\"><a href=\"#浮动元素引起的问题和解决办法\" class=\"headerlink\" title=\"浮动元素引起的问题和解决办法\"></a>浮动元素引起的问题和解决办法</h4><ul>\n<li>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n<li>解决办法：<br>（1）使用CSS中的<code>clear:both;</code>属性来清除元素的浮动可解决2、3问题<br>（2）对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>: both;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">&#125; <span class=\"comment\">/* for IE/Mac */</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"title":"JavaScript正则表达式","date":"2017-04-21T07:22:18.000Z","_content":">正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n<!--more-->\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","source":"_posts/17-04-21-14.md","raw":"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n<!--more-->\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","slug":"17-04-21-14","published":1,"updated":"2017-10-05T16:03:55.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sn000cbgujqq392ony","content":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\0\t匹配null字符(\\u0000)</div><div class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</div><div class=\"line\">\\t  \t匹配制表符tab(\\u0009)</div><div class=\"line\">\\n  \t匹配换行符(\\u000A)</div><div class=\"line\">\\v      匹配垂直制表符(\\u000B)</div><div class=\"line\">\\f\t匹配换页符(\\u000C)</div><div class=\"line\">\\r\t匹配回车键(\\u000D)</div><div class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</div><div class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</div><div class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</div></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...]   匹配方括号内的任意字符</div><div class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</div><div class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</div><div class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</div><div class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</div><div class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</div><div class=\"line\">\\s \t任何Unicode空白符</div><div class=\"line\">\\S\t任何非Unicode空白符的字符</div><div class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</div><div class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</div></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</div><div class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</div><div class=\"line\">&#123;n&#125; \t匹配前一项n次</div><div class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</div><div class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</div><div class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</div></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</div><div class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</div><div class=\"line\">(...) \t把单独的项组合成子表达式</div><div class=\"line\">\\n\t引用第n个带括号的子表达式</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></div><div class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></div></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</div><div class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</div><div class=\"line\">\\b \t匹配一个单词的边界</div><div class=\"line\">\\B \t匹配非单词边界的位置</div><div class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</div><div class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">i \t执行不区分大小写的匹配</div><div class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</div><div class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</div><div class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></div></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第二个参数：</div><div class=\"line\">$`\t指代匹配结果前面的文本</div><div class=\"line\">$&apos;\t指代匹配结果后面的文本</div><div class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</div><div class=\"line\">$$ \t指代美元符号$</div></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></div></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>","more":"<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\0\t匹配null字符(\\u0000)</div><div class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</div><div class=\"line\">\\t  \t匹配制表符tab(\\u0009)</div><div class=\"line\">\\n  \t匹配换行符(\\u000A)</div><div class=\"line\">\\v      匹配垂直制表符(\\u000B)</div><div class=\"line\">\\f\t匹配换页符(\\u000C)</div><div class=\"line\">\\r\t匹配回车键(\\u000D)</div><div class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</div><div class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</div><div class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</div></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...]   匹配方括号内的任意字符</div><div class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</div><div class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</div><div class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</div><div class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</div><div class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</div><div class=\"line\">\\s \t任何Unicode空白符</div><div class=\"line\">\\S\t任何非Unicode空白符的字符</div><div class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</div><div class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</div></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</div><div class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</div><div class=\"line\">&#123;n&#125; \t匹配前一项n次</div><div class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</div><div class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</div><div class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</div></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</div><div class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</div><div class=\"line\">(...) \t把单独的项组合成子表达式</div><div class=\"line\">\\n\t引用第n个带括号的子表达式</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></div><div class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></div></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</div><div class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</div><div class=\"line\">\\b \t匹配一个单词的边界</div><div class=\"line\">\\B \t匹配非单词边界的位置</div><div class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</div><div class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">i \t执行不区分大小写的匹配</div><div class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</div><div class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</div><div class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></div></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第二个参数：</div><div class=\"line\">$`\t指代匹配结果前面的文本</div><div class=\"line\">$&apos;\t指代匹配结果后面的文本</div><div class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</div><div class=\"line\">$$ \t指代美元符号$</div></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></div></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>"},{"title":"搭建Hexo博客之后","date":"2017-07-15T06:59:11.000Z","_content":"\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!--more-->\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n#### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n#### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n#### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n#### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n#### 更换电脑后的操作\n\n* 使用`git clone`将远程仓库克隆到本地\n* 在本地的仓库执行`npm install hexo`、`npm install`、`npm install hexo-git-backup --save`，就完成了更换电脑更新的操作啦（记得，不需要`hexo init`这条指令）。\n\n","source":"_posts/17-07-15-19.md","raw":"---\ntitle: 搭建Hexo博客之后\ndate: 2017-07-15 14:59:11\n---\n\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!--more-->\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n#### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n#### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n#### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n#### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n#### 更换电脑后的操作\n\n* 使用`git clone`将远程仓库克隆到本地\n* 在本地的仓库执行`npm install hexo`、`npm install`、`npm install hexo-git-backup --save`，就完成了更换电脑更新的操作啦（记得，不需要`hexo init`这条指令）。\n\n","slug":"17-07-15-19","published":1,"updated":"2017-10-05T16:03:55.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2so000dbgujcg978swa","content":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>\n<a id=\"more\"></a>\n<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch README.md</div><div class=\"line\">$ git init </div><div class=\"line\">$ git add README.md</div><div class=\"line\">$ git commit -m &quot;first commit&quot;</div><div class=\"line\">$ git remote add origin 你的项目地址</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull --rebase origin master</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h4 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch hexo</div><div class=\"line\">$ git push origin hexo</div></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h4 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div><div class=\"line\">$ npm install hexo</div><div class=\"line\">$ hexo init</div><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h4><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></div><div class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></div><div class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></div><div class=\"line\"><span class=\"attr\">backup:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span></div><div class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g </div><div class=\"line\">$ hexo d //部署博客</div><div class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h4 id=\"更换电脑后的操作\"><a href=\"#更换电脑后的操作\" class=\"headerlink\" title=\"更换电脑后的操作\"></a>更换电脑后的操作</h4><ul>\n<li>使用<code>git clone</code>将远程仓库克隆到本地</li>\n<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>","more":"<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch README.md</div><div class=\"line\">$ git init </div><div class=\"line\">$ git add README.md</div><div class=\"line\">$ git commit -m &quot;first commit&quot;</div><div class=\"line\">$ git remote add origin 你的项目地址</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull --rebase origin master</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h4 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch hexo</div><div class=\"line\">$ git push origin hexo</div></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h4 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div><div class=\"line\">$ npm install hexo</div><div class=\"line\">$ hexo init</div><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h4><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></div><div class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></div><div class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></div><div class=\"line\"><span class=\"attr\">backup:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span></div><div class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g </div><div class=\"line\">$ hexo d //部署博客</div><div class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h4 id=\"更换电脑后的操作\"><a href=\"#更换电脑后的操作\" class=\"headerlink\" title=\"更换电脑后的操作\"></a>更换电脑后的操作</h4><ul>\n<li>使用<code>git clone</code>将远程仓库克隆到本地</li>\n<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>\n</ul>"},{"title":"异步编程之promise与trigger","date":"2017-07-15T08:13:01.000Z","_content":"这周的学习任务：`promise`与`trigger`\n<!--more-->\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\n\n#### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n#### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n#### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","source":"_posts/17-07-15-20.md","raw":"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\n---\n这周的学习任务：`promise`与`trigger`\n<!--more-->\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\n\n#### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n#### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n#### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","slug":"17-07-15-20","published":1,"updated":"2017-10-05T16:03:55.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sp000ebguj024c8xpq","content":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code><br><a id=\"more\"></a></p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h4 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h4><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></div><div class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div><div class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  callback();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1(f2);</div><div class=\"line\">f3();</div></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1().then(f2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</div><div class=\"line\">　<span class=\"comment\">// f1的任务代码</span></div><div class=\"line\">　dfd.resolve();</div><div class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h4 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h4><ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">      <span class=\"attr\">url</span>: ...,</div><div class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        ....</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"...\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  dosth();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h4><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code><br>","more":"</p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h4 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h4><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></div><div class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div><div class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  callback();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1(f2);</div><div class=\"line\">f3();</div></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1().then(f2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</div><div class=\"line\">　<span class=\"comment\">// f1的任务代码</span></div><div class=\"line\">　dfd.resolve();</div><div class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h4 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h4><ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">      <span class=\"attr\">url</span>: ...,</div><div class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        ....</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"...\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  dosth();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h4><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>"},{"title":"JS继承笔记","date":"2017-07-07T14:02:11.000Z","_content":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n<!--more-->\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","source":"_posts/17-07-07-17.md","raw":"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n<!--more-->\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","slug":"17-07-07-17","published":1,"updated":"2017-10-05T16:03:55.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sp000fbguj13n1j2r8","content":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<a id=\"more\"></a>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt=\"\"><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//现有两个构造函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  Animal.apply(<span class=\"keyword\">this</span>.arguments);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div><div class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></div><div class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">funtion Animal() &#123;&#125;</div><div class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">F.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">  temp.prototype = parent.prototype;</div><div class=\"line\">  child.prototype = <span class=\"keyword\">new</span> temp();</div><div class=\"line\">  child.prototype.constructor = child;</div><div class=\"line\">  child.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>","more":"<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt=\"\"><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//现有两个构造函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  Animal.apply(<span class=\"keyword\">this</span>.arguments);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div><div class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></div><div class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">funtion Animal() &#123;&#125;</div><div class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">F.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">  temp.prototype = parent.prototype;</div><div class=\"line\">  child.prototype = <span class=\"keyword\">new</span> temp();</div><div class=\"line\">  child.prototype.constructor = child;</div><div class=\"line\">  child.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt=\"\"></p>"},{"title":"JS之this指针笔记","date":"2017-07-08T05:48:43.000Z","_content":"## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!--more-->\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n  this.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n  alert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n  test: function () {\n    this.x = 1;\n  } //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n  test: function () {\n    //在构造函数的时候也会调用其他的函数，所以this的指向就会变\n    $(this.xx).on(\"click\",function(){\n      //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n    })\n  } \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n  name: \"小明\",\n  sex: \"男\",\n  age: \"18\",\n  say: function() {\n    alert(this.name + \",\" + this.sex + \",\" + this.age);\n  }\n}\n\nvar xh = {\n  name: \"小红\",\n  sex: \"女\",\n  age: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n  this.txt = \"这是一个对象属性\";\n  $(\"div\").click($.proxy(this.myClick,this));\n  //本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n  alert(this.txt);\n  alert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","source":"_posts/17-07-08-18.md","raw":"---\ntitle: JS之this指针笔记\ndate: 2017-07-08 13:48:43\n---\n## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!--more-->\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n  this.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n  alert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n  test: function () {\n    this.x = 1;\n  } //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n  test: function () {\n    //在构造函数的时候也会调用其他的函数，所以this的指向就会变\n    $(this.xx).on(\"click\",function(){\n      //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n    })\n  } \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n  name: \"小明\",\n  sex: \"男\",\n  age: \"18\",\n  say: function() {\n    alert(this.name + \",\" + this.sex + \",\" + this.age);\n  }\n}\n\nvar xh = {\n  name: \"小红\",\n  sex: \"女\",\n  age: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n  this.txt = \"这是一个对象属性\";\n  $(\"div\").click($.proxy(this.myClick,this));\n  //本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n  alert(this.txt);\n  alert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","slug":"17-07-08-18","published":1,"updated":"2017-10-05T16:03:55.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sq000gbgujwn470smr","content":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></div><div class=\"line\">&#125;</div><div class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">  &#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class=\"line\">    $(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"男\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"18\"</span>,</div><div class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小红\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"女\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</div><div class=\"line\">  $(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</div><div class=\"line\">  <span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.txt);</div><div class=\"line\">  alert(event.currentTarget.nodeName);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>","more":"<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></div><div class=\"line\">&#125;</div><div class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">  &#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class=\"line\">    $(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"男\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"18\"</span>,</div><div class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小红\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"女\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</div><div class=\"line\">  $(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</div><div class=\"line\">  <span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.txt);</div><div class=\"line\">  alert(event.currentTarget.nodeName);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"网络知识补充——浏览器请求过程","date":"2017-08-17T12:49:56.000Z","_content":"当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n<!--more-->\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。\n以Chrome浏览器为例，其解析过程：\n* 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存\n* 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）\n* 读取本地的HOST文件（操作系统的DNS缓存也没有找到）\n* 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求\n\n紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：\n* 查找本地缓存\n* 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求\n* 将迭代查询后的结果返回给操作系统内核同时进行缓存\n\n之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入`Controller`层，进行相关的逻辑处理，以及请求的分发，然后来调用`Model`层，`Model`层主要负责与数据的交互，在交互过程中会它会读取`redis`和数据库中存储的数据，最终将渲染好的页面通过`View`层返回给网络。这时，`httpResponse`就通过层层网络回到浏览器，浏览器根据请求回来的`html`、`css`、`js`进行渲染，最终将页面展现在我们面前。\n\n## DNS\n\nDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：`http://www.baidu.com/`，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。\n**Tip：**电脑中的HOST文件是通过静态匹配IP和域名\n\n#### 域名空间结构\n\n* 根域：`.`，根域名的服务器只有13台\n* 顶级域（一级域）：`edu`、`gov`、`com`、`org`、`mil`、`cn`等，由域名分配组织ISO决定\n  * 组织域\n  ```\n  gov         政府部门\n  com         商业部门\n  edu         教育部门\n  org         民间团体组织\n  net         网络服务机构\n  mil         军事部门\n  ```\n  * 国家或地区域\n  ```\n  cn          中国\n  jp          日本\n  uk          英国\n  au          澳大利亚\n  hk          中国香港\n  ```\n* 二级域：个人和企业向域名分配组织申请的，需要购买，如`baidu`、`sina`等\n* 主机名（三级域）：申请完二级域名后自己规定的，如`www`（代表网页服务）、`NEWS`\n\n一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。\n在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。\n\n#### DNS查询过程\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png)\n\n客户机向指定的域名服务器发送请求，说我想要访问`www.baidu.com.cn`这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（`cn`）的IP地址，紧接着本地域名服务器就向`cn`服务器发送询问，`cn`服务器返回`com.cn`服务器的IP，然后本地服务器接着询问，直到找到`www.baidu.com.cn`的IP地址，再返回给客户机。这个过程就是**DNS迭代查询**。\n\n## ISO/OSI 七层模型\n\n#### 基本概念\n\n* ISO：国际标准化组织\n* OSI：开放系统互联模型\n* IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统\n* OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png)\n\n每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。 \n**注意点：**各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。\n\n**为什么要进行分层？**\n\n因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。\n\n**传输单位：**\n  * 比特：bit，机器码的传输单位，每个0或1就是一个比特。\n  * 帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。\n  * 报文：保存的基本信息为IP地址（负责外网通信）。\n  * TPDU：传输协议数据单元。\n  * APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。\n\n#### 七层详解\n\n* 物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）\n* 数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。\n* 网络层：提供逻辑地址（IP）、选路。\n* 传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）\n* 会话层：对应用会话的管理、同步。\n* 表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。\n* 应用层：用户接口（可以理解为各自桌面应用）。\n\n## TCP/IP 四层模型\n\n#### 基本概念\n\n* 网络接口层：与OSI参考模型中的**物理层**和**数据链路层**相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。**地址解析协议（ARP）**工作在此层，即OSI参考模型的数据链路层。\n* 网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：**网际协议（IP）**、**互联网组管理协议（IGMP）**和**互联网控制报文协议（ICMP）**。\n* 传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：**传输控制协议（TCP）**和**用户数据报协议（UDP）**。\n* 应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png)\n\n#### 比较\n\n* 共同点：\n    * 都采用了层次结构的概念；\n    * 都能够提供面向连接和无连接两种通信服务机制；\n* 不同点：\n    * 前者七层模型，后者四层结构；\n    * 对可靠性的要求不同（后者更高）；\n    * OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。\n    * 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。\n\n## TCP/IP 通信\n\n**当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？**\n\n首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。\n在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。\n\n#### IP协议 \n\nIP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是**IP地址**和**MAC地址**（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。\n\n**APR协议：**通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。\n**路由选择：**在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。\n\n#### TCP协议\n\nTCP协议位于传输层，提供可靠的字节流服务。其中**字节流服务**是指，将大块的数据分割成以报文为单位的数据包进行管理。**可靠的传输服务**是指能够把数据准确可靠的传给对方。\n\n**三次握手：**为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。\n\n发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n>**「我给你讲个TCP的笑话吧」**\n\n>“我给你讲一个TCP的笑话吧？”\n>“给我讲一个TCP笑话呗！”\n>“好的，我会给你讲一个TCP的笑话。”\n\n**TCP与UDP比较：**UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。\n","source":"_posts/17-08-17-23.md","raw":"---\ntitle: 网络知识补充——浏览器请求过程\ndate: 2017-08-17 20:49:56\ntags:\n---\n当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n<!--more-->\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。\n以Chrome浏览器为例，其解析过程：\n* 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存\n* 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）\n* 读取本地的HOST文件（操作系统的DNS缓存也没有找到）\n* 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求\n\n紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：\n* 查找本地缓存\n* 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求\n* 将迭代查询后的结果返回给操作系统内核同时进行缓存\n\n之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入`Controller`层，进行相关的逻辑处理，以及请求的分发，然后来调用`Model`层，`Model`层主要负责与数据的交互，在交互过程中会它会读取`redis`和数据库中存储的数据，最终将渲染好的页面通过`View`层返回给网络。这时，`httpResponse`就通过层层网络回到浏览器，浏览器根据请求回来的`html`、`css`、`js`进行渲染，最终将页面展现在我们面前。\n\n## DNS\n\nDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：`http://www.baidu.com/`，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。\n**Tip：**电脑中的HOST文件是通过静态匹配IP和域名\n\n#### 域名空间结构\n\n* 根域：`.`，根域名的服务器只有13台\n* 顶级域（一级域）：`edu`、`gov`、`com`、`org`、`mil`、`cn`等，由域名分配组织ISO决定\n  * 组织域\n  ```\n  gov         政府部门\n  com         商业部门\n  edu         教育部门\n  org         民间团体组织\n  net         网络服务机构\n  mil         军事部门\n  ```\n  * 国家或地区域\n  ```\n  cn          中国\n  jp          日本\n  uk          英国\n  au          澳大利亚\n  hk          中国香港\n  ```\n* 二级域：个人和企业向域名分配组织申请的，需要购买，如`baidu`、`sina`等\n* 主机名（三级域）：申请完二级域名后自己规定的，如`www`（代表网页服务）、`NEWS`\n\n一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。\n在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。\n\n#### DNS查询过程\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png)\n\n客户机向指定的域名服务器发送请求，说我想要访问`www.baidu.com.cn`这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（`cn`）的IP地址，紧接着本地域名服务器就向`cn`服务器发送询问，`cn`服务器返回`com.cn`服务器的IP，然后本地服务器接着询问，直到找到`www.baidu.com.cn`的IP地址，再返回给客户机。这个过程就是**DNS迭代查询**。\n\n## ISO/OSI 七层模型\n\n#### 基本概念\n\n* ISO：国际标准化组织\n* OSI：开放系统互联模型\n* IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统\n* OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png)\n\n每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。 \n**注意点：**各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。\n\n**为什么要进行分层？**\n\n因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。\n\n**传输单位：**\n  * 比特：bit，机器码的传输单位，每个0或1就是一个比特。\n  * 帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。\n  * 报文：保存的基本信息为IP地址（负责外网通信）。\n  * TPDU：传输协议数据单元。\n  * APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。\n\n#### 七层详解\n\n* 物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）\n* 数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。\n* 网络层：提供逻辑地址（IP）、选路。\n* 传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）\n* 会话层：对应用会话的管理、同步。\n* 表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。\n* 应用层：用户接口（可以理解为各自桌面应用）。\n\n## TCP/IP 四层模型\n\n#### 基本概念\n\n* 网络接口层：与OSI参考模型中的**物理层**和**数据链路层**相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。**地址解析协议（ARP）**工作在此层，即OSI参考模型的数据链路层。\n* 网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：**网际协议（IP）**、**互联网组管理协议（IGMP）**和**互联网控制报文协议（ICMP）**。\n* 传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：**传输控制协议（TCP）**和**用户数据报协议（UDP）**。\n* 应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png)\n\n#### 比较\n\n* 共同点：\n    * 都采用了层次结构的概念；\n    * 都能够提供面向连接和无连接两种通信服务机制；\n* 不同点：\n    * 前者七层模型，后者四层结构；\n    * 对可靠性的要求不同（后者更高）；\n    * OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。\n    * 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。\n\n## TCP/IP 通信\n\n**当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？**\n\n首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。\n在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。\n\n#### IP协议 \n\nIP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是**IP地址**和**MAC地址**（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。\n\n**APR协议：**通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。\n**路由选择：**在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。\n\n#### TCP协议\n\nTCP协议位于传输层，提供可靠的字节流服务。其中**字节流服务**是指，将大块的数据分割成以报文为单位的数据包进行管理。**可靠的传输服务**是指能够把数据准确可靠的传给对方。\n\n**三次握手：**为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。\n\n发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n>**「我给你讲个TCP的笑话吧」**\n\n>“我给你讲一个TCP的笑话吧？”\n>“给我讲一个TCP笑话呗！”\n>“好的，我会给你讲一个TCP的笑话。”\n\n**TCP与UDP比较：**UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。\n","slug":"17-08-17-23","published":1,"updated":"2017-10-05T16:03:55.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sr000hbgujv77wvp21","content":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？<br><a id=\"more\"></a></p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt=\"\"></p>\n<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>\n<ul>\n<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>\n<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>\n<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>\n<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>\n</ul>\n<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>\n<ul>\n<li>查找本地缓存</li>\n<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>\n<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>\n</ul>\n<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>\n<h4 id=\"域名空间结构\"><a href=\"#域名空间结构\" class=\"headerlink\" title=\"域名空间结构\"></a>域名空间结构</h4><ul>\n<li>根域：<code>.</code>，根域名的服务器只有13台</li>\n<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>\n<ul>\n<li><p>组织域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">gov         政府部门</div><div class=\"line\">com         商业部门</div><div class=\"line\">edu         教育部门</div><div class=\"line\">org         民间团体组织</div><div class=\"line\">net         网络服务机构</div><div class=\"line\">mil         军事部门</div></pre></td></tr></table></figure>\n</li>\n<li><p>国家或地区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cn          中国</div><div class=\"line\">jp          日本</div><div class=\"line\">uk          英国</div><div class=\"line\">au          澳大利亚</div><div class=\"line\">hk          中国香港</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>\n</li>\n<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>\n</ul>\n<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>\n<h4 id=\"DNS查询过程\"><a href=\"#DNS查询过程\" class=\"headerlink\" title=\"DNS查询过程\"></a>DNS查询过程</h4><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png\" alt=\"\"></p>\n<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>\n<h2 id=\"ISO-OSI-七层模型\"><a href=\"#ISO-OSI-七层模型\" class=\"headerlink\" title=\"ISO/OSI 七层模型\"></a>ISO/OSI 七层模型</h2><h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>ISO：国际标准化组织</li>\n<li>OSI：开放系统互联模型</li>\n<li>IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统</li>\n<li>OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png\" alt=\"\"></p>\n<p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。<br><strong>注意点：</strong>各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。</p>\n<p><strong>为什么要进行分层？</strong></p>\n<p>因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。</p>\n<p><strong>传输单位：</strong></p>\n<ul>\n<li>比特：bit，机器码的传输单位，每个0或1就是一个比特。</li>\n<li>帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。</li>\n<li>报文：保存的基本信息为IP地址（负责外网通信）。</li>\n<li>TPDU：传输协议数据单元。</li>\n<li>APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。</li>\n</ul>\n<h4 id=\"七层详解\"><a href=\"#七层详解\" class=\"headerlink\" title=\"七层详解\"></a>七层详解</h4><ul>\n<li>物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）</li>\n<li>数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。</li>\n<li>网络层：提供逻辑地址（IP）、选路。</li>\n<li>传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）</li>\n<li>会话层：对应用会话的管理、同步。</li>\n<li>表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。</li>\n<li>应用层：用户接口（可以理解为各自桌面应用）。</li>\n</ul>\n<h2 id=\"TCP-IP-四层模型\"><a href=\"#TCP-IP-四层模型\" class=\"headerlink\" title=\"TCP/IP 四层模型\"></a>TCP/IP 四层模型</h2><h4 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>网络接口层：与OSI参考模型中的<strong>物理层</strong>和<strong>数据链路层</strong>相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。<strong>地址解析协议（ARP）</strong>工作在此层，即OSI参考模型的数据链路层。</li>\n<li>网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：<strong>网际协议（IP）</strong>、<strong>互联网组管理协议（IGMP）</strong>和<strong>互联网控制报文协议（ICMP）</strong>。</li>\n<li>传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：<strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议（UDP）</strong>。</li>\n<li>应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png\" alt=\"\"></p>\n<h4 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h4><ul>\n<li>共同点：<ul>\n<li>都采用了层次结构的概念；</li>\n<li>都能够提供面向连接和无连接两种通信服务机制；</li>\n</ul>\n</li>\n<li>不同点：<ul>\n<li>前者七层模型，后者四层结构；</li>\n<li>对可靠性的要求不同（后者更高）；</li>\n<li>OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。</li>\n<li>实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP-IP-通信\"><a href=\"#TCP-IP-通信\" class=\"headerlink\" title=\"TCP/IP 通信\"></a>TCP/IP 通信</h2><p><strong>当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？</strong></p>\n<p>首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。</p>\n<h4 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h4><p>IP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是<strong>IP地址</strong>和<strong>MAC地址</strong>（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p>\n<p><strong>APR协议：</strong>通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。<br><strong>路由选择：</strong>在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。</p>\n<h4 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h4><p>TCP协议位于传输层，提供可靠的字节流服务。其中<strong>字节流服务</strong>是指，将大块的数据分割成以报文为单位的数据包进行管理。<strong>可靠的传输服务</strong>是指能够把数据准确可靠的传给对方。</p>\n<p><strong>三次握手：</strong>为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>\n<blockquote>\n<p><strong>「我给你讲个TCP的笑话吧」</strong></p>\n<p>“我给你讲一个TCP的笑话吧？”<br>“给我讲一个TCP笑话呗！”<br>“好的，我会给你讲一个TCP的笑话。”</p>\n</blockquote>\n<p><strong>TCP与UDP比较：</strong>UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。</p>\n","site":{"data":{}},"excerpt":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？<br>","more":"</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt=\"\"></p>\n<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>\n<ul>\n<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>\n<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>\n<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>\n<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>\n</ul>\n<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>\n<ul>\n<li>查找本地缓存</li>\n<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>\n<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>\n</ul>\n<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>\n<h4 id=\"域名空间结构\"><a href=\"#域名空间结构\" class=\"headerlink\" title=\"域名空间结构\"></a>域名空间结构</h4><ul>\n<li>根域：<code>.</code>，根域名的服务器只有13台</li>\n<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>\n<ul>\n<li><p>组织域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">gov         政府部门</div><div class=\"line\">com         商业部门</div><div class=\"line\">edu         教育部门</div><div class=\"line\">org         民间团体组织</div><div class=\"line\">net         网络服务机构</div><div class=\"line\">mil         军事部门</div></pre></td></tr></table></figure>\n</li>\n<li><p>国家或地区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cn          中国</div><div class=\"line\">jp          日本</div><div class=\"line\">uk          英国</div><div class=\"line\">au          澳大利亚</div><div class=\"line\">hk          中国香港</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>\n</li>\n<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>\n</ul>\n<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>\n<h4 id=\"DNS查询过程\"><a href=\"#DNS查询过程\" class=\"headerlink\" title=\"DNS查询过程\"></a>DNS查询过程</h4><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png\" alt=\"\"></p>\n<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>\n<h2 id=\"ISO-OSI-七层模型\"><a href=\"#ISO-OSI-七层模型\" class=\"headerlink\" title=\"ISO/OSI 七层模型\"></a>ISO/OSI 七层模型</h2><h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>ISO：国际标准化组织</li>\n<li>OSI：开放系统互联模型</li>\n<li>IOS：在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统</li>\n<li>OSI七层模型的划分：OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互联系统参考模型。如下图。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/osi.png\" alt=\"\"></p>\n<p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。<br><strong>注意点：</strong>各层通信的接口并不是真实存在的接口，整个分层模型也只是逻辑上的分层。数据传递只在物理层进行，其他层的数据传递只是逻辑上的概念，并没有真实数据传递。</p>\n<p><strong>为什么要进行分层？</strong></p>\n<p>因为分层可以将功能进行划分，一旦数据传输出了问题，或者需要设计修改相关的功能软件，这样只要针对其中的一层进行排查和修改。分层的目的就是便于管理。</p>\n<p><strong>传输单位：</strong></p>\n<ul>\n<li>比特：bit，机器码的传输单位，每个0或1就是一个比特。</li>\n<li>帧：由帧头和帧数据组成。帧头包括接收方主机物理地址的定位以及其他信息。其中这个物理地址就是MAC地址（负责局域网通信）。而帧数据区含有一个数据体。</li>\n<li>报文：保存的基本信息为IP地址（负责外网通信）。</li>\n<li>TPDU：传输协议数据单元。</li>\n<li>APDU/PPDU/SPDU：由于上三层并不做数据传输，所以这三个单位可用可不用。SPDU是会话协议数据单元，PPDU是表示协议数据单元，ADPU是应用协议数据单元。</li>\n</ul>\n<h4 id=\"七层详解\"><a href=\"#七层详解\" class=\"headerlink\" title=\"七层详解\"></a>七层详解</h4><ul>\n<li>物理层：设备之间的比特流的传输、物理接口、电气特性等。（网线，网卡）</li>\n<li>数据链路层：成帧、用MAC地址访问媒介、错误检测与修正。</li>\n<li>网络层：提供逻辑地址（IP）、选路。</li>\n<li>传输层：可靠与不可靠的传输（TCP/UDP协议）、传输前的错误检测、流控。（确定端口号，而端口号是用于确定计算机所提供的服务的，例如www,mail等）</li>\n<li>会话层：对应用会话的管理、同步。</li>\n<li>表示层：数据的表现形式（将机器码转换成我们可以理解的字符，文件格式，反之亦可）、特定功能的实现如加密。</li>\n<li>应用层：用户接口（可以理解为各自桌面应用）。</li>\n</ul>\n<h2 id=\"TCP-IP-四层模型\"><a href=\"#TCP-IP-四层模型\" class=\"headerlink\" title=\"TCP/IP 四层模型\"></a>TCP/IP 四层模型</h2><h4 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>网络接口层：与OSI参考模型中的<strong>物理层</strong>和<strong>数据链路层</strong>相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。<strong>地址解析协议（ARP）</strong>工作在此层，即OSI参考模型的数据链路层。</li>\n<li>网际互联层：对应OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议涉及数据包在整个网络上的逻辑传输。该层有三个主要协议：<strong>网际协议（IP）</strong>、<strong>互联网组管理协议（IGMP）</strong>和<strong>互联网控制报文协议（ICMP）</strong>。</li>\n<li>传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：<strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议（UDP）</strong>。</li>\n<li>应用层：对应OSI参考模型的高层，为用户提供所需要的各自服务，例如：FTP、Telnet、DNS、SMTP等。</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/tcp-ip.png\" alt=\"\"></p>\n<h4 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h4><ul>\n<li>共同点：<ul>\n<li>都采用了层次结构的概念；</li>\n<li>都能够提供面向连接和无连接两种通信服务机制；</li>\n</ul>\n</li>\n<li>不同点：<ul>\n<li>前者七层模型，后者四层结构；</li>\n<li>对可靠性的要求不同（后者更高）；</li>\n<li>OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。</li>\n<li>实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP-IP-通信\"><a href=\"#TCP-IP-通信\" class=\"headerlink\" title=\"TCP/IP 通信\"></a>TCP/IP 通信</h2><p><strong>当浏览器向服务器发送HTTP请求的时候，数据是如何到达服务器的呢？</strong></p>\n<p>首先，为了传输的方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，每经过一层就将对应的首部去掉，最终到达服务器的应用层。</p>\n<h4 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h4><p>IP网际协议位于网络层，其作用是把各种数据包传送给对方，而要保证确实传送到，则需要满足各类条件，其中两个重要的条件是<strong>IP地址</strong>和<strong>MAC地址</strong>（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p>\n<p><strong>APR协议：</strong>通过APR协议对IP地址进行解析，可以查出通信方对应的MAC地址，从而进行通信。<br><strong>路由选择：</strong>在到达通信目标前的中转过程中，计算机与路由器等网络设备的传输线路不是固定的。</p>\n<h4 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h4><p>TCP协议位于传输层，提供可靠的字节流服务。其中<strong>字节流服务</strong>是指，将大块的数据分割成以报文为单位的数据包进行管理。<strong>可靠的传输服务</strong>是指能够把数据准确可靠的传给对方。</p>\n<p><strong>三次握手：</strong>为了确保数据准确传送，TCP协议把数据包传送出去后，会向对方确认是否成功送达。握手过程中使用了TCP标志——SYN（synchronize）和ACK（acknowledgement）。</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带有ACK标志的数据包，代表握手结束。若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>\n<blockquote>\n<p><strong>「我给你讲个TCP的笑话吧」</strong></p>\n<p>“我给你讲一个TCP的笑话吧？”<br>“给我讲一个TCP笑话呗！”<br>“好的，我会给你讲一个TCP的笑话。”</p>\n</blockquote>\n<p><strong>TCP与UDP比较：</strong>UDP也是一种传输协议，但是UDP是不可靠的，将数据包发送之后，就不会验证数据包和回复。</p>"},{"title":"JS变量、作用域和内存问题","date":"2017-08-15T12:30:52.000Z","_content":"## 变量\n\n#### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n<!--more-->\n\n```JavaScript\n//eg1\nvar num = 4;\nnum = 3; //这里的值操作并不是修改，而是覆盖\n\n//eg2\nvar str = 'string';\nvar anotherStr = str.replace('s',''); \n//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr\n\n```\n基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是`Number`，字符的包装对象是`String`。包装对象包含了这个类型的属性和方法。\n\n#### 堆栈\n\n在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。\n\n因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-1.png)\n\n#### 变量的比较\n\n```javascript\n//基本类型的比较\nvar xmScore = 4;\nvar xhScore =4;\nconsole.log(xmScore === xhScore) //true\n\n//引用类型的比较\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = {\n  age: 18,\n  score: 4\n};\nconsole.log(xm === xh); //false\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-2.png)\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-3.png)\n在引用类型中，只有指向同一个引用，变量才是相等的。\n\n\n```javascript\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用\nconsole.log(xm === xh); //true;\n```\n那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。\n```javascript\nfunction equalObjs(a,b) {\n  for(var p in a) {\n    if(a[p] !== b[p] return false;\n  }\n  return true;\n}\n\nfunction equalArrays(a,b) {\n  if(a.length !== b.length) return false;\n  for(var i = 0; i < a.length; i ++) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n```\n\n#### 变量的复制\n\n当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。\n```javascript\nfunction copyObj(obj) {\n  var newObj = {};\n  for(var p in obj) {\n   newObj[p] = obj[p];\n  }\n  return newObj;\n}\n```\n以上的方法便是**浅拷贝**，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。\n* `$.extend(deep,target,object1,objectN)`\n参数说明：\n`deep`：可选。布尔值。指是否深度合并对象，默认`false`。\n`target`：目标对象，其他对象的成员属性将被附加到该对象上。\n`object1`：可选。指第一个被合并的对象。\n`objectN`：可选。指第N个被合并的对象。\n\n#### 参数传递\n\n```javascript\nfunction fn(a,b) {\n  return a + b;\n} // 在函数里声明的a与b是形参\nfn(1,2); //在调用函数时传入的参数是实参\n```\n当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。\n```javascript\n//eg1 当变量为基本类型时\nfunction addTen(num) {\n  return num + 10;\n}\nvar score = 10;\naddTen(score);\n//相当于\nnum = score;\n\n//eg2 当变量为引用类型时\nfunction setName(obj) {\n  return obj.name = 'xm';\n}\nvar person = {};\nsetName(person);\n```\n当传递的参数是引用类型时，也相当于`obj = person`，因为引用类型赋值时是对地址进行复制的，所以`obj`与`person`实际上指向的都是同一个引用，所以我们对`obj`的修改也能反应到`person`上。\n\n#### 类型检测\n\n`typeof`：返回字符串类型。可以区分基本类型，但是无法区分引用类型（`null`，对象和数组返回的都是`object`）。\n`instanceof`：用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法`[] instanceof Array`。\n\n## 作用域\n\n> 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量\n\n#### 全局与局部\n\n在JS中，变量的作用域分为两种：全局变量和局部变量\n全局变量的声明方式有两种：\n```javascript\nvar n = 999; //直接在外部声明\nfunction f1() {\n  i = 888; //在函数内部声明，但是不适用var命令\n}\n```\n全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。\n在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用`{}`包含的域。在其他语言，例如C++，`if`和`for`中声明的变量在外部也是无法访问到的。但是JS中，在`if`和`for`中声明的变量在整个函数内部都可以访问。\n```\nfor(var i = 0; i < 10; i ++) { }\n//等同于\nvar i = 0;\nfor(i < 10; i ++) { }\n```\n\n#### 变量的作用域链\n\n```javascript\nvar name = 'xm';\nfunuction fn(argument) {\n  var name = 'xh';\n  var sex = 'male';\n  function fn2(argument) {\n    var name = 'xhei';\n    var age = 18;\n  }\n}\n```\n\n所有全局空间中的属性和方法，都是属于window的（`window.name = 'xm';`）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（`fn.sex`与`fn.fn2`不存在）。\n作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。\n**作用链：** 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png)\n\n* **延长作用域链**\n\n```javascript\nvar person = {};\nperson.name = 'xm';\nperson.sex = 'male';\nvar score = 4;\n\nwith(person) {\n  name = 'xh';\n  sex = 'female';\n  score = 44;\n}\n\nconsole.log(person.name); //xh\nconsole.log(person.sex); //female\nconsole.log(score); //44\n```\n使用`with`的时候，当修改`name`与`sex`时，此时查找的作用域是`person`，但是`person`中并不存在`score`这个属性，于是with就随着作用域链查找到`window`下的`score`，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。\n\n* **闭包**\n\n在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //999\n  }\n  return f2; //将f2作为返回值\n}\n\nvar result = f1();\nresult(); //999\n```\n以上代码中的f2函数就是闭包，也就是闭包可以理解为**\"定义在一个函数内部的函数\"**。\n* **闭包的两个用途**：\n  * 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。\n  * 将某些变量的值始终保持在内存中。（JS的垃圾回收机制）\n\n#### JS解析机制-预解析\n\nJS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。\n```javascript\nvar name = 'xm';\nvar age = 18;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\nfn(); //undefined\n```\n就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的`var`找出来，并且将所有的变量都赋值为`undefined`。然后查找该域中的`function`，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是`undefined`。\n```\n//window域预解析\nvar name = undefiied;\nvar age = undefined;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\n\n//fn域预解析\nvar name = undefined;\nvar age = undefined;\n\n//逐行解析\nname = 'xm';\nage = 18;\nfn(argument) {\n  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined\n  name = 'xh';\n  age = 10;\n}\n```\n在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。\n```javascript\nconsole.log(a);\na = 1; //预解析不解析没有var的变量，所以浏览器会报错\n```\n\n## 内存\n\n#### 垃圾回收机制\n**垃圾回收机制：**释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。\n**标识无用数据的策略：**\n  * **标记清除：**垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。**环境中的变量**指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。\n  * **引用计数：**引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。\n  * **循环引用问题：**\n  \n```javascript\nfunction fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n}\nfun();\nxm = null; //0\nxh = null; //0\n\nfunctioni fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n  xm.wife = xh; //2\n  xh.husband = xm; //2\n}\nfn();\nxm = null; //1\nxh = null; //1\n```\n由于`xm`与`xh`相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。\n\n#### 管理内存\n\n为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为`null`。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","source":"_posts/17-08-15-21.md","raw":"---\ntitle: JS变量、作用域和内存问题\ndate: 2017-08-15 20:30:52\ntags:\n---\n## 变量\n\n#### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n<!--more-->\n\n```JavaScript\n//eg1\nvar num = 4;\nnum = 3; //这里的值操作并不是修改，而是覆盖\n\n//eg2\nvar str = 'string';\nvar anotherStr = str.replace('s',''); \n//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr\n\n```\n基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是`Number`，字符的包装对象是`String`。包装对象包含了这个类型的属性和方法。\n\n#### 堆栈\n\n在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。\n\n因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-1.png)\n\n#### 变量的比较\n\n```javascript\n//基本类型的比较\nvar xmScore = 4;\nvar xhScore =4;\nconsole.log(xmScore === xhScore) //true\n\n//引用类型的比较\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = {\n  age: 18,\n  score: 4\n};\nconsole.log(xm === xh); //false\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-2.png)\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-3.png)\n在引用类型中，只有指向同一个引用，变量才是相等的。\n\n\n```javascript\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用\nconsole.log(xm === xh); //true;\n```\n那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。\n```javascript\nfunction equalObjs(a,b) {\n  for(var p in a) {\n    if(a[p] !== b[p] return false;\n  }\n  return true;\n}\n\nfunction equalArrays(a,b) {\n  if(a.length !== b.length) return false;\n  for(var i = 0; i < a.length; i ++) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n```\n\n#### 变量的复制\n\n当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。\n```javascript\nfunction copyObj(obj) {\n  var newObj = {};\n  for(var p in obj) {\n   newObj[p] = obj[p];\n  }\n  return newObj;\n}\n```\n以上的方法便是**浅拷贝**，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。\n* `$.extend(deep,target,object1,objectN)`\n参数说明：\n`deep`：可选。布尔值。指是否深度合并对象，默认`false`。\n`target`：目标对象，其他对象的成员属性将被附加到该对象上。\n`object1`：可选。指第一个被合并的对象。\n`objectN`：可选。指第N个被合并的对象。\n\n#### 参数传递\n\n```javascript\nfunction fn(a,b) {\n  return a + b;\n} // 在函数里声明的a与b是形参\nfn(1,2); //在调用函数时传入的参数是实参\n```\n当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。\n```javascript\n//eg1 当变量为基本类型时\nfunction addTen(num) {\n  return num + 10;\n}\nvar score = 10;\naddTen(score);\n//相当于\nnum = score;\n\n//eg2 当变量为引用类型时\nfunction setName(obj) {\n  return obj.name = 'xm';\n}\nvar person = {};\nsetName(person);\n```\n当传递的参数是引用类型时，也相当于`obj = person`，因为引用类型赋值时是对地址进行复制的，所以`obj`与`person`实际上指向的都是同一个引用，所以我们对`obj`的修改也能反应到`person`上。\n\n#### 类型检测\n\n`typeof`：返回字符串类型。可以区分基本类型，但是无法区分引用类型（`null`，对象和数组返回的都是`object`）。\n`instanceof`：用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法`[] instanceof Array`。\n\n## 作用域\n\n> 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量\n\n#### 全局与局部\n\n在JS中，变量的作用域分为两种：全局变量和局部变量\n全局变量的声明方式有两种：\n```javascript\nvar n = 999; //直接在外部声明\nfunction f1() {\n  i = 888; //在函数内部声明，但是不适用var命令\n}\n```\n全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。\n在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用`{}`包含的域。在其他语言，例如C++，`if`和`for`中声明的变量在外部也是无法访问到的。但是JS中，在`if`和`for`中声明的变量在整个函数内部都可以访问。\n```\nfor(var i = 0; i < 10; i ++) { }\n//等同于\nvar i = 0;\nfor(i < 10; i ++) { }\n```\n\n#### 变量的作用域链\n\n```javascript\nvar name = 'xm';\nfunuction fn(argument) {\n  var name = 'xh';\n  var sex = 'male';\n  function fn2(argument) {\n    var name = 'xhei';\n    var age = 18;\n  }\n}\n```\n\n所有全局空间中的属性和方法，都是属于window的（`window.name = 'xm';`）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（`fn.sex`与`fn.fn2`不存在）。\n作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。\n**作用链：** 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png)\n\n* **延长作用域链**\n\n```javascript\nvar person = {};\nperson.name = 'xm';\nperson.sex = 'male';\nvar score = 4;\n\nwith(person) {\n  name = 'xh';\n  sex = 'female';\n  score = 44;\n}\n\nconsole.log(person.name); //xh\nconsole.log(person.sex); //female\nconsole.log(score); //44\n```\n使用`with`的时候，当修改`name`与`sex`时，此时查找的作用域是`person`，但是`person`中并不存在`score`这个属性，于是with就随着作用域链查找到`window`下的`score`，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。\n\n* **闭包**\n\n在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //999\n  }\n  return f2; //将f2作为返回值\n}\n\nvar result = f1();\nresult(); //999\n```\n以上代码中的f2函数就是闭包，也就是闭包可以理解为**\"定义在一个函数内部的函数\"**。\n* **闭包的两个用途**：\n  * 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。\n  * 将某些变量的值始终保持在内存中。（JS的垃圾回收机制）\n\n#### JS解析机制-预解析\n\nJS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。\n```javascript\nvar name = 'xm';\nvar age = 18;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\nfn(); //undefined\n```\n就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的`var`找出来，并且将所有的变量都赋值为`undefined`。然后查找该域中的`function`，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是`undefined`。\n```\n//window域预解析\nvar name = undefiied;\nvar age = undefined;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\n\n//fn域预解析\nvar name = undefined;\nvar age = undefined;\n\n//逐行解析\nname = 'xm';\nage = 18;\nfn(argument) {\n  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined\n  name = 'xh';\n  age = 10;\n}\n```\n在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。\n```javascript\nconsole.log(a);\na = 1; //预解析不解析没有var的变量，所以浏览器会报错\n```\n\n## 内存\n\n#### 垃圾回收机制\n**垃圾回收机制：**释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。\n**标识无用数据的策略：**\n  * **标记清除：**垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。**环境中的变量**指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。\n  * **引用计数：**引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。\n  * **循环引用问题：**\n  \n```javascript\nfunction fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n}\nfun();\nxm = null; //0\nxh = null; //0\n\nfunctioni fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n  xm.wife = xh; //2\n  xh.husband = xm; //2\n}\nfn();\nxm = null; //1\nxh = null; //1\n```\n由于`xm`与`xh`相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。\n\n#### 管理内存\n\n为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为`null`。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","slug":"17-08-15-21","published":1,"updated":"2017-10-05T16:03:55.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2ss000ibgujjoojc8ol","content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改<a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1</span></div><div class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">4</span>;</div><div class=\"line\">num = <span class=\"number\">3</span>; <span class=\"comment\">//这里的值操作并不是修改，而是覆盖</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'string'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.replace(<span class=\"string\">'s'</span>,<span class=\"string\">''</span>); </div><div class=\"line\"><span class=\"comment\">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></div></pre></td></tr></table></figure>\n<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>\n<h4 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h4><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>\n<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png\" alt=\"\"></p>\n<h4 id=\"变量的比较\"><a href=\"#变量的比较\" class=\"headerlink\" title=\"变量的比较\"></a>变量的比较</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//基本类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xmScore = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> xhScore =<span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xmScore === xhScore) <span class=\"comment\">//true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//引用类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//false</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png\" alt=\"\"><br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png\" alt=\"\"><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = xm; <span class=\"comment\">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//true;</span></div></pre></td></tr></table></figure>\n<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalObjs</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> a) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[p] !== b[p] <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalArrays</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(a.length !== b.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[i] !== b[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的复制\"><a href=\"#变量的复制\" class=\"headerlink\" title=\"变量的复制\"></a>变量的复制</h4><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObj</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">   newObj[p] = obj[p];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> newObj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>\n<ul>\n<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>\n</ul>\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125; <span class=\"comment\">// 在函数里声明的a与b是形参</span></div><div class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//在调用函数时传入的参数是实参</span></div></pre></td></tr></table></figure>\n<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1 当变量为基本类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTen</span>(<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">10</span>;</div><div class=\"line\">addTen(score);</div><div class=\"line\"><span class=\"comment\">//相当于</span></div><div class=\"line\">num = score;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2 当变量为引用类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">setName(person);</div></pre></td></tr></table></figure></p>\n<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>\n<h4 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h4><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>\n</blockquote>\n<h4 id=\"全局与局部\"><a href=\"#全局与局部\" class=\"headerlink\" title=\"全局与局部\"></a>全局与局部</h4><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">999</span>; <span class=\"comment\">//直接在外部声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  i = <span class=\"number\">888</span>; <span class=\"comment\">//在函数内部声明，但是不适用var命令</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</div><div class=\"line\">//等同于</div><div class=\"line\">var i = 0;</div><div class=\"line\">for(i &lt; 10; i ++) &#123; &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的作用域链\"><a href=\"#变量的作用域链\" class=\"headerlink\" title=\"变量的作用域链\"></a>变量的作用域链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">funuction fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> sex = <span class=\"string\">'male'</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'xhei'</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png\" alt=\"\"></p>\n<ul>\n<li><strong>延长作用域链</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.sex = <span class=\"string\">'male'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">4</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span>(person) &#123;</div><div class=\"line\">  name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  sex = <span class=\"string\">'female'</span>;</div><div class=\"line\">  score = <span class=\"number\">44</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">//xh</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//female</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(score); <span class=\"comment\">//44</span></div></pre></td></tr></table></figure>\n<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>\n<ul>\n<li><strong>闭包</strong></li>\n</ul>\n<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(n); <span class=\"comment\">//999</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> f2; <span class=\"comment\">//将f2作为返回值</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result = f1();</div><div class=\"line\">result(); <span class=\"comment\">//999</span></div></pre></td></tr></table></figure></p>\n<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>\n<ul>\n<li><strong>闭包的两个用途</strong>：<ul>\n<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>\n<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JS解析机制-预解析\"><a href=\"#JS解析机制-预解析\" class=\"headerlink\" title=\"JS解析机制-预解析\"></a>JS解析机制-预解析</h4><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fn(); <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure></p>\n<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//window域预解析</div><div class=\"line\">var name = undefiied;</div><div class=\"line\">var age = undefined;</div><div class=\"line\">function fn(argument) &#123;</div><div class=\"line\">  console.log(name);</div><div class=\"line\">  var name = &apos;xh&apos;;</div><div class=\"line\">  var age = 10;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//fn域预解析</div><div class=\"line\">var name = undefined;</div><div class=\"line\">var age = undefined;</div><div class=\"line\"></div><div class=\"line\">//逐行解析</div><div class=\"line\">name = &apos;xm&apos;;</div><div class=\"line\">age = 18;</div><div class=\"line\">fn(argument) &#123;</div><div class=\"line\">  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</div><div class=\"line\">  name = &apos;xh&apos;;</div><div class=\"line\">  age = 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">a = <span class=\"number\">1</span>; <span class=\"comment\">//预解析不解析没有var的变量，所以浏览器会报错</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><h4 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h4><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>\n<ul>\n<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>\n<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>\n<li><strong>循环引用问题：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">&#125;</div><div class=\"line\">fun();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\"></div><div class=\"line\">functioni fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  xm.wife = xh; <span class=\"comment\">//2</span></div><div class=\"line\">  xh.husband = xm; <span class=\"comment\">//2</span></div><div class=\"line\">&#125;</div><div class=\"line\">fn();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>\n<h4 id=\"管理内存\"><a href=\"#管理内存\" class=\"headerlink\" title=\"管理内存\"></a>管理内存</h4><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改","more":"</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1</span></div><div class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">4</span>;</div><div class=\"line\">num = <span class=\"number\">3</span>; <span class=\"comment\">//这里的值操作并不是修改，而是覆盖</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'string'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.replace(<span class=\"string\">'s'</span>,<span class=\"string\">''</span>); </div><div class=\"line\"><span class=\"comment\">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></div></pre></td></tr></table></figure>\n<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>\n<h4 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h4><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>\n<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png\" alt=\"\"></p>\n<h4 id=\"变量的比较\"><a href=\"#变量的比较\" class=\"headerlink\" title=\"变量的比较\"></a>变量的比较</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//基本类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xmScore = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> xhScore =<span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xmScore === xhScore) <span class=\"comment\">//true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//引用类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//false</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png\" alt=\"\"><br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png\" alt=\"\"><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = xm; <span class=\"comment\">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//true;</span></div></pre></td></tr></table></figure>\n<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalObjs</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> a) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[p] !== b[p] <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalArrays</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(a.length !== b.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[i] !== b[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的复制\"><a href=\"#变量的复制\" class=\"headerlink\" title=\"变量的复制\"></a>变量的复制</h4><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObj</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">   newObj[p] = obj[p];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> newObj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>\n<ul>\n<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>\n</ul>\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125; <span class=\"comment\">// 在函数里声明的a与b是形参</span></div><div class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//在调用函数时传入的参数是实参</span></div></pre></td></tr></table></figure>\n<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1 当变量为基本类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTen</span>(<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">10</span>;</div><div class=\"line\">addTen(score);</div><div class=\"line\"><span class=\"comment\">//相当于</span></div><div class=\"line\">num = score;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2 当变量为引用类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">setName(person);</div></pre></td></tr></table></figure></p>\n<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>\n<h4 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h4><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>\n</blockquote>\n<h4 id=\"全局与局部\"><a href=\"#全局与局部\" class=\"headerlink\" title=\"全局与局部\"></a>全局与局部</h4><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">999</span>; <span class=\"comment\">//直接在外部声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  i = <span class=\"number\">888</span>; <span class=\"comment\">//在函数内部声明，但是不适用var命令</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</div><div class=\"line\">//等同于</div><div class=\"line\">var i = 0;</div><div class=\"line\">for(i &lt; 10; i ++) &#123; &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的作用域链\"><a href=\"#变量的作用域链\" class=\"headerlink\" title=\"变量的作用域链\"></a>变量的作用域链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">funuction fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> sex = <span class=\"string\">'male'</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'xhei'</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png\" alt=\"\"></p>\n<ul>\n<li><strong>延长作用域链</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.sex = <span class=\"string\">'male'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">4</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span>(person) &#123;</div><div class=\"line\">  name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  sex = <span class=\"string\">'female'</span>;</div><div class=\"line\">  score = <span class=\"number\">44</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">//xh</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//female</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(score); <span class=\"comment\">//44</span></div></pre></td></tr></table></figure>\n<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>\n<ul>\n<li><strong>闭包</strong></li>\n</ul>\n<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(n); <span class=\"comment\">//999</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> f2; <span class=\"comment\">//将f2作为返回值</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result = f1();</div><div class=\"line\">result(); <span class=\"comment\">//999</span></div></pre></td></tr></table></figure></p>\n<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>\n<ul>\n<li><strong>闭包的两个用途</strong>：<ul>\n<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>\n<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JS解析机制-预解析\"><a href=\"#JS解析机制-预解析\" class=\"headerlink\" title=\"JS解析机制-预解析\"></a>JS解析机制-预解析</h4><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fn(); <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure></p>\n<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//window域预解析</div><div class=\"line\">var name = undefiied;</div><div class=\"line\">var age = undefined;</div><div class=\"line\">function fn(argument) &#123;</div><div class=\"line\">  console.log(name);</div><div class=\"line\">  var name = &apos;xh&apos;;</div><div class=\"line\">  var age = 10;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//fn域预解析</div><div class=\"line\">var name = undefined;</div><div class=\"line\">var age = undefined;</div><div class=\"line\"></div><div class=\"line\">//逐行解析</div><div class=\"line\">name = &apos;xm&apos;;</div><div class=\"line\">age = 18;</div><div class=\"line\">fn(argument) &#123;</div><div class=\"line\">  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</div><div class=\"line\">  name = &apos;xh&apos;;</div><div class=\"line\">  age = 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">a = <span class=\"number\">1</span>; <span class=\"comment\">//预解析不解析没有var的变量，所以浏览器会报错</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><h4 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h4><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>\n<ul>\n<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>\n<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>\n<li><strong>循环引用问题：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">&#125;</div><div class=\"line\">fun();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\"></div><div class=\"line\">functioni fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  xm.wife = xh; <span class=\"comment\">//2</span></div><div class=\"line\">  xh.husband = xm; <span class=\"comment\">//2</span></div><div class=\"line\">&#125;</div><div class=\"line\">fn();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>\n<h4 id=\"管理内存\"><a href=\"#管理内存\" class=\"headerlink\" title=\"管理内存\"></a>管理内存</h4><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>"},{"title":"JS面向对象学习笔记","date":"2017-08-16T13:20:29.000Z","_content":"## 面向对象（OOP）的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n<!--more-->\n\n**对象有哪些特性？**\n* **封装性：**通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。\n* **继承：**很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。\n* **多态：**多态指的不同类的对象对同一消息作出不同的响应。\n\n**面向对象的优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。\n\nJavaScript作为一门面向对象的语言，却并不是通过**类**来实现面向对象的，而是通过**原型（prototype）**。那么这两者实现面向对象究竟有什么区别呢？\n\n#### 基于类vs基于原型\n\n基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。\n* **类（class）：**定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。\n* **实例（instance）：**类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。\n\n\n```java\n//定义类\npublic class Person {\n  String name;\n  int age;\n  void walking() {\n  }\n  void sleeping() {\n  }\n  Person(x,y) {\n    name = x;\n    age = y;\n  }//类的构造函数\n}\n//实例化\nPerson xm = new Person('xm',18);\n```\n\n其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。\n而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar xm = new Person('xm',18);\n```\n#### new操作符\n\n在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。\n在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的**两个步骤**\n* 将实例的`._proto_`指向构造函数的`prototype`属性。\n* 调用构造函数来初始化实例对象。（`call`、`apply`）\n\n#### 原型对象\n\n对象不仅仅有自己独特的属性，例如`Person`，每个`Person`的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。\n\n在Java中，共用的方法会采用静态的方式用`static`修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。\n\n而在JS中，则引入了原型对象。原型对象就是构造函数的`prototype`属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个`constructor`属性来指向该原型实例的构造函数。\n\n## 原型链\n\n由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的`_proto_`属性，`constructor`属性和`prototype`属性，它们相互指来指去，就形成了一条原型链。\n\n以`Person`这个构造函数为例，我们创建了它的实例`xm`，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中`_proto_`其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png)\n\n#### 属性查找\n\n当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回`undefined`。\n\n## 创建对象\n\n* 基于Object对象创建\n\n```javascript\nvar person = new Object();\nperson.name = 'xm';\nperson.age = 18;\nperson.getName = function() {\n  return this.name;\n}\n```\n* 字面量的方式：清晰的查找对象包含的属性和方法\n\n```javascript\nvar person = {\n  name: 'xm',\n  age: 18,\n  getName: function() {\n    return this.name;\n  }\n}\n```\n* 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。\n\n```javascript\nfunctioni createPerson(name,age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.getName = function() {\n    return this.name;\n  }\n  return o;\n}\nvar person = createPerson('xm',18);\n```\n* 构造函数模式\n\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n  this.getName = function() {\n    return this.name;\n  }\n}\nvar person = new Person('xm',18);\n```\n* `Object.create(prototype, descriptors)`：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数`prototype`。\n参数说明：\n`prototype`：必需。要用作原型的对象，可以为`null`。\n`descriptors`：可选。包含一个或多个属性描述符的JavaScript对象。\n\n```javascript\nvar var obj = Object.create({x:1});\nobj.hasOwnProperty('x');//false\n```","source":"_posts/17-08-16-22.md","raw":"---\ntitle: JS面向对象学习笔记\ndate: 2017-08-16 21:20:29\ntags:\n---\n## 面向对象（OOP）的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n<!--more-->\n\n**对象有哪些特性？**\n* **封装性：**通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。\n* **继承：**很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。\n* **多态：**多态指的不同类的对象对同一消息作出不同的响应。\n\n**面向对象的优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。\n\nJavaScript作为一门面向对象的语言，却并不是通过**类**来实现面向对象的，而是通过**原型（prototype）**。那么这两者实现面向对象究竟有什么区别呢？\n\n#### 基于类vs基于原型\n\n基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。\n* **类（class）：**定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。\n* **实例（instance）：**类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。\n\n\n```java\n//定义类\npublic class Person {\n  String name;\n  int age;\n  void walking() {\n  }\n  void sleeping() {\n  }\n  Person(x,y) {\n    name = x;\n    age = y;\n  }//类的构造函数\n}\n//实例化\nPerson xm = new Person('xm',18);\n```\n\n其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。\n而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar xm = new Person('xm',18);\n```\n#### new操作符\n\n在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。\n在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的**两个步骤**\n* 将实例的`._proto_`指向构造函数的`prototype`属性。\n* 调用构造函数来初始化实例对象。（`call`、`apply`）\n\n#### 原型对象\n\n对象不仅仅有自己独特的属性，例如`Person`，每个`Person`的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。\n\n在Java中，共用的方法会采用静态的方式用`static`修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。\n\n而在JS中，则引入了原型对象。原型对象就是构造函数的`prototype`属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个`constructor`属性来指向该原型实例的构造函数。\n\n## 原型链\n\n由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的`_proto_`属性，`constructor`属性和`prototype`属性，它们相互指来指去，就形成了一条原型链。\n\n以`Person`这个构造函数为例，我们创建了它的实例`xm`，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中`_proto_`其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png)\n\n#### 属性查找\n\n当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回`undefined`。\n\n## 创建对象\n\n* 基于Object对象创建\n\n```javascript\nvar person = new Object();\nperson.name = 'xm';\nperson.age = 18;\nperson.getName = function() {\n  return this.name;\n}\n```\n* 字面量的方式：清晰的查找对象包含的属性和方法\n\n```javascript\nvar person = {\n  name: 'xm',\n  age: 18,\n  getName: function() {\n    return this.name;\n  }\n}\n```\n* 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。\n\n```javascript\nfunctioni createPerson(name,age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.getName = function() {\n    return this.name;\n  }\n  return o;\n}\nvar person = createPerson('xm',18);\n```\n* 构造函数模式\n\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n  this.getName = function() {\n    return this.name;\n  }\n}\nvar person = new Person('xm',18);\n```\n* `Object.create(prototype, descriptors)`：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数`prototype`。\n参数说明：\n`prototype`：必需。要用作原型的对象，可以为`null`。\n`descriptors`：可选。包含一个或多个属性描述符的JavaScript对象。\n\n```javascript\nvar var obj = Object.create({x:1});\nobj.hasOwnProperty('x');//false\n```","slug":"17-08-16-22","published":1,"updated":"2017-10-05T16:03:55.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2st000jbgujijhtu64a","content":"<h2 id=\"面向对象（OOP）的概念\"><a href=\"#面向对象（OOP）的概念\" class=\"headerlink\" title=\"面向对象（OOP）的概念\"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏<a id=\"more\"></a>\n</li>\n</ul>\n<p><strong>对象有哪些特性？</strong></p>\n<ul>\n<li><strong>封装性：</strong>通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。</li>\n<li><strong>继承：</strong>很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。</li>\n<li><strong>多态：</strong>多态指的不同类的对象对同一消息作出不同的响应。</li>\n</ul>\n<p><strong>面向对象的优点：</strong>易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。</p>\n<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>\n<h4 id=\"基于类vs基于原型\"><a href=\"#基于类vs基于原型\" class=\"headerlink\" title=\"基于类vs基于原型\"></a>基于类vs基于原型</h4><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>\n<ul>\n<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>\n<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  String name;</div><div class=\"line\">  <span class=\"keyword\">int</span> age;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">walking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleeping</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Person(x,y) &#123;</div><div class=\"line\">    name = x;</div><div class=\"line\">    age = y;</div><div class=\"line\">  &#125;<span class=\"comment\">//类的构造函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\">Person xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h4><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>\n<ul>\n<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>\n<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>\n</ul>\n<h4 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h4><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>\n<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>\n<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>\n<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png\" alt=\"\"></p>\n<h4 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h4><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li>基于Object对象创建</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.age = <span class=\"number\">18</span>;</div><div class=\"line\">person.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>字面量的方式：清晰的查找对象包含的属性和方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xm'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">functioni createPerson(name,age) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.age = age;</div><div class=\"line\">  o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = createPerson(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>构造函数模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</div><div class=\"line\">obj.hasOwnProperty(<span class=\"string\">'x'</span>);<span class=\"comment\">//false</span></div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"面向对象（OOP）的概念\"><a href=\"#面向对象（OOP）的概念\" class=\"headerlink\" title=\"面向对象（OOP）的概念\"></a>面向对象（OOP）的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏","more":"</li>\n</ul>\n<p><strong>对象有哪些特性？</strong></p>\n<ul>\n<li><strong>封装性：</strong>通过封装可以为对象内部的数据提供不同级别的保护，避免了外界的干扰和不确定性。</li>\n<li><strong>继承：</strong>很好的支持了代码的重用性，通过一个类派生一个新的类，这个新类不仅可以具有原来的类的特性，还可以拥有新的特性。</li>\n<li><strong>多态：</strong>多态指的不同类的对象对同一消息作出不同的响应。</li>\n</ul>\n<p><strong>面向对象的优点：</strong>易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。</p>\n<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>\n<h4 id=\"基于类vs基于原型\"><a href=\"#基于类vs基于原型\" class=\"headerlink\" title=\"基于类vs基于原型\"></a>基于类vs基于原型</h4><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>\n<ul>\n<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>\n<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  String name;</div><div class=\"line\">  <span class=\"keyword\">int</span> age;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">walking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleeping</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Person(x,y) &#123;</div><div class=\"line\">    name = x;</div><div class=\"line\">    age = y;</div><div class=\"line\">  &#125;<span class=\"comment\">//类的构造函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\">Person xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h4><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>\n<ul>\n<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>\n<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>\n</ul>\n<h4 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h4><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>\n<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>\n<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>\n<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png\" alt=\"\"></p>\n<h4 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h4><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li>基于Object对象创建</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.age = <span class=\"number\">18</span>;</div><div class=\"line\">person.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>字面量的方式：清晰的查找对象包含的属性和方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xm'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">functioni createPerson(name,age) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.age = age;</div><div class=\"line\">  o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = createPerson(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>构造函数模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</div><div class=\"line\">obj.hasOwnProperty(<span class=\"string\">'x'</span>);<span class=\"comment\">//false</span></div></pre></td></tr></table></figure>"},{"title":"DOM基础知识巩固","date":"2017-10-02T05:15:36.000Z","_content":"## DOM本质\nDOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。\n\n## DOM节点操作\n\n#### 获取DOM节点\n\n* `document.getElementById`\n* `document.getElementsByTagName`\n* `document.getElementsByClassName`\n* `document.querySelectorAll`\n\n#### property与attribute\n\n虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。\n\n* property是DOM中的属性，是JavaScript里的对象；\n* attribute是HTML标签上的特性，它的值只能够是字符串；\n\n例如在html中有一段这样的代码：\n```html\n<input id=\"test\" value=\"1\" sth=\"whatever\">\n```\n我们在js中来获取这个DOM对象：\n```javascript\nvar test = document.getElementById('test');\nconsole.log(test);\nconsole.log(test.id); // 'test'\nconsole.log(test.value); // 1\nconsole.log(test.sth) // undefined\n```\n由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：\n```html\n<input id=\"test-2\" >\n```\n```javascript\nvar test_2 = document.getElementById('test-2');\nconsole.log(test_2.value); // null\n```\n虽然没有在标签中定义`value`，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：\n\n* DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。\n* 如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。\n\n那么标签上的sth定义在哪里呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png)\n\n也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。\n```javascript\nconsole.log(test.attibutes.sth); // 'sth=\"whatever\"'\n```\n由此可以得出：\n\n* HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；\n* 这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；\n\n那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：\n```javascript\ntest.value = 'new value of prop';\nconsole.log(test.value); // 'new value of prop'\nconsole.log(test.arrtibutes.value); // 'value=\"1\"'\n```\n如果反过来，效果又是如何呢？\n```javascript\ntest.attributes.value = 'new value of attr';\nconsole.log(test.value); // 'new value of attr'\nconsole.log(test.attributes.value); // 'new value of attr'\n```\n此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：\n```javascript\ntest.attributes.value.nodeValue = 'new value of attr';\n```\n由此，可得出结论：\n\n* property能够从attribute中得到同步；\n* attribute不会同步property上的值；\n* attribute和property之间的数据绑定是单向的，attribute->property；\n* 更改property和attribute上的任意值，都会将更新反映到HTML页面中；\n\n#### DOM操作\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png)\n\n有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：\n* 减少DOM访问次数\n* 多次访问同一DOM，应该用局部变量缓存该DOM\n* 尽可能使用querySelector，而不是使用获取HTML集合的API\n* 注意重排（reflow）和重绘（repaint）\n* 使用事件委托，减少绑定事件的数量\n\n#### 重排（重构）&重绘\n\n重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：\n\n* 添加或删除DOM元素\n* 元素位置、大小、内容改变\n* 浏览器窗口大小改变\n* 滚动条出现\n\n**最小化重排、重绘的建议：**\n\n* 不要再修改布局信息的时候，去查询布局信息\n* 修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式\n* :hover会降低响应速度，在处理很大的列表时，避免使用\n\n## BOM操作\nBOM（Browser Object Model）指的是浏览器对象模型，主要用途：\n* 检测浏览器的类型\n* 拆解url的各部分\n\n#### navigator\n\n`navigator`对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。\n常用方法有：\n* `navigator.userAgent` //用户代理头的字符串表示\n\n#### screen\n\n`screen`对象：用于获取某些关于用户屏幕的信息。\n常用方法有：\n* `screen.width/height` //屏幕的宽度与高度，以像素计 \n* `screen.availWidth/availHeight` //窗口可以使用的屏幕的宽度和高度，以像素计 \n* `screen.colorDepth` //用户表示颜色的位数，大多数系统采用32位 \n* `window.moveTo(0, 0); `\n* `window.resizeTo(screen.availWidth, screen.availHeight); ` //填充用户的屏幕\n\n#### location\n\n`location`对象：表示载入窗口的URL。\n常用方法有：\n* `location.href` //当前载入页面的完整URL\n* `location.portocol` //URL中使用的协议，即双斜杠之前的部分，如http\n* `location.host` //服务器的名字，如www.wrox.com\n* `location.hostname` //通常等于host，有时会省略前面的www\n* `location.port` //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080\n* `location.pathname` //URL中主机名后的部分，如/pictures/index.htm\n* `location.search` //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx\n* `location.hash` //如果URL包含#，返回该符号之后的内容，如#anchor1\n* `location.assign(\"http:www.baidu.com\");` //同location.href，新地址都会被加到浏览器的历史栈中\n* `location.replace(\"http:www.baidu.com\");` //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问\n* `location.reload(true | false);` //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false\n\n#### history\n\n`history`对象：浏览器窗口的历史\n常用方法有：\n* `history.go(-1);` //访问浏览器窗口的历史，负数为后退，正数为前进\n* `history.back();` //同上\n* `history.forward();` //同上\n* `history.length` //可以查看历史中的页面数\n\n","source":"_posts/17-10-02-27.md","raw":"---\ntitle: DOM基础知识巩固\ndate: 2017-10-02 13:15:36\ntags:\n---\n## DOM本质\nDOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。\n\n## DOM节点操作\n\n#### 获取DOM节点\n\n* `document.getElementById`\n* `document.getElementsByTagName`\n* `document.getElementsByClassName`\n* `document.querySelectorAll`\n\n#### property与attribute\n\n虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。\n\n* property是DOM中的属性，是JavaScript里的对象；\n* attribute是HTML标签上的特性，它的值只能够是字符串；\n\n例如在html中有一段这样的代码：\n```html\n<input id=\"test\" value=\"1\" sth=\"whatever\">\n```\n我们在js中来获取这个DOM对象：\n```javascript\nvar test = document.getElementById('test');\nconsole.log(test);\nconsole.log(test.id); // 'test'\nconsole.log(test.value); // 1\nconsole.log(test.sth) // undefined\n```\n由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：\n```html\n<input id=\"test-2\" >\n```\n```javascript\nvar test_2 = document.getElementById('test-2');\nconsole.log(test_2.value); // null\n```\n虽然没有在标签中定义`value`，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：\n\n* DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。\n* 如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。\n\n那么标签上的sth定义在哪里呢？\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png)\n\n也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。\n```javascript\nconsole.log(test.attibutes.sth); // 'sth=\"whatever\"'\n```\n由此可以得出：\n\n* HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；\n* 这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；\n\n那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：\n```javascript\ntest.value = 'new value of prop';\nconsole.log(test.value); // 'new value of prop'\nconsole.log(test.arrtibutes.value); // 'value=\"1\"'\n```\n如果反过来，效果又是如何呢？\n```javascript\ntest.attributes.value = 'new value of attr';\nconsole.log(test.value); // 'new value of attr'\nconsole.log(test.attributes.value); // 'new value of attr'\n```\n此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：\n```javascript\ntest.attributes.value.nodeValue = 'new value of attr';\n```\n由此，可得出结论：\n\n* property能够从attribute中得到同步；\n* attribute不会同步property上的值；\n* attribute和property之间的数据绑定是单向的，attribute->property；\n* 更改property和attribute上的任意值，都会将更新反映到HTML页面中；\n\n#### DOM操作\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png)\n\n有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：\n* 减少DOM访问次数\n* 多次访问同一DOM，应该用局部变量缓存该DOM\n* 尽可能使用querySelector，而不是使用获取HTML集合的API\n* 注意重排（reflow）和重绘（repaint）\n* 使用事件委托，减少绑定事件的数量\n\n#### 重排（重构）&重绘\n\n重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：\n\n* 添加或删除DOM元素\n* 元素位置、大小、内容改变\n* 浏览器窗口大小改变\n* 滚动条出现\n\n**最小化重排、重绘的建议：**\n\n* 不要再修改布局信息的时候，去查询布局信息\n* 修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式\n* :hover会降低响应速度，在处理很大的列表时，避免使用\n\n## BOM操作\nBOM（Browser Object Model）指的是浏览器对象模型，主要用途：\n* 检测浏览器的类型\n* 拆解url的各部分\n\n#### navigator\n\n`navigator`对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。\n常用方法有：\n* `navigator.userAgent` //用户代理头的字符串表示\n\n#### screen\n\n`screen`对象：用于获取某些关于用户屏幕的信息。\n常用方法有：\n* `screen.width/height` //屏幕的宽度与高度，以像素计 \n* `screen.availWidth/availHeight` //窗口可以使用的屏幕的宽度和高度，以像素计 \n* `screen.colorDepth` //用户表示颜色的位数，大多数系统采用32位 \n* `window.moveTo(0, 0); `\n* `window.resizeTo(screen.availWidth, screen.availHeight); ` //填充用户的屏幕\n\n#### location\n\n`location`对象：表示载入窗口的URL。\n常用方法有：\n* `location.href` //当前载入页面的完整URL\n* `location.portocol` //URL中使用的协议，即双斜杠之前的部分，如http\n* `location.host` //服务器的名字，如www.wrox.com\n* `location.hostname` //通常等于host，有时会省略前面的www\n* `location.port` //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080\n* `location.pathname` //URL中主机名后的部分，如/pictures/index.htm\n* `location.search` //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx\n* `location.hash` //如果URL包含#，返回该符号之后的内容，如#anchor1\n* `location.assign(\"http:www.baidu.com\");` //同location.href，新地址都会被加到浏览器的历史栈中\n* `location.replace(\"http:www.baidu.com\");` //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问\n* `location.reload(true | false);` //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false\n\n#### history\n\n`history`对象：浏览器窗口的历史\n常用方法有：\n* `history.go(-1);` //访问浏览器窗口的历史，负数为后退，正数为前进\n* `history.back();` //同上\n* `history.forward();` //同上\n* `history.length` //可以查看历史中的页面数\n\n","slug":"17-10-02-27","published":1,"updated":"2017-10-05T16:03:55.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2su000kbguj2ankw4t0","content":"<h2 id=\"DOM本质\"><a href=\"#DOM本质\" class=\"headerlink\" title=\"DOM本质\"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>\n<h2 id=\"DOM节点操作\"><a href=\"#DOM节点操作\" class=\"headerlink\" title=\"DOM节点操作\"></a>DOM节点操作</h2><h4 id=\"获取DOM节点\"><a href=\"#获取DOM节点\" class=\"headerlink\" title=\"获取DOM节点\"></a>获取DOM节点</h4><ul>\n<li><code>document.getElementById</code></li>\n<li><code>document.getElementsByTagName</code></li>\n<li><code>document.getElementsByClassName</code></li>\n<li><code>document.querySelectorAll</code></li>\n</ul>\n<h4 id=\"property与attribute\"><a href=\"#property与attribute\" class=\"headerlink\" title=\"property与attribute\"></a>property与attribute</h4><p>虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。</p>\n<ul>\n<li>property是DOM中的属性，是JavaScript里的对象；</li>\n<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>\n</ul>\n<p>例如在html中有一段这样的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">sth</span>=<span class=\"string\">\"whatever\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>我们在js中来获取这个DOM对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.id); <span class=\"comment\">// 'test'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.sth) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure></p>\n<p>由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test-2\"</span> &gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> test_2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test-2'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test_2.value); <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>虽然没有在标签中定义<code>value</code>，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：</p>\n<ul>\n<li>DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。</li>\n<li>如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。</li>\n</ul>\n<p>那么标签上的sth定义在哪里呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png\" alt=\"\"></p>\n<p>也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(test.attibutes.sth); <span class=\"comment\">// 'sth=\"whatever\"'</span></div></pre></td></tr></table></figure></p>\n<p>由此可以得出：</p>\n<ul>\n<li>HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；</li>\n<li>这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；</li>\n</ul>\n<p>那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.value = <span class=\"string\">'new value of prop'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of prop'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.arrtibutes.value); <span class=\"comment\">// 'value=\"1\"'</span></div></pre></td></tr></table></figure></p>\n<p>如果反过来，效果又是如何呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.attributes.value = <span class=\"string\">'new value of attr'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of attr'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.attributes.value); <span class=\"comment\">// 'new value of attr'</span></div></pre></td></tr></table></figure></p>\n<p>此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.attributes.value.nodeValue = <span class=\"string\">'new value of attr'</span>;</div></pre></td></tr></table></figure></p>\n<p>由此，可得出结论：</p>\n<ul>\n<li>property能够从attribute中得到同步；</li>\n<li>attribute不会同步property上的值；</li>\n<li>attribute和property之间的数据绑定是单向的，attribute-&gt;property；</li>\n<li>更改property和attribute上的任意值，都会将更新反映到HTML页面中；</li>\n</ul>\n<h4 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h4><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png\" alt=\"\"></p>\n<p>有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：</p>\n<ul>\n<li>减少DOM访问次数</li>\n<li>多次访问同一DOM，应该用局部变量缓存该DOM</li>\n<li>尽可能使用querySelector，而不是使用获取HTML集合的API</li>\n<li>注意重排（reflow）和重绘（repaint）</li>\n<li>使用事件委托，减少绑定事件的数量</li>\n</ul>\n<h4 id=\"重排（重构）-amp-重绘\"><a href=\"#重排（重构）-amp-重绘\" class=\"headerlink\" title=\"重排（重构）&amp;重绘\"></a>重排（重构）&amp;重绘</h4><p>重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：</p>\n<ul>\n<li>添加或删除DOM元素</li>\n<li>元素位置、大小、内容改变</li>\n<li>浏览器窗口大小改变</li>\n<li>滚动条出现</li>\n</ul>\n<p><strong>最小化重排、重绘的建议：</strong></p>\n<ul>\n<li>不要再修改布局信息的时候，去查询布局信息</li>\n<li>修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式</li>\n<li>:hover会降低响应速度，在处理很大的列表时，避免使用</li>\n</ul>\n<h2 id=\"BOM操作\"><a href=\"#BOM操作\" class=\"headerlink\" title=\"BOM操作\"></a>BOM操作</h2><p>BOM（Browser Object Model）指的是浏览器对象模型，主要用途：</p>\n<ul>\n<li>检测浏览器的类型</li>\n<li>拆解url的各部分</li>\n</ul>\n<h4 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h4><p><code>navigator</code>对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。<br>常用方法有：</p>\n<ul>\n<li><code>navigator.userAgent</code> //用户代理头的字符串表示</li>\n</ul>\n<h4 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h4><p><code>screen</code>对象：用于获取某些关于用户屏幕的信息。<br>常用方法有：</p>\n<ul>\n<li><code>screen.width/height</code> //屏幕的宽度与高度，以像素计 </li>\n<li><code>screen.availWidth/availHeight</code> //窗口可以使用的屏幕的宽度和高度，以像素计 </li>\n<li><code>screen.colorDepth</code> //用户表示颜色的位数，大多数系统采用32位 </li>\n<li><code>window.moveTo(0, 0);</code></li>\n<li><code>window.resizeTo(screen.availWidth, screen.availHeight);</code> //填充用户的屏幕</li>\n</ul>\n<h4 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h4><p><code>location</code>对象：表示载入窗口的URL。<br>常用方法有：</p>\n<ul>\n<li><code>location.href</code> //当前载入页面的完整URL</li>\n<li><code>location.portocol</code> //URL中使用的协议，即双斜杠之前的部分，如http</li>\n<li><code>location.host</code> //服务器的名字，如www.wrox.com</li>\n<li><code>location.hostname</code> //通常等于host，有时会省略前面的www</li>\n<li><code>location.port</code> //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080</li>\n<li><code>location.pathname</code> //URL中主机名后的部分，如/pictures/index.htm</li>\n<li><code>location.search</code> //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx</li>\n<li><code>location.hash</code> //如果URL包含#，返回该符号之后的内容，如#anchor1</li>\n<li><code>location.assign(&quot;http:www.baidu.com&quot;);</code> //同location.href，新地址都会被加到浏览器的历史栈中</li>\n<li><code>location.replace(&quot;http:www.baidu.com&quot;);</code> //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问</li>\n<li><code>location.reload(true | false);</code> //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false</li>\n</ul>\n<h4 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h4><p><code>history</code>对象：浏览器窗口的历史<br>常用方法有：</p>\n<ul>\n<li><code>history.go(-1);</code> //访问浏览器窗口的历史，负数为后退，正数为前进</li>\n<li><code>history.back();</code> //同上</li>\n<li><code>history.forward();</code> //同上</li>\n<li><code>history.length</code> //可以查看历史中的页面数</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"DOM本质\"><a href=\"#DOM本质\" class=\"headerlink\" title=\"DOM本质\"></a>DOM本质</h2><p>DOM（Document Object Model）是浏览器将文档转换成的一个树形对象模型，使之能够识别并且进行js操作。</p>\n<h2 id=\"DOM节点操作\"><a href=\"#DOM节点操作\" class=\"headerlink\" title=\"DOM节点操作\"></a>DOM节点操作</h2><h4 id=\"获取DOM节点\"><a href=\"#获取DOM节点\" class=\"headerlink\" title=\"获取DOM节点\"></a>获取DOM节点</h4><ul>\n<li><code>document.getElementById</code></li>\n<li><code>document.getElementsByTagName</code></li>\n<li><code>document.getElementsByClassName</code></li>\n<li><code>document.querySelectorAll</code></li>\n</ul>\n<h4 id=\"property与attribute\"><a href=\"#property与attribute\" class=\"headerlink\" title=\"property与attribute\"></a>property与attribute</h4><p>虽然property与attribute两者皆可翻译为“属性”，但二者的本质实际上是有很大区别的。</p>\n<ul>\n<li>property是DOM中的属性，是JavaScript里的对象；</li>\n<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>\n</ul>\n<p>例如在html中有一段这样的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">sth</span>=<span class=\"string\">\"whatever\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>我们在js中来获取这个DOM对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.id); <span class=\"comment\">// 'test'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.sth) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure></p>\n<p>由于每一个DOM对象都会有它的默认的基本属性，在创建的时候只会创建这些基本属性，自定义的属性是不会直接放在DOM中的。对比一下的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test-2\"</span> &gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> test_2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test-2'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test_2.value); <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>虽然没有在标签中定义<code>value</code>，但由于它是DOM默认的基本属性，所以在DOM初始化的时候它还是会被创建。由此我们可以得出结论：</p>\n<ul>\n<li>DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。</li>\n<li>如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。</li>\n</ul>\n<p>那么标签上的sth定义在哪里呢？</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-1.png\" alt=\"\"></p>\n<p>也就是说，attributes是属于property的一个子集，它保存了HTML标签上定义的属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(test.attibutes.sth); <span class=\"comment\">// 'sth=\"whatever\"'</span></div></pre></td></tr></table></figure></p>\n<p>由此可以得出：</p>\n<ul>\n<li>HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；</li>\n<li>这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；</li>\n</ul>\n<p>那么，如果我们更改property和attribute的值会出现什么效果呢？执行如下语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.value = <span class=\"string\">'new value of prop'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of prop'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.arrtibutes.value); <span class=\"comment\">// 'value=\"1\"'</span></div></pre></td></tr></table></figure></p>\n<p>如果反过来，效果又是如何呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.attributes.value = <span class=\"string\">'new value of attr'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.value); <span class=\"comment\">// 'new value of attr'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(test.attributes.value); <span class=\"comment\">// 'new value of attr'</span></div></pre></td></tr></table></figure></p>\n<p>此时，页面中的输入栏得到更新，property中的value也发生了变化。此外，执行下面语句也会得到一样的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.attributes.value.nodeValue = <span class=\"string\">'new value of attr'</span>;</div></pre></td></tr></table></figure></p>\n<p>由此，可得出结论：</p>\n<ul>\n<li>property能够从attribute中得到同步；</li>\n<li>attribute不会同步property上的值；</li>\n<li>attribute和property之间的数据绑定是单向的，attribute-&gt;property；</li>\n<li>更改property和attribute上的任意值，都会将更新反映到HTML页面中；</li>\n</ul>\n<h4 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h4><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/dom-2.png\" alt=\"\"></p>\n<p>有关DOM操作，主要注意点在于性能方面的影响，优化DOM操作方法有：</p>\n<ul>\n<li>减少DOM访问次数</li>\n<li>多次访问同一DOM，应该用局部变量缓存该DOM</li>\n<li>尽可能使用querySelector，而不是使用获取HTML集合的API</li>\n<li>注意重排（reflow）和重绘（repaint）</li>\n<li>使用事件委托，减少绑定事件的数量</li>\n</ul>\n<h4 id=\"重排（重构）-amp-重绘\"><a href=\"#重排（重构）-amp-重绘\" class=\"headerlink\" title=\"重排（重构）&amp;重绘\"></a>重排（重构）&amp;重绘</h4><p>重绘并不一定导致重排，比如修改某个元素的颜色，只会导致重绘；而重排之后，浏览器需要重新绘制受重排影响的部分。导致重排的原因有：</p>\n<ul>\n<li>添加或删除DOM元素</li>\n<li>元素位置、大小、内容改变</li>\n<li>浏览器窗口大小改变</li>\n<li>滚动条出现</li>\n</ul>\n<p><strong>最小化重排、重绘的建议：</strong></p>\n<ul>\n<li>不要再修改布局信息的时候，去查询布局信息</li>\n<li>修改一个元素的多个style时，一次性修改，而不是多次，能用css的class解决的，就尽量不用内联样式</li>\n<li>:hover会降低响应速度，在处理很大的列表时，避免使用</li>\n</ul>\n<h2 id=\"BOM操作\"><a href=\"#BOM操作\" class=\"headerlink\" title=\"BOM操作\"></a>BOM操作</h2><p>BOM（Browser Object Model）指的是浏览器对象模型，主要用途：</p>\n<ul>\n<li>检测浏览器的类型</li>\n<li>拆解url的各部分</li>\n</ul>\n<h4 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h4><p><code>navigator</code>对象：包含大量有关Web浏览器的信息，用于检测浏览器及操作系统。<br>常用方法有：</p>\n<ul>\n<li><code>navigator.userAgent</code> //用户代理头的字符串表示</li>\n</ul>\n<h4 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h4><p><code>screen</code>对象：用于获取某些关于用户屏幕的信息。<br>常用方法有：</p>\n<ul>\n<li><code>screen.width/height</code> //屏幕的宽度与高度，以像素计 </li>\n<li><code>screen.availWidth/availHeight</code> //窗口可以使用的屏幕的宽度和高度，以像素计 </li>\n<li><code>screen.colorDepth</code> //用户表示颜色的位数，大多数系统采用32位 </li>\n<li><code>window.moveTo(0, 0);</code></li>\n<li><code>window.resizeTo(screen.availWidth, screen.availHeight);</code> //填充用户的屏幕</li>\n</ul>\n<h4 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h4><p><code>location</code>对象：表示载入窗口的URL。<br>常用方法有：</p>\n<ul>\n<li><code>location.href</code> //当前载入页面的完整URL</li>\n<li><code>location.portocol</code> //URL中使用的协议，即双斜杠之前的部分，如http</li>\n<li><code>location.host</code> //服务器的名字，如www.wrox.com</li>\n<li><code>location.hostname</code> //通常等于host，有时会省略前面的www</li>\n<li><code>location.port</code> //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080</li>\n<li><code>location.pathname</code> //URL中主机名后的部分，如/pictures/index.htm</li>\n<li><code>location.search</code> //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx</li>\n<li><code>location.hash</code> //如果URL包含#，返回该符号之后的内容，如#anchor1</li>\n<li><code>location.assign(&quot;http:www.baidu.com&quot;);</code> //同location.href，新地址都会被加到浏览器的历史栈中</li>\n<li><code>location.replace(&quot;http:www.baidu.com&quot;);</code> //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问</li>\n<li><code>location.reload(true | false);</code> //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false</li>\n</ul>\n<h4 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h4><p><code>history</code>对象：浏览器窗口的历史<br>常用方法有：</p>\n<ul>\n<li><code>history.go(-1);</code> //访问浏览器窗口的历史，负数为后退，正数为前进</li>\n<li><code>history.back();</code> //同上</li>\n<li><code>history.forward();</code> //同上</li>\n<li><code>history.length</code> //可以查看历史中的页面数</li>\n</ul>\n"},{"title":"jQuery源码学习笔记(01)","date":"2017-10-02T05:36:40.000Z","_content":"## 总体架构\n\n#### 自调用匿名函数\n\n```javascript\n(function( window, undefined) {\n  // jquery code\n})(window);\n```\n▼ **使用自调用匿名函数的原因：**\n\n通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，保证jQuery创建的变量不能和导入他的程序所使用的变量发生冲突。\n\n▼ **自调用匿名函数的写法：**\n\n**写法1**\n```javascript\n(function() {\n  // code\n}(window));\n//括号包括了函数参数\n```\n**写法2**\n```javascript\n(function() {\n  // code\n})(window);\n//括号只包括了函数定义\n```\n\n▼ **为什么要传入`window`：**\n\n通过传入window变量，使得window由全局变量变为局部变量，在访问的时候就不需要将作用域链回退到顶层作用域，可以更快的访问。更重要的是，将window作为参数传入，可以在压缩代码时进行优化。\n\n▼ **为什么要在参数列表中增加`undefined`：**\n\n要在自调用匿名函数的作用域内，确保`undefined`是真的未定义，因为`undefined`能够被重写。\n\n#### 代码结构\n\n```javascript\n(function( window, undefined ) {\n  // 构造jQuery对象\n  var jQuery = function( selector, context ) {\n        return new jQuery.fn.init( selector, context, rootjQuery );\n      }\n  // 工具函数 Utilities\n  // 异步队列 Deferred\n  // 浏览器测试 Support\n  // 数据缓存 Data\n  // 队列 queue\n  // 属性操作 Attribute\n  // 事件处理 Event\n  // 选择器 Sizzle\n  // DOM遍历\n  // DOM操作\n  // CSS操作\n  // 异步请求 Ajax\n  // 动画 FX\n  // 坐标和大小\n  window.jQuery = window.$ = jQuery;\n})(window);\n```\n\n#### jQuery对象的构建方法\n\n在平时我们构造函数的时候一般是这样实现的：\n```javascript\nvar aQuery = function(selector, context) {\n  // 构造函数\n}\n\naQuery.prototype = {\n  // 原型\n  name: function() {  },\n  age: function() {  }\n}\n\nvar a = new aQuery(); // 实例化\n\na.name(); // 调用\n```\n而在使用jQuery的时候，并不需要`new`，而是可以直接调用函数方法。\n```javascript\n$().find().css();\n```\n所以可以看到，调用jQuery的时候返回的就是一个函数的实例。\n```javascript\nvar aQuery = function(selector, context) {\n  return new aQuery();\n} // 虽然返回了实例，但是会造成死循环\n\naQuery.prototype = {\n  name: function() {  },\n  age: function() {  }\n}\n```\n当我们用上面的方法来执行`aQuery()`，会报错。那么应该如何返回一个正确的实例呢？我们可以利用工厂模式来创建对象，并把这个方法放到原型中。\n```javascript\nvar aQuery = function(selector, context) {\n  return aQuery.prototype.init();\n}\n\naQuery.prototype = {\n  init: functionn() {\n    return this;\n  },\n  name: function() {},\n  age: function() {}\n}\n```\n此时执行`aQuery()`就会返回一个正确的实例，而在init函数中的this,指向的是aQuery这个对象。如果我们要把init函数也当作一个构造器，那如何让内部的this指向init呢？\n```javascript\njQuery = function( selector, context ) {\n  // The jQuery object is actually just the init constructor 'enhanced'\n  return new jQuery.fn.init( selector, context, rootjQuery );\n},\n```\n通过实例init函数，每次都构建新的init实例对象，来分隔this，这样在init内部使用的this的指向就会变成了init函数本身。但是这样一来，执行`aQuery()`后返回的就是init()函数的实例对象，绑定在aQuery原型对象上的方法就无法通过`aQuery().name()`这种方式去调用了。\n\n如何做到既能隔离作用域还能使用jQuery原型对象的作用域，能在返回的实例中访问jQuery的原型对象呢？\n```javascript\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n```\n通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说，jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。\n```javascript\nvar aQuery = function(selector, context) {\n  return new aQuery.prototype.init();\n}\n\naQuery.prototype = {\n  init: function() {\n    return this;\n  },\n  name: 'xm',\n  getName: function() {\n    return this.name;\n  }\n}\n\naQuery.prototype.init.prototype = aQuery.prototype;\n\nconsole.log(aQuery().getName()); //xm\n```\n\n#### jQuery方法的调用方式\n\n▼ **链式调用：**\n\n**链式调用的原理：**通过简单拓展原型方法并通过`return this`的形式来实现跨浏览器的链式调用。\n```javascript\naQuery.prototype = {\n  init: function() {\n    return this;\n  },\n  name: function() {\n    return this;\n  }\n}\n```\n**优点：**节省代码量，提高代码的效率，代码看起来更优雅。\n**缺点：**由于返回的都是对象本身，所以没有返回值，不一定在任何环境下都适用\n\n▼ **插件接口：**\n\n从封装的角度讲，为了给jQuery添加属性方法，或是给开发者拓展方法，jQuery提供了`jQuery.fn.extend()`这个接口，来对对象增加方法。\n\n#### $.extend()\n\n```javascript\njQuery.extend = jQuery.fn.extend = function() {\n  var options, name, src, copy, copyIsArray, clone,\n      target = arguments[0] || {}, // 默认第一个参数为目标对象，对应用法：$.extend(obj1, obj2);\n      i = 1, // 标记被合并对象的起始位置\n      length = arguments.length,\n      deep = false; // 判断是否要深拷贝，对应用法：$.extend(true, obj1, obj2);\n\n  // Handle a deep copy situation\n  // 判断target的类型，如果是布尔值，则target和被标记对象的位置都将被改变\n  if ( typeof target === \"boolean\" ) {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  // 在target类型不是对象或函数，则将target看成空对象\n  if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  // 当只传一个参数的时候，目标对象变为jQuery，传入的参数合并到jQuery对象中\n  if ( length === i ) {\n    target = this;\n    --i;\n  }\n\n  for ( ; i < length; i++ ) {\n    // Only deal with non-null/undefined values\n    if ( (options = arguments[ i ]) != null ) {\n      // Extend the base object\n      for ( name in options ) {\n        src = target[ name ]; // 目标对象的属性\n        copy = options[ name ]; // 被合并对象的属性\n\n        // Prevent never-ending loop\n        // 当对象属性一致的时候，跳过此属性进行下一个属性的判断\n        if ( target === copy ) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        // 深拷贝&&copy不是null或者undefined&&copy是“纯粹的”对象或数组\n        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n          // 如果copy是一个数组\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && jQuery.isArray(src) ? src : [];// 该字段用于保存合并目标的属性\n          } else {\n            clone = src && jQuery.isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          // 使用了递归\n          target[ name ] = jQuery.extend( deep, clone, copy );\n\n        // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n\n}\n\n```\n\n#### 细节知识\n\n`jQuery.isPlainObject()`：用于判断指定参数是否是一个纯粹的对象。纯粹的对象指的是该对象是通过`{}`或`new Object`创建的。\n\n**示例：**\n```javascript\n在当前页面内追加换行标签和指定的HTML内容\nfunction w( html ){\n    document.body.innerHTML += \"<br/>\" + html;\n}\n\n\n\nw( $.isPlainObject( { } ) ); // true\nw( $.isPlainObject( new Object() ) ); // true\nw( $.isPlainObject( { name: \"CodePlayer\"} ) ); // true\nw( $.isPlainObject( { sayHi: function(){} } ) ); // true\n\n\nw( $.isPlainObject( \"CodePlayer\" ) ); // false\nw( $.isPlainObject( true ) ); // false\nw( $.isPlainObject( 12 ) ); // false\nw( $.isPlainObject( [ ] ) ); // false\nw( $.isPlainObject( function(){ } ) ); // false\nw( $.isPlainObject( document.location ) ); // false(在IE中返回true)\n\nfunction Person(){\n    this.name = \"张三\";\n}\nw( $.isPlainObject( new Person() ) ); // false\n```\n\n学习参考：\n[[原创] jQuery1.6.1源码分析系列（停止更新）](http://www.cnblogs.com/nuysoft/archive/2011/11/14/2248023.html)\n[jQuery源码分析系列](http://www.cnblogs.com/aaronjs/p/3279314.html)","source":"_posts/17-10-02-28.md","raw":"---\ntitle: jQuery源码学习笔记(01)\ndate: 2017-10-02 13:36:40\ntags:\n---\n## 总体架构\n\n#### 自调用匿名函数\n\n```javascript\n(function( window, undefined) {\n  // jquery code\n})(window);\n```\n▼ **使用自调用匿名函数的原因：**\n\n通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，保证jQuery创建的变量不能和导入他的程序所使用的变量发生冲突。\n\n▼ **自调用匿名函数的写法：**\n\n**写法1**\n```javascript\n(function() {\n  // code\n}(window));\n//括号包括了函数参数\n```\n**写法2**\n```javascript\n(function() {\n  // code\n})(window);\n//括号只包括了函数定义\n```\n\n▼ **为什么要传入`window`：**\n\n通过传入window变量，使得window由全局变量变为局部变量，在访问的时候就不需要将作用域链回退到顶层作用域，可以更快的访问。更重要的是，将window作为参数传入，可以在压缩代码时进行优化。\n\n▼ **为什么要在参数列表中增加`undefined`：**\n\n要在自调用匿名函数的作用域内，确保`undefined`是真的未定义，因为`undefined`能够被重写。\n\n#### 代码结构\n\n```javascript\n(function( window, undefined ) {\n  // 构造jQuery对象\n  var jQuery = function( selector, context ) {\n        return new jQuery.fn.init( selector, context, rootjQuery );\n      }\n  // 工具函数 Utilities\n  // 异步队列 Deferred\n  // 浏览器测试 Support\n  // 数据缓存 Data\n  // 队列 queue\n  // 属性操作 Attribute\n  // 事件处理 Event\n  // 选择器 Sizzle\n  // DOM遍历\n  // DOM操作\n  // CSS操作\n  // 异步请求 Ajax\n  // 动画 FX\n  // 坐标和大小\n  window.jQuery = window.$ = jQuery;\n})(window);\n```\n\n#### jQuery对象的构建方法\n\n在平时我们构造函数的时候一般是这样实现的：\n```javascript\nvar aQuery = function(selector, context) {\n  // 构造函数\n}\n\naQuery.prototype = {\n  // 原型\n  name: function() {  },\n  age: function() {  }\n}\n\nvar a = new aQuery(); // 实例化\n\na.name(); // 调用\n```\n而在使用jQuery的时候，并不需要`new`，而是可以直接调用函数方法。\n```javascript\n$().find().css();\n```\n所以可以看到，调用jQuery的时候返回的就是一个函数的实例。\n```javascript\nvar aQuery = function(selector, context) {\n  return new aQuery();\n} // 虽然返回了实例，但是会造成死循环\n\naQuery.prototype = {\n  name: function() {  },\n  age: function() {  }\n}\n```\n当我们用上面的方法来执行`aQuery()`，会报错。那么应该如何返回一个正确的实例呢？我们可以利用工厂模式来创建对象，并把这个方法放到原型中。\n```javascript\nvar aQuery = function(selector, context) {\n  return aQuery.prototype.init();\n}\n\naQuery.prototype = {\n  init: functionn() {\n    return this;\n  },\n  name: function() {},\n  age: function() {}\n}\n```\n此时执行`aQuery()`就会返回一个正确的实例，而在init函数中的this,指向的是aQuery这个对象。如果我们要把init函数也当作一个构造器，那如何让内部的this指向init呢？\n```javascript\njQuery = function( selector, context ) {\n  // The jQuery object is actually just the init constructor 'enhanced'\n  return new jQuery.fn.init( selector, context, rootjQuery );\n},\n```\n通过实例init函数，每次都构建新的init实例对象，来分隔this，这样在init内部使用的this的指向就会变成了init函数本身。但是这样一来，执行`aQuery()`后返回的就是init()函数的实例对象，绑定在aQuery原型对象上的方法就无法通过`aQuery().name()`这种方式去调用了。\n\n如何做到既能隔离作用域还能使用jQuery原型对象的作用域，能在返回的实例中访问jQuery的原型对象呢？\n```javascript\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n```\n通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说，jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。\n```javascript\nvar aQuery = function(selector, context) {\n  return new aQuery.prototype.init();\n}\n\naQuery.prototype = {\n  init: function() {\n    return this;\n  },\n  name: 'xm',\n  getName: function() {\n    return this.name;\n  }\n}\n\naQuery.prototype.init.prototype = aQuery.prototype;\n\nconsole.log(aQuery().getName()); //xm\n```\n\n#### jQuery方法的调用方式\n\n▼ **链式调用：**\n\n**链式调用的原理：**通过简单拓展原型方法并通过`return this`的形式来实现跨浏览器的链式调用。\n```javascript\naQuery.prototype = {\n  init: function() {\n    return this;\n  },\n  name: function() {\n    return this;\n  }\n}\n```\n**优点：**节省代码量，提高代码的效率，代码看起来更优雅。\n**缺点：**由于返回的都是对象本身，所以没有返回值，不一定在任何环境下都适用\n\n▼ **插件接口：**\n\n从封装的角度讲，为了给jQuery添加属性方法，或是给开发者拓展方法，jQuery提供了`jQuery.fn.extend()`这个接口，来对对象增加方法。\n\n#### $.extend()\n\n```javascript\njQuery.extend = jQuery.fn.extend = function() {\n  var options, name, src, copy, copyIsArray, clone,\n      target = arguments[0] || {}, // 默认第一个参数为目标对象，对应用法：$.extend(obj1, obj2);\n      i = 1, // 标记被合并对象的起始位置\n      length = arguments.length,\n      deep = false; // 判断是否要深拷贝，对应用法：$.extend(true, obj1, obj2);\n\n  // Handle a deep copy situation\n  // 判断target的类型，如果是布尔值，则target和被标记对象的位置都将被改变\n  if ( typeof target === \"boolean\" ) {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  // 在target类型不是对象或函数，则将target看成空对象\n  if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  // 当只传一个参数的时候，目标对象变为jQuery，传入的参数合并到jQuery对象中\n  if ( length === i ) {\n    target = this;\n    --i;\n  }\n\n  for ( ; i < length; i++ ) {\n    // Only deal with non-null/undefined values\n    if ( (options = arguments[ i ]) != null ) {\n      // Extend the base object\n      for ( name in options ) {\n        src = target[ name ]; // 目标对象的属性\n        copy = options[ name ]; // 被合并对象的属性\n\n        // Prevent never-ending loop\n        // 当对象属性一致的时候，跳过此属性进行下一个属性的判断\n        if ( target === copy ) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        // 深拷贝&&copy不是null或者undefined&&copy是“纯粹的”对象或数组\n        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n          // 如果copy是一个数组\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && jQuery.isArray(src) ? src : [];// 该字段用于保存合并目标的属性\n          } else {\n            clone = src && jQuery.isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          // 使用了递归\n          target[ name ] = jQuery.extend( deep, clone, copy );\n\n        // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n\n}\n\n```\n\n#### 细节知识\n\n`jQuery.isPlainObject()`：用于判断指定参数是否是一个纯粹的对象。纯粹的对象指的是该对象是通过`{}`或`new Object`创建的。\n\n**示例：**\n```javascript\n在当前页面内追加换行标签和指定的HTML内容\nfunction w( html ){\n    document.body.innerHTML += \"<br/>\" + html;\n}\n\n\n\nw( $.isPlainObject( { } ) ); // true\nw( $.isPlainObject( new Object() ) ); // true\nw( $.isPlainObject( { name: \"CodePlayer\"} ) ); // true\nw( $.isPlainObject( { sayHi: function(){} } ) ); // true\n\n\nw( $.isPlainObject( \"CodePlayer\" ) ); // false\nw( $.isPlainObject( true ) ); // false\nw( $.isPlainObject( 12 ) ); // false\nw( $.isPlainObject( [ ] ) ); // false\nw( $.isPlainObject( function(){ } ) ); // false\nw( $.isPlainObject( document.location ) ); // false(在IE中返回true)\n\nfunction Person(){\n    this.name = \"张三\";\n}\nw( $.isPlainObject( new Person() ) ); // false\n```\n\n学习参考：\n[[原创] jQuery1.6.1源码分析系列（停止更新）](http://www.cnblogs.com/nuysoft/archive/2011/11/14/2248023.html)\n[jQuery源码分析系列](http://www.cnblogs.com/aaronjs/p/3279314.html)","slug":"17-10-02-28","published":1,"updated":"2017-10-10T12:52:33.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2sv000lbguj31iv9y69","content":"<h2 id=\"总体架构\"><a href=\"#总体架构\" class=\"headerlink\" title=\"总体架构\"></a>总体架构</h2><h4 id=\"自调用匿名函数\"><a href=\"#自调用匿名函数\" class=\"headerlink\" title=\"自调用匿名函数\"></a>自调用匿名函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window, undefined</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// jquery code</span></div><div class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</div></pre></td></tr></table></figure>\n<p>▼ <strong>使用自调用匿名函数的原因：</strong></p>\n<p>通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，保证jQuery创建的变量不能和导入他的程序所使用的变量发生冲突。</p>\n<p>▼ <strong>自调用匿名函数的写法：</strong></p>\n<p><strong>写法1</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;(<span class=\"built_in\">window</span>));</div><div class=\"line\"><span class=\"comment\">//括号包括了函数参数</span></div></pre></td></tr></table></figure></p>\n<p><strong>写法2</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</div><div class=\"line\"><span class=\"comment\">//括号只包括了函数定义</span></div></pre></td></tr></table></figure></p>\n<p>▼ <strong>为什么要传入<code>window</code>：</strong></p>\n<p>通过传入window变量，使得window由全局变量变为局部变量，在访问的时候就不需要将作用域链回退到顶层作用域，可以更快的访问。更重要的是，将window作为参数传入，可以在压缩代码时进行优化。</p>\n<p>▼ <strong>为什么要在参数列表中增加<code>undefined</code>：</strong></p>\n<p>要在自调用匿名函数的作用域内，确保<code>undefined</code>是真的未定义，因为<code>undefined</code>能够被重写。</p>\n<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window, undefined </span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 构造jQuery对象</span></div><div class=\"line\">  <span class=\"keyword\">var</span> jQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> selector, context </span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class=\"line\">      &#125;</div><div class=\"line\">  <span class=\"comment\">// 工具函数 Utilities</span></div><div class=\"line\">  <span class=\"comment\">// 异步队列 Deferred</span></div><div class=\"line\">  <span class=\"comment\">// 浏览器测试 Support</span></div><div class=\"line\">  <span class=\"comment\">// 数据缓存 Data</span></div><div class=\"line\">  <span class=\"comment\">// 队列 queue</span></div><div class=\"line\">  <span class=\"comment\">// 属性操作 Attribute</span></div><div class=\"line\">  <span class=\"comment\">// 事件处理 Event</span></div><div class=\"line\">  <span class=\"comment\">// 选择器 Sizzle</span></div><div class=\"line\">  <span class=\"comment\">// DOM遍历</span></div><div class=\"line\">  <span class=\"comment\">// DOM操作</span></div><div class=\"line\">  <span class=\"comment\">// CSS操作</span></div><div class=\"line\">  <span class=\"comment\">// 异步请求 Ajax</span></div><div class=\"line\">  <span class=\"comment\">// 动画 FX</span></div><div class=\"line\">  <span class=\"comment\">// 坐标和大小</span></div><div class=\"line\">  <span class=\"built_in\">window</span>.jQuery = <span class=\"built_in\">window</span>.$ = jQuery;</div><div class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"jQuery对象的构建方法\"><a href=\"#jQuery对象的构建方法\" class=\"headerlink\" title=\"jQuery对象的构建方法\"></a>jQuery对象的构建方法</h4><p>在平时我们构造函数的时候一般是这样实现的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 构造函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"comment\">// 原型</span></div><div class=\"line\">  name: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> aQuery(); <span class=\"comment\">// 实例化</span></div><div class=\"line\"></div><div class=\"line\">a.name(); <span class=\"comment\">// 调用</span></div></pre></td></tr></table></figure></p>\n<p>而在使用jQuery的时候，并不需要<code>new</code>，而是可以直接调用函数方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$().find().css();</div></pre></td></tr></table></figure></p>\n<p>所以可以看到，调用jQuery的时候返回的就是一个函数的实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> aQuery();</div><div class=\"line\">&#125; <span class=\"comment\">// 虽然返回了实例，但是会造成死循环</span></div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们用上面的方法来执行<code>aQuery()</code>，会报错。那么应该如何返回一个正确的实例呢？我们可以利用工厂模式来创建对象，并把这个方法放到原型中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> aQuery.prototype.init();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">init</span>: functionn() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此时执行<code>aQuery()</code>就会返回一个正确的实例，而在init函数中的this,指向的是aQuery这个对象。如果我们要把init函数也当作一个构造器，那如何让内部的this指向init呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> selector, context </span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// The jQuery object is actually just the init constructor 'enhanced'</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure></p>\n<p>通过实例init函数，每次都构建新的init实例对象，来分隔this，这样在init内部使用的this的指向就会变成了init函数本身。但是这样一来，执行<code>aQuery()</code>后返回的就是init()函数的实例对象，绑定在aQuery原型对象上的方法就无法通过<code>aQuery().name()</code>这种方式去调用了。</p>\n<p>如何做到既能隔离作用域还能使用jQuery原型对象的作用域，能在返回的实例中访问jQuery的原型对象呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Give the init function the jQuery prototype for later instantiation</span></div><div class=\"line\">jQuery.fn.init.prototype = jQuery.fn;</div></pre></td></tr></table></figure></p>\n<p>通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说，jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> aQuery.prototype.init();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xm'</span>,</div><div class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype.init.prototype = aQuery.prototype;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(aQuery().getName()); <span class=\"comment\">//xm</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"jQuery方法的调用方式\"><a href=\"#jQuery方法的调用方式\" class=\"headerlink\" title=\"jQuery方法的调用方式\"></a>jQuery方法的调用方式</h4><p>▼ <strong>链式调用：</strong></p>\n<p><strong>链式调用的原理：</strong>通过简单拓展原型方法并通过<code>return this</code>的形式来实现跨浏览器的链式调用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong>节省代码量，提高代码的效率，代码看起来更优雅。<br><strong>缺点：</strong>由于返回的都是对象本身，所以没有返回值，不一定在任何环境下都适用</p>\n<p>▼ <strong>插件接口：</strong></p>\n<p>从封装的角度讲，为了给jQuery添加属性方法，或是给开发者拓展方法，jQuery提供了<code>jQuery.fn.extend()</code>这个接口，来对对象增加方法。</p>\n<h4 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"$.extend()\"></a>$.extend()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.extend = jQuery.fn.extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> options, name, src, copy, copyIsArray, clone,</div><div class=\"line\">      target = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] || &#123;&#125;, <span class=\"comment\">// 默认第一个参数为目标对象，对应用法：$.extend(obj1, obj2);</span></div><div class=\"line\">      i = <span class=\"number\">1</span>, <span class=\"comment\">// 标记被合并对象的起始位置</span></div><div class=\"line\">      length = <span class=\"built_in\">arguments</span>.length,</div><div class=\"line\">      deep = <span class=\"literal\">false</span>; <span class=\"comment\">// 判断是否要深拷贝，对应用法：$.extend(true, obj1, obj2);</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Handle a deep copy situation</span></div><div class=\"line\">  <span class=\"comment\">// 判断target的类型，如果是布尔值，则target和被标记对象的位置都将被改变</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> target === <span class=\"string\">\"boolean\"</span> ) &#123;</div><div class=\"line\">    deep = target;</div><div class=\"line\">    target = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] || &#123;&#125;;</div><div class=\"line\">    <span class=\"comment\">// skip the boolean and the target</span></div><div class=\"line\">    i = <span class=\"number\">2</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Handle case when target is a string or something (possible in deep copy)</span></div><div class=\"line\">  <span class=\"comment\">// 在target类型不是对象或函数，则将target看成空对象</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> target !== <span class=\"string\">\"object\"</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</div><div class=\"line\">    target = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// extend jQuery itself if only one argument is passed</span></div><div class=\"line\">  <span class=\"comment\">// 当只传一个参数的时候，目标对象变为jQuery，传入的参数合并到jQuery对象中</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( length === i ) &#123;</div><div class=\"line\">    target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    --i;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class=\"line\">    <span class=\"comment\">// Only deal with non-null/undefined values</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ( (options = <span class=\"built_in\">arguments</span>[ i ]) != <span class=\"literal\">null</span> ) &#123;</div><div class=\"line\">      <span class=\"comment\">// Extend the base object</span></div><div class=\"line\">      <span class=\"keyword\">for</span> ( name <span class=\"keyword\">in</span> options ) &#123;</div><div class=\"line\">        src = target[ name ]; <span class=\"comment\">// 目标对象的属性</span></div><div class=\"line\">        copy = options[ name ]; <span class=\"comment\">// 被合并对象的属性</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Prevent never-ending loop</span></div><div class=\"line\">        <span class=\"comment\">// 当对象属性一致的时候，跳过此属性进行下一个属性的判断</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ( target === copy ) &#123;</div><div class=\"line\">          <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Recurse if we're merging plain objects or arrays</span></div><div class=\"line\">        <span class=\"comment\">// 深拷贝&amp;&amp;copy不是null或者undefined&amp;&amp;copy是“纯粹的”对象或数组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123;</div><div class=\"line\">          <span class=\"comment\">// 如果copy是一个数组</span></div><div class=\"line\">          <span class=\"keyword\">if</span> ( copyIsArray ) &#123;</div><div class=\"line\">            copyIsArray = <span class=\"literal\">false</span>;</div><div class=\"line\">            clone = src &amp;&amp; jQuery.isArray(src) ? src : [];<span class=\"comment\">// 该字段用于保存合并目标的属性</span></div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</div><div class=\"line\">          &#125;</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">// Never move original objects, clone them</span></div><div class=\"line\">          <span class=\"comment\">// 使用了递归</span></div><div class=\"line\">          target[ name ] = jQuery.extend( deep, clone, copy );</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Don't bring in undefined values</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( copy !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">          target[ name ] = copy;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Return the modified object</span></div><div class=\"line\">  <span class=\"keyword\">return</span> target;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"细节知识\"><a href=\"#细节知识\" class=\"headerlink\" title=\"细节知识\"></a>细节知识</h4><p><code>jQuery.isPlainObject()</code>：用于判断指定参数是否是一个纯粹的对象。纯粹的对象指的是该对象是通过<code>{}</code>或<code>new Object</code>创建的。</p>\n<p><strong>示例：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">在当前页面内追加换行标签和指定的HTML内容</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">w</span>(<span class=\"params\"> html </span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.body.innerHTML += <span class=\"string\">\"&lt;br/&gt;\"</span> + html;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">w( $.isPlainObject( &#123; &#125; ) ); <span class=\"comment\">// true</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() ) ); <span class=\"comment\">// true</span></div><div class=\"line\">w( $.isPlainObject( &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"CodePlayer\"</span>&#125; ) ); <span class=\"comment\">// true</span></div><div class=\"line\">w( $.isPlainObject( &#123; <span class=\"attr\">sayHi</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; &#125; ) ); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">w( $.isPlainObject( <span class=\"string\">\"CodePlayer\"</span> ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"literal\">true</span> ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"number\">12</span> ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( [ ] ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; &#125; ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"built_in\">document</span>.location ) ); <span class=\"comment\">// false(在IE中返回true)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">\"张三\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">w( $.isPlainObject( <span class=\"keyword\">new</span> Person() ) ); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>学习参考：<br><a href=\"http://www.cnblogs.com/nuysoft/archive/2011/11/14/2248023.html\" target=\"_blank\" rel=\"external\">[原创] jQuery1.6.1源码分析系列（停止更新）</a><br><a href=\"http://www.cnblogs.com/aaronjs/p/3279314.html\" target=\"_blank\" rel=\"external\">jQuery源码分析系列</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"总体架构\"><a href=\"#总体架构\" class=\"headerlink\" title=\"总体架构\"></a>总体架构</h2><h4 id=\"自调用匿名函数\"><a href=\"#自调用匿名函数\" class=\"headerlink\" title=\"自调用匿名函数\"></a>自调用匿名函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window, undefined</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// jquery code</span></div><div class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</div></pre></td></tr></table></figure>\n<p>▼ <strong>使用自调用匿名函数的原因：</strong></p>\n<p>通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，保证jQuery创建的变量不能和导入他的程序所使用的变量发生冲突。</p>\n<p>▼ <strong>自调用匿名函数的写法：</strong></p>\n<p><strong>写法1</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;(<span class=\"built_in\">window</span>));</div><div class=\"line\"><span class=\"comment\">//括号包括了函数参数</span></div></pre></td></tr></table></figure></p>\n<p><strong>写法2</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</div><div class=\"line\"><span class=\"comment\">//括号只包括了函数定义</span></div></pre></td></tr></table></figure></p>\n<p>▼ <strong>为什么要传入<code>window</code>：</strong></p>\n<p>通过传入window变量，使得window由全局变量变为局部变量，在访问的时候就不需要将作用域链回退到顶层作用域，可以更快的访问。更重要的是，将window作为参数传入，可以在压缩代码时进行优化。</p>\n<p>▼ <strong>为什么要在参数列表中增加<code>undefined</code>：</strong></p>\n<p>要在自调用匿名函数的作用域内，确保<code>undefined</code>是真的未定义，因为<code>undefined</code>能够被重写。</p>\n<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window, undefined </span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 构造jQuery对象</span></div><div class=\"line\">  <span class=\"keyword\">var</span> jQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> selector, context </span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class=\"line\">      &#125;</div><div class=\"line\">  <span class=\"comment\">// 工具函数 Utilities</span></div><div class=\"line\">  <span class=\"comment\">// 异步队列 Deferred</span></div><div class=\"line\">  <span class=\"comment\">// 浏览器测试 Support</span></div><div class=\"line\">  <span class=\"comment\">// 数据缓存 Data</span></div><div class=\"line\">  <span class=\"comment\">// 队列 queue</span></div><div class=\"line\">  <span class=\"comment\">// 属性操作 Attribute</span></div><div class=\"line\">  <span class=\"comment\">// 事件处理 Event</span></div><div class=\"line\">  <span class=\"comment\">// 选择器 Sizzle</span></div><div class=\"line\">  <span class=\"comment\">// DOM遍历</span></div><div class=\"line\">  <span class=\"comment\">// DOM操作</span></div><div class=\"line\">  <span class=\"comment\">// CSS操作</span></div><div class=\"line\">  <span class=\"comment\">// 异步请求 Ajax</span></div><div class=\"line\">  <span class=\"comment\">// 动画 FX</span></div><div class=\"line\">  <span class=\"comment\">// 坐标和大小</span></div><div class=\"line\">  <span class=\"built_in\">window</span>.jQuery = <span class=\"built_in\">window</span>.$ = jQuery;</div><div class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"jQuery对象的构建方法\"><a href=\"#jQuery对象的构建方法\" class=\"headerlink\" title=\"jQuery对象的构建方法\"></a>jQuery对象的构建方法</h4><p>在平时我们构造函数的时候一般是这样实现的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 构造函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"comment\">// 原型</span></div><div class=\"line\">  name: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> aQuery(); <span class=\"comment\">// 实例化</span></div><div class=\"line\"></div><div class=\"line\">a.name(); <span class=\"comment\">// 调用</span></div></pre></td></tr></table></figure></p>\n<p>而在使用jQuery的时候，并不需要<code>new</code>，而是可以直接调用函数方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$().find().css();</div></pre></td></tr></table></figure></p>\n<p>所以可以看到，调用jQuery的时候返回的就是一个函数的实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> aQuery();</div><div class=\"line\">&#125; <span class=\"comment\">// 虽然返回了实例，但是会造成死循环</span></div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们用上面的方法来执行<code>aQuery()</code>，会报错。那么应该如何返回一个正确的实例呢？我们可以利用工厂模式来创建对象，并把这个方法放到原型中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> aQuery.prototype.init();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">init</span>: functionn() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此时执行<code>aQuery()</code>就会返回一个正确的实例，而在init函数中的this,指向的是aQuery这个对象。如果我们要把init函数也当作一个构造器，那如何让内部的this指向init呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> selector, context </span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// The jQuery object is actually just the init constructor 'enhanced'</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure></p>\n<p>通过实例init函数，每次都构建新的init实例对象，来分隔this，这样在init内部使用的this的指向就会变成了init函数本身。但是这样一来，执行<code>aQuery()</code>后返回的就是init()函数的实例对象，绑定在aQuery原型对象上的方法就无法通过<code>aQuery().name()</code>这种方式去调用了。</p>\n<p>如何做到既能隔离作用域还能使用jQuery原型对象的作用域，能在返回的实例中访问jQuery的原型对象呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Give the init function the jQuery prototype for later instantiation</span></div><div class=\"line\">jQuery.fn.init.prototype = jQuery.fn;</div></pre></td></tr></table></figure></p>\n<p>通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说，jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">selector, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> aQuery.prototype.init();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xm'</span>,</div><div class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">aQuery.prototype.init.prototype = aQuery.prototype;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(aQuery().getName()); <span class=\"comment\">//xm</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"jQuery方法的调用方式\"><a href=\"#jQuery方法的调用方式\" class=\"headerlink\" title=\"jQuery方法的调用方式\"></a>jQuery方法的调用方式</h4><p>▼ <strong>链式调用：</strong></p>\n<p><strong>链式调用的原理：</strong>通过简单拓展原型方法并通过<code>return this</code>的形式来实现跨浏览器的链式调用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">aQuery.prototype = &#123;</div><div class=\"line\">  <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong>节省代码量，提高代码的效率，代码看起来更优雅。<br><strong>缺点：</strong>由于返回的都是对象本身，所以没有返回值，不一定在任何环境下都适用</p>\n<p>▼ <strong>插件接口：</strong></p>\n<p>从封装的角度讲，为了给jQuery添加属性方法，或是给开发者拓展方法，jQuery提供了<code>jQuery.fn.extend()</code>这个接口，来对对象增加方法。</p>\n<h4 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"$.extend()\"></a>$.extend()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.extend = jQuery.fn.extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> options, name, src, copy, copyIsArray, clone,</div><div class=\"line\">      target = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] || &#123;&#125;, <span class=\"comment\">// 默认第一个参数为目标对象，对应用法：$.extend(obj1, obj2);</span></div><div class=\"line\">      i = <span class=\"number\">1</span>, <span class=\"comment\">// 标记被合并对象的起始位置</span></div><div class=\"line\">      length = <span class=\"built_in\">arguments</span>.length,</div><div class=\"line\">      deep = <span class=\"literal\">false</span>; <span class=\"comment\">// 判断是否要深拷贝，对应用法：$.extend(true, obj1, obj2);</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Handle a deep copy situation</span></div><div class=\"line\">  <span class=\"comment\">// 判断target的类型，如果是布尔值，则target和被标记对象的位置都将被改变</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> target === <span class=\"string\">\"boolean\"</span> ) &#123;</div><div class=\"line\">    deep = target;</div><div class=\"line\">    target = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] || &#123;&#125;;</div><div class=\"line\">    <span class=\"comment\">// skip the boolean and the target</span></div><div class=\"line\">    i = <span class=\"number\">2</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Handle case when target is a string or something (possible in deep copy)</span></div><div class=\"line\">  <span class=\"comment\">// 在target类型不是对象或函数，则将target看成空对象</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> target !== <span class=\"string\">\"object\"</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</div><div class=\"line\">    target = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// extend jQuery itself if only one argument is passed</span></div><div class=\"line\">  <span class=\"comment\">// 当只传一个参数的时候，目标对象变为jQuery，传入的参数合并到jQuery对象中</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( length === i ) &#123;</div><div class=\"line\">    target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    --i;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class=\"line\">    <span class=\"comment\">// Only deal with non-null/undefined values</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ( (options = <span class=\"built_in\">arguments</span>[ i ]) != <span class=\"literal\">null</span> ) &#123;</div><div class=\"line\">      <span class=\"comment\">// Extend the base object</span></div><div class=\"line\">      <span class=\"keyword\">for</span> ( name <span class=\"keyword\">in</span> options ) &#123;</div><div class=\"line\">        src = target[ name ]; <span class=\"comment\">// 目标对象的属性</span></div><div class=\"line\">        copy = options[ name ]; <span class=\"comment\">// 被合并对象的属性</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Prevent never-ending loop</span></div><div class=\"line\">        <span class=\"comment\">// 当对象属性一致的时候，跳过此属性进行下一个属性的判断</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ( target === copy ) &#123;</div><div class=\"line\">          <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Recurse if we're merging plain objects or arrays</span></div><div class=\"line\">        <span class=\"comment\">// 深拷贝&amp;&amp;copy不是null或者undefined&amp;&amp;copy是“纯粹的”对象或数组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123;</div><div class=\"line\">          <span class=\"comment\">// 如果copy是一个数组</span></div><div class=\"line\">          <span class=\"keyword\">if</span> ( copyIsArray ) &#123;</div><div class=\"line\">            copyIsArray = <span class=\"literal\">false</span>;</div><div class=\"line\">            clone = src &amp;&amp; jQuery.isArray(src) ? src : [];<span class=\"comment\">// 该字段用于保存合并目标的属性</span></div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</div><div class=\"line\">          &#125;</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">// Never move original objects, clone them</span></div><div class=\"line\">          <span class=\"comment\">// 使用了递归</span></div><div class=\"line\">          target[ name ] = jQuery.extend( deep, clone, copy );</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Don't bring in undefined values</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( copy !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">          target[ name ] = copy;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Return the modified object</span></div><div class=\"line\">  <span class=\"keyword\">return</span> target;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"细节知识\"><a href=\"#细节知识\" class=\"headerlink\" title=\"细节知识\"></a>细节知识</h4><p><code>jQuery.isPlainObject()</code>：用于判断指定参数是否是一个纯粹的对象。纯粹的对象指的是该对象是通过<code>{}</code>或<code>new Object</code>创建的。</p>\n<p><strong>示例：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">在当前页面内追加换行标签和指定的HTML内容</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">w</span>(<span class=\"params\"> html </span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.body.innerHTML += <span class=\"string\">\"&lt;br/&gt;\"</span> + html;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">w( $.isPlainObject( &#123; &#125; ) ); <span class=\"comment\">// true</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() ) ); <span class=\"comment\">// true</span></div><div class=\"line\">w( $.isPlainObject( &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"CodePlayer\"</span>&#125; ) ); <span class=\"comment\">// true</span></div><div class=\"line\">w( $.isPlainObject( &#123; <span class=\"attr\">sayHi</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; &#125; ) ); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">w( $.isPlainObject( <span class=\"string\">\"CodePlayer\"</span> ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"literal\">true</span> ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"number\">12</span> ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( [ ] ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; &#125; ) ); <span class=\"comment\">// false</span></div><div class=\"line\">w( $.isPlainObject( <span class=\"built_in\">document</span>.location ) ); <span class=\"comment\">// false(在IE中返回true)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">\"张三\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">w( $.isPlainObject( <span class=\"keyword\">new</span> Person() ) ); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>学习参考：<br><a href=\"http://www.cnblogs.com/nuysoft/archive/2011/11/14/2248023.html\" target=\"_blank\" rel=\"external\">[原创] jQuery1.6.1源码分析系列（停止更新）</a><br><a href=\"http://www.cnblogs.com/aaronjs/p/3279314.html\" target=\"_blank\" rel=\"external\">jQuery源码分析系列</a></p>\n"},{"title":"jQuery源码学习笔记(02)","date":"2017-10-10T12:44:41.000Z","_content":"## jQuery.fn.init\n\n#### 正则表达式\n\n```javascript\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n// Strict HTML recognition (#11290: must start with <)\nrquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/\n```\n这是一个简单的检测HTML字符串的表达式，它可以分成两部分：\n```javascript\n\\s*(<[\\w\\W]+>)[^>]*\n// 用来匹配\"  <xxx><xxx>xxxx\"形式的字符串\n```\n```javascript\n#([\\w-]*)\n// 用来匹配\"#xx-xx-xx..\"形式的字符串\n```\n* tip：关于`(?:pattern)`，作用是匹配pattern但不获取匹配结果（非获取匹配）。即当使用match或exec的时候，该括号中的pattern匹配结果不会保存在数组中。\n\n\n#### jQuery选择器API\n\n选择器支持9种方式的处理\n```\n1.$(document)\n2.$(‘<div>’)\n3.$(‘div’)\n4.$(‘#test’)\n5.$(function(){})\n6.$(\"input:radio\", document.forms[0]);\n7.$(‘input’, $(‘div’))\n8.$()\n9.$(\"<div>\", {\n         \"class\": \"test\",\n         text: \"Click me!\",\n         click: function(){ $(this).toggleClass(\"test\"); }\n      }).appendTo(\"body\");\n10$($(‘.test’))\n```\n源码缩进后的结构：\n```javascript\ninit: function( selector, context, rootjQuery ) {\n  var match, elem;\n\n  // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n  if ( !selector ) {\n    return this;\n  }\n\n  // Handle HTML strings\n  if ( typeof selector === \"string\" ) {\n    // HANDLE: $(DOMElement)\n  } else if ( selector.nodeType ) {\n    // HANDLE: $(function)\n    // Shortcut for document ready\n  } else if ( jQuery.isFunction( selector ) ) {\n    return rootjQuery.ready( selector );\n  }\n\n  if ( selector.selector !== undefined ) {\n    this.selector = selector.selector;\n    this.context = selector.context;\n  }\n\n  return jQuery.makeArray( selector, this );\n},\n```\n\n#### 匹配传入的字符串\n\n```javascript\nif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n  // Assume that strings that start and end with <> are HTML and skip the regex check\n  match = [ null, selector, null ];\n\n} else {\n  match = rquickExpr.exec( selector );\n}\n```\n通过分析rquickExpr正则表达式，我们可以得出selector分别为以下几种值时返回值match的结构：\n* `selector = \"<div>\"`\n```javascript\nmatch = [null, \"<div>\", null]\n```\n* `selector = \"<div>content</div>\"`\n```javascript\nmatch = [null, \"<div>content</div>\", null]\n```\n* `selector = \"<div></div>content\"`\n```javascript\nmatch = [\"<div></div>content\", \"<div></div>\", null]\n```\n* `selector = #id`\n```javascript\nmatch = [#id, null, id]\n```\n* `selector = .className`等\n```javascript\nmatch = null\n```\n\n可以判断是第三种或第四种情况，当为#id时，不需要指定上下文context，当为<htmltag>时，需要指定上下文\n```javascript\nif ( match && (match[1] || !context) ) {\n```\n\n\n#### 匹配模式一：$(\"#id\")\n\n```javascript\nelem = document.getElementById( match[2] );\n\n// Check parentNode to catch when Blackberry 4.6 returns\n// nodes that are no longer in the document #6963\nif ( elem && elem.parentNode ) {\n  // Inject the element directly into the jQuery object\n  this.length = 1;\n  this[0] = elem;\n}\n\nthis.context = document;\nthis.selector = selector;\nreturn this;\n```\n\n#### 匹配模式二：$(`<htmltag>`)\n\n```javascript\n// HANDLE: $(html) -> $(array)\nif ( match[1] ) {\n  context = context instanceof jQuery ? context[0] : context;\n  // 当context为jQuery对象时，把context转换成Js的原生DOM对象\n  // 从上面可知context[0]即document.getElementById获取的elem\n  // scripts is true for back-compat\n  jQuery.merge( this, jQuery.parseHTML(\n    match[1],\n    context && context.nodeType ? context.ownerDocument || context : document,\n    true\n  ) );\n\n  // HANDLE: $(html, props)\n  // 对应：$(html标签, 对象)\n  if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n    for ( match in context ) {\n      // Properties of context are called as methods if possible\n      if ( jQuery.isFunction( this[ match ] ) ) {\n        this[ match ]( context[ match ] );\n\n      // ...and otherwise set as attributes\n      } else {\n        this.attr( match, context[ match ] );\n      }\n    }\n  }\n\n  return this;\n\n  // HANDLE: $(#id)\n}\n```\n▼ **关于`nodeType`：**\nnodeType是DOM对象中Node类型的一个属性，返回数字值代表指定节点的节点类型。如果节点是元素节点，则返回1；如果节点是属性节点，则返回2。通过nodeType属性来判断context是不是一个节点。\n▼ **关于`ownerDocument`：**\nownerDocument也是DOM对象中Node类型的一个属性，它返回的创建这个节点的文档对象。由于可能存在iframe或者通过ajax加载的xml文档，所以要区分这些文档与默认文档window.document。\n▼ **关于`$.merge`：**\n用于合并两个数组，但是不仅限于数组，还可以是key为数字的对象（类数组元素）\n▼ **关于`$.parseHTML`：**\n将字符串转换为存储DOM节点的数组。第一个参数为传入的字符串，第二个为指定的根节点，第三个是boolean值，默认为false，不转换。\n\n#### 匹配模式三：$(.className)\n\n```javascript\nelse if ( !context || context.jquery )\n```\ncontext为空或是context是一个jQuery对象时\n```javascript\nreturn ( context || rootjQuery ).find( selector );\n// rootjQuery即为jQuery(document)\n// 相当于 return jQuery( ducument ).find( selector );\n\n```\n\n#### 匹配模式四：$(.className, context)\n\n```javascript\nreturn this.constructor( context ).find( selector );\n// this.constructor 即为jQuery对象\n// 相当于 return jQuery( context ).find( selector );\n\n```\n\n▼ **关于`$.find`：**\njQuery的遍历方法，在DOM树中搜索匹配的元素，并构造成一个新的jQuery对象。\n\n#### 匹配模式五：$(jQuery对象)\n\n```javascript\nif ( selector.selector !== undefined ) {\n  this.selector = selector.selector;\n  this.context = selector.context;\n}\n```\n\n#### 匹配模式六：$(DOMElement)\n\n将DOM节点转换成jQuery对象：\n\n```javascript\nelse if ( selector.nodeType ) {\n  this.context = this[0] = selector;\n  this.length = 1;\n  return this;\n}\n```\n\n#### 匹配模式七：$(function)\n\n```javascript\nelse if ( jQuery.isFunction( selector ) ) {\n  return rootjQuery.ready( selector );\n}\n\n```\n▼ **关于`$.ready`：**\n当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。也即当加载完成时执行selector函数。\n\n#### 总结\n\n从本质上来说，构建的jQuery对象，其实不仅仅只是dom，还有很多附加的元素，用数组的方式存储，当然各种组合有不一样，但是存储的方式是一样的。\n\n总的来说分2大类：\n\n* 单个DOM元素，如$(ID),直接把DOM元素作数组传递给this对象\n* 多个DOM元素，集合形式，可以通过CSS选择器匹配是有的DOM元素，过滤操作,构建数据结构\n\n学习参考：\n[jQuery源码分析系列](http://www.cnblogs.com/aaronjs/p/3279314.html)","source":"_posts/17-10-10-29.md","raw":"---\ntitle: jQuery源码学习笔记(02)\ndate: 2017-10-10 20:44:41\ntags:\n---\n## jQuery.fn.init\n\n#### 正则表达式\n\n```javascript\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n// Strict HTML recognition (#11290: must start with <)\nrquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/\n```\n这是一个简单的检测HTML字符串的表达式，它可以分成两部分：\n```javascript\n\\s*(<[\\w\\W]+>)[^>]*\n// 用来匹配\"  <xxx><xxx>xxxx\"形式的字符串\n```\n```javascript\n#([\\w-]*)\n// 用来匹配\"#xx-xx-xx..\"形式的字符串\n```\n* tip：关于`(?:pattern)`，作用是匹配pattern但不获取匹配结果（非获取匹配）。即当使用match或exec的时候，该括号中的pattern匹配结果不会保存在数组中。\n\n\n#### jQuery选择器API\n\n选择器支持9种方式的处理\n```\n1.$(document)\n2.$(‘<div>’)\n3.$(‘div’)\n4.$(‘#test’)\n5.$(function(){})\n6.$(\"input:radio\", document.forms[0]);\n7.$(‘input’, $(‘div’))\n8.$()\n9.$(\"<div>\", {\n         \"class\": \"test\",\n         text: \"Click me!\",\n         click: function(){ $(this).toggleClass(\"test\"); }\n      }).appendTo(\"body\");\n10$($(‘.test’))\n```\n源码缩进后的结构：\n```javascript\ninit: function( selector, context, rootjQuery ) {\n  var match, elem;\n\n  // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n  if ( !selector ) {\n    return this;\n  }\n\n  // Handle HTML strings\n  if ( typeof selector === \"string\" ) {\n    // HANDLE: $(DOMElement)\n  } else if ( selector.nodeType ) {\n    // HANDLE: $(function)\n    // Shortcut for document ready\n  } else if ( jQuery.isFunction( selector ) ) {\n    return rootjQuery.ready( selector );\n  }\n\n  if ( selector.selector !== undefined ) {\n    this.selector = selector.selector;\n    this.context = selector.context;\n  }\n\n  return jQuery.makeArray( selector, this );\n},\n```\n\n#### 匹配传入的字符串\n\n```javascript\nif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n  // Assume that strings that start and end with <> are HTML and skip the regex check\n  match = [ null, selector, null ];\n\n} else {\n  match = rquickExpr.exec( selector );\n}\n```\n通过分析rquickExpr正则表达式，我们可以得出selector分别为以下几种值时返回值match的结构：\n* `selector = \"<div>\"`\n```javascript\nmatch = [null, \"<div>\", null]\n```\n* `selector = \"<div>content</div>\"`\n```javascript\nmatch = [null, \"<div>content</div>\", null]\n```\n* `selector = \"<div></div>content\"`\n```javascript\nmatch = [\"<div></div>content\", \"<div></div>\", null]\n```\n* `selector = #id`\n```javascript\nmatch = [#id, null, id]\n```\n* `selector = .className`等\n```javascript\nmatch = null\n```\n\n可以判断是第三种或第四种情况，当为#id时，不需要指定上下文context，当为<htmltag>时，需要指定上下文\n```javascript\nif ( match && (match[1] || !context) ) {\n```\n\n\n#### 匹配模式一：$(\"#id\")\n\n```javascript\nelem = document.getElementById( match[2] );\n\n// Check parentNode to catch when Blackberry 4.6 returns\n// nodes that are no longer in the document #6963\nif ( elem && elem.parentNode ) {\n  // Inject the element directly into the jQuery object\n  this.length = 1;\n  this[0] = elem;\n}\n\nthis.context = document;\nthis.selector = selector;\nreturn this;\n```\n\n#### 匹配模式二：$(`<htmltag>`)\n\n```javascript\n// HANDLE: $(html) -> $(array)\nif ( match[1] ) {\n  context = context instanceof jQuery ? context[0] : context;\n  // 当context为jQuery对象时，把context转换成Js的原生DOM对象\n  // 从上面可知context[0]即document.getElementById获取的elem\n  // scripts is true for back-compat\n  jQuery.merge( this, jQuery.parseHTML(\n    match[1],\n    context && context.nodeType ? context.ownerDocument || context : document,\n    true\n  ) );\n\n  // HANDLE: $(html, props)\n  // 对应：$(html标签, 对象)\n  if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n    for ( match in context ) {\n      // Properties of context are called as methods if possible\n      if ( jQuery.isFunction( this[ match ] ) ) {\n        this[ match ]( context[ match ] );\n\n      // ...and otherwise set as attributes\n      } else {\n        this.attr( match, context[ match ] );\n      }\n    }\n  }\n\n  return this;\n\n  // HANDLE: $(#id)\n}\n```\n▼ **关于`nodeType`：**\nnodeType是DOM对象中Node类型的一个属性，返回数字值代表指定节点的节点类型。如果节点是元素节点，则返回1；如果节点是属性节点，则返回2。通过nodeType属性来判断context是不是一个节点。\n▼ **关于`ownerDocument`：**\nownerDocument也是DOM对象中Node类型的一个属性，它返回的创建这个节点的文档对象。由于可能存在iframe或者通过ajax加载的xml文档，所以要区分这些文档与默认文档window.document。\n▼ **关于`$.merge`：**\n用于合并两个数组，但是不仅限于数组，还可以是key为数字的对象（类数组元素）\n▼ **关于`$.parseHTML`：**\n将字符串转换为存储DOM节点的数组。第一个参数为传入的字符串，第二个为指定的根节点，第三个是boolean值，默认为false，不转换。\n\n#### 匹配模式三：$(.className)\n\n```javascript\nelse if ( !context || context.jquery )\n```\ncontext为空或是context是一个jQuery对象时\n```javascript\nreturn ( context || rootjQuery ).find( selector );\n// rootjQuery即为jQuery(document)\n// 相当于 return jQuery( ducument ).find( selector );\n\n```\n\n#### 匹配模式四：$(.className, context)\n\n```javascript\nreturn this.constructor( context ).find( selector );\n// this.constructor 即为jQuery对象\n// 相当于 return jQuery( context ).find( selector );\n\n```\n\n▼ **关于`$.find`：**\njQuery的遍历方法，在DOM树中搜索匹配的元素，并构造成一个新的jQuery对象。\n\n#### 匹配模式五：$(jQuery对象)\n\n```javascript\nif ( selector.selector !== undefined ) {\n  this.selector = selector.selector;\n  this.context = selector.context;\n}\n```\n\n#### 匹配模式六：$(DOMElement)\n\n将DOM节点转换成jQuery对象：\n\n```javascript\nelse if ( selector.nodeType ) {\n  this.context = this[0] = selector;\n  this.length = 1;\n  return this;\n}\n```\n\n#### 匹配模式七：$(function)\n\n```javascript\nelse if ( jQuery.isFunction( selector ) ) {\n  return rootjQuery.ready( selector );\n}\n\n```\n▼ **关于`$.ready`：**\n当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。也即当加载完成时执行selector函数。\n\n#### 总结\n\n从本质上来说，构建的jQuery对象，其实不仅仅只是dom，还有很多附加的元素，用数组的方式存储，当然各种组合有不一样，但是存储的方式是一样的。\n\n总的来说分2大类：\n\n* 单个DOM元素，如$(ID),直接把DOM元素作数组传递给this对象\n* 多个DOM元素，集合形式，可以通过CSS选择器匹配是有的DOM元素，过滤操作,构建数据结构\n\n学习参考：\n[jQuery源码分析系列](http://www.cnblogs.com/aaronjs/p/3279314.html)","slug":"17-10-10-29","published":1,"updated":"2017-10-14T03:13:13.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2xf000mbguj7xowvezf","content":"<h2 id=\"jQuery-fn-init\"><a href=\"#jQuery-fn-init\" class=\"headerlink\" title=\"jQuery.fn.init\"></a>jQuery.fn.init</h2><h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// A simple way to check for HTML strings</span></div><div class=\"line\"><span class=\"comment\">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span></div><div class=\"line\"><span class=\"comment\">// Strict HTML recognition (#11290: must start with &lt;)</span></div><div class=\"line\">rquickExpr = <span class=\"regexp\">/^(?:\\s*(&lt;[\\w\\W]+&gt;)[^&gt;]*|#([\\w-]*))$/</span></div></pre></td></tr></table></figure>\n<p>这是一个简单的检测HTML字符串的表达式，它可以分成两部分：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\s*(&lt;[\\w\\W]+&gt;)[^&gt;]*</div><div class=\"line\">// 用来匹配\"  &lt;xxx&gt;&lt;xxx&gt;xxxx\"形式的字符串</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#([\\w-]*)</div><div class=\"line\">// 用来匹配\"#xx-xx-xx..\"形式的字符串</div></pre></td></tr></table></figure>\n<ul>\n<li>tip：关于<code>(?:pattern)</code>，作用是匹配pattern但不获取匹配结果（非获取匹配）。即当使用match或exec的时候，该括号中的pattern匹配结果不会保存在数组中。</li>\n</ul>\n<h4 id=\"jQuery选择器API\"><a href=\"#jQuery选择器API\" class=\"headerlink\" title=\"jQuery选择器API\"></a>jQuery选择器API</h4><p>选择器支持9种方式的处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.$(document)</div><div class=\"line\">2.$(‘&lt;div&gt;’)</div><div class=\"line\">3.$(‘div’)</div><div class=\"line\">4.$(‘#test’)</div><div class=\"line\">5.$(function()&#123;&#125;)</div><div class=\"line\">6.$(&quot;input:radio&quot;, document.forms[0]);</div><div class=\"line\">7.$(‘input’, $(‘div’))</div><div class=\"line\">8.$()</div><div class=\"line\">9.$(&quot;&lt;div&gt;&quot;, &#123;</div><div class=\"line\">         &quot;class&quot;: &quot;test&quot;,</div><div class=\"line\">         text: &quot;Click me!&quot;,</div><div class=\"line\">         click: function()&#123; $(this).toggleClass(&quot;test&quot;); &#125;</div><div class=\"line\">      &#125;).appendTo(&quot;body&quot;);</div><div class=\"line\">10$($(‘.test’))</div></pre></td></tr></table></figure></p>\n<p>源码缩进后的结构：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> selector, context, rootjQuery </span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> match, elem;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// HANDLE: $(\"\"), $(null), $(undefined), $(false)</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( !selector ) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Handle HTML strings</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> selector === <span class=\"string\">\"string\"</span> ) &#123;</div><div class=\"line\">    <span class=\"comment\">// HANDLE: $(DOMElement)</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( selector.nodeType ) &#123;</div><div class=\"line\">    <span class=\"comment\">// HANDLE: $(function)</span></div><div class=\"line\">    <span class=\"comment\">// Shortcut for document ready</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> rootjQuery.ready( selector );</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> ( selector.selector !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.selector = selector.selector;</div><div class=\"line\">    <span class=\"keyword\">this</span>.context = selector.context;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> jQuery.makeArray( selector, <span class=\"keyword\">this</span> );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure></p>\n<h4 id=\"匹配传入的字符串\"><a href=\"#匹配传入的字符串\" class=\"headerlink\" title=\"匹配传入的字符串\"></a>匹配传入的字符串</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ( selector.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\"&lt;\"</span> &amp;&amp; selector.charAt( selector.length - <span class=\"number\">1</span> ) === <span class=\"string\">\"&gt;\"</span> &amp;&amp; selector.length &gt;= <span class=\"number\">3</span> ) &#123;</div><div class=\"line\">  <span class=\"comment\">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span></div><div class=\"line\">  match = [ <span class=\"literal\">null</span>, selector, <span class=\"literal\">null</span> ];</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  match = rquickExpr.exec( selector );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过分析rquickExpr正则表达式，我们可以得出selector分别为以下几种值时返回值match的结构：</p>\n<ul>\n<li><p><code>selector = &quot;&lt;div&gt;&quot;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [<span class=\"literal\">null</span>, <span class=\"string\">\"&lt;div&gt;\"</span>, <span class=\"literal\">null</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = &quot;&lt;div&gt;content&lt;/div&gt;&quot;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [<span class=\"literal\">null</span>, <span class=\"string\">\"&lt;div&gt;content&lt;/div&gt;\"</span>, <span class=\"literal\">null</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = &quot;&lt;div&gt;&lt;/div&gt;content&quot;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [<span class=\"string\">\"&lt;div&gt;&lt;/div&gt;content\"</span>, <span class=\"string\">\"&lt;div&gt;&lt;/div&gt;\"</span>, <span class=\"literal\">null</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = #id</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [#id, null, id]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = .className</code>等</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = <span class=\"literal\">null</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以判断是第三种或第四种情况，当为#id时，不需要指定上下文context，当为<htmltag>时，需要指定上下文<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ( match &amp;&amp; (match[<span class=\"number\">1</span>] || !context) ) &#123;</div></pre></td></tr></table></figure></htmltag></p>\n<h4 id=\"匹配模式一：-“-id”\"><a href=\"#匹配模式一：-“-id”\" class=\"headerlink\" title=\"匹配模式一：$(“#id”)\"></a>匹配模式一：$(“#id”)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">elem = <span class=\"built_in\">document</span>.getElementById( match[<span class=\"number\">2</span>] );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Check parentNode to catch when Blackberry 4.6 returns</span></div><div class=\"line\"><span class=\"comment\">// nodes that are no longer in the document #6963</span></div><div class=\"line\"><span class=\"keyword\">if</span> ( elem &amp;&amp; elem.parentNode ) &#123;</div><div class=\"line\">  <span class=\"comment\">// Inject the element directly into the jQuery object</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>[<span class=\"number\">0</span>] = elem;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">this</span>.context = <span class=\"built_in\">document</span>;</div><div class=\"line\"><span class=\"keyword\">this</span>.selector = selector;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div></pre></td></tr></table></figure>\n<h4 id=\"匹配模式二：-lt-htmltag-gt\"><a href=\"#匹配模式二：-lt-htmltag-gt\" class=\"headerlink\" title=\"匹配模式二：$(&lt;htmltag&gt;)\"></a>匹配模式二：$(<code>&lt;htmltag&gt;</code>)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HANDLE: $(html) -&gt; $(array)</span></div><div class=\"line\"><span class=\"keyword\">if</span> ( match[<span class=\"number\">1</span>] ) &#123;</div><div class=\"line\">  context = context <span class=\"keyword\">instanceof</span> jQuery ? context[<span class=\"number\">0</span>] : context;</div><div class=\"line\">  <span class=\"comment\">// 当context为jQuery对象时，把context转换成Js的原生DOM对象</span></div><div class=\"line\">  <span class=\"comment\">// 从上面可知context[0]即document.getElementById获取的elem</span></div><div class=\"line\">  <span class=\"comment\">// scripts is true for back-compat</span></div><div class=\"line\">  jQuery.merge( <span class=\"keyword\">this</span>, jQuery.parseHTML(</div><div class=\"line\">    match[<span class=\"number\">1</span>],</div><div class=\"line\">    context &amp;&amp; context.nodeType ? context.ownerDocument || context : <span class=\"built_in\">document</span>,</div><div class=\"line\">    <span class=\"literal\">true</span></div><div class=\"line\">  ) );</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// HANDLE: $(html, props)</span></div><div class=\"line\">  <span class=\"comment\">// 对应：$(html标签, 对象)</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( rsingleTag.test( match[<span class=\"number\">1</span>] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> ( match <span class=\"keyword\">in</span> context ) &#123;</div><div class=\"line\">      <span class=\"comment\">// Properties of context are called as methods if possible</span></div><div class=\"line\">      <span class=\"keyword\">if</span> ( jQuery.isFunction( <span class=\"keyword\">this</span>[ match ] ) ) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>[ match ]( context[ match ] );</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// ...and otherwise set as attributes</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.attr( match, context[ match ] );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// HANDLE: $(#id)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>▼ <strong>关于<code>nodeType</code>：</strong><br>nodeType是DOM对象中Node类型的一个属性，返回数字值代表指定节点的节点类型。如果节点是元素节点，则返回1；如果节点是属性节点，则返回2。通过nodeType属性来判断context是不是一个节点。<br>▼ <strong>关于<code>ownerDocument</code>：</strong><br>ownerDocument也是DOM对象中Node类型的一个属性，它返回的创建这个节点的文档对象。由于可能存在iframe或者通过ajax加载的xml文档，所以要区分这些文档与默认文档window.document。<br>▼ <strong>关于<code>$.merge</code>：</strong><br>用于合并两个数组，但是不仅限于数组，还可以是key为数字的对象（类数组元素）<br>▼ <strong>关于<code>$.parseHTML</code>：</strong><br>将字符串转换为存储DOM节点的数组。第一个参数为传入的字符串，第二个为指定的根节点，第三个是boolean值，默认为false，不转换。</p>\n<h4 id=\"匹配模式三：-className\"><a href=\"#匹配模式三：-className\" class=\"headerlink\" title=\"匹配模式三：$(.className)\"></a>匹配模式三：$(.className)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( !context || context.jquery )</div></pre></td></tr></table></figure>\n<p>context为空或是context是一个jQuery对象时<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> ( context || rootjQuery ).find( selector );</div><div class=\"line\"><span class=\"comment\">// rootjQuery即为jQuery(document)</span></div><div class=\"line\"><span class=\"comment\">// 相当于 return jQuery( ducument ).find( selector );</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"匹配模式四：-className-context\"><a href=\"#匹配模式四：-className-context\" class=\"headerlink\" title=\"匹配模式四：$(.className, context)\"></a>匹配模式四：$(.className, context)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.constructor( context ).find( selector );</div><div class=\"line\"><span class=\"comment\">// this.constructor 即为jQuery对象</span></div><div class=\"line\"><span class=\"comment\">// 相当于 return jQuery( context ).find( selector );</span></div></pre></td></tr></table></figure>\n<p>▼ <strong>关于<code>$.find</code>：</strong><br>jQuery的遍历方法，在DOM树中搜索匹配的元素，并构造成一个新的jQuery对象。</p>\n<h4 id=\"匹配模式五：-jQuery对象\"><a href=\"#匹配模式五：-jQuery对象\" class=\"headerlink\" title=\"匹配模式五：$(jQuery对象)\"></a>匹配模式五：$(jQuery对象)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ( selector.selector !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.selector = selector.selector;</div><div class=\"line\">  <span class=\"keyword\">this</span>.context = selector.context;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"匹配模式六：-DOMElement\"><a href=\"#匹配模式六：-DOMElement\" class=\"headerlink\" title=\"匹配模式六：$(DOMElement)\"></a>匹配模式六：$(DOMElement)</h4><p>将DOM节点转换成jQuery对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( selector.nodeType ) &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.context = <span class=\"keyword\">this</span>[<span class=\"number\">0</span>] = selector;</div><div class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"匹配模式七：-function\"><a href=\"#匹配模式七：-function\" class=\"headerlink\" title=\"匹配模式七：$(function)\"></a>匹配模式七：$(function)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> rootjQuery.ready( selector );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>▼ <strong>关于<code>$.ready</code>：</strong><br>当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。也即当加载完成时执行selector函数。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>从本质上来说，构建的jQuery对象，其实不仅仅只是dom，还有很多附加的元素，用数组的方式存储，当然各种组合有不一样，但是存储的方式是一样的。</p>\n<p>总的来说分2大类：</p>\n<ul>\n<li>单个DOM元素，如$(ID),直接把DOM元素作数组传递给this对象</li>\n<li>多个DOM元素，集合形式，可以通过CSS选择器匹配是有的DOM元素，过滤操作,构建数据结构</li>\n</ul>\n<p>学习参考：<br><a href=\"http://www.cnblogs.com/aaronjs/p/3279314.html\" target=\"_blank\" rel=\"external\">jQuery源码分析系列</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"jQuery-fn-init\"><a href=\"#jQuery-fn-init\" class=\"headerlink\" title=\"jQuery.fn.init\"></a>jQuery.fn.init</h2><h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// A simple way to check for HTML strings</span></div><div class=\"line\"><span class=\"comment\">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span></div><div class=\"line\"><span class=\"comment\">// Strict HTML recognition (#11290: must start with &lt;)</span></div><div class=\"line\">rquickExpr = <span class=\"regexp\">/^(?:\\s*(&lt;[\\w\\W]+&gt;)[^&gt;]*|#([\\w-]*))$/</span></div></pre></td></tr></table></figure>\n<p>这是一个简单的检测HTML字符串的表达式，它可以分成两部分：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\s*(&lt;[\\w\\W]+&gt;)[^&gt;]*</div><div class=\"line\">// 用来匹配\"  &lt;xxx&gt;&lt;xxx&gt;xxxx\"形式的字符串</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#([\\w-]*)</div><div class=\"line\">// 用来匹配\"#xx-xx-xx..\"形式的字符串</div></pre></td></tr></table></figure>\n<ul>\n<li>tip：关于<code>(?:pattern)</code>，作用是匹配pattern但不获取匹配结果（非获取匹配）。即当使用match或exec的时候，该括号中的pattern匹配结果不会保存在数组中。</li>\n</ul>\n<h4 id=\"jQuery选择器API\"><a href=\"#jQuery选择器API\" class=\"headerlink\" title=\"jQuery选择器API\"></a>jQuery选择器API</h4><p>选择器支持9种方式的处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.$(document)</div><div class=\"line\">2.$(‘&lt;div&gt;’)</div><div class=\"line\">3.$(‘div’)</div><div class=\"line\">4.$(‘#test’)</div><div class=\"line\">5.$(function()&#123;&#125;)</div><div class=\"line\">6.$(&quot;input:radio&quot;, document.forms[0]);</div><div class=\"line\">7.$(‘input’, $(‘div’))</div><div class=\"line\">8.$()</div><div class=\"line\">9.$(&quot;&lt;div&gt;&quot;, &#123;</div><div class=\"line\">         &quot;class&quot;: &quot;test&quot;,</div><div class=\"line\">         text: &quot;Click me!&quot;,</div><div class=\"line\">         click: function()&#123; $(this).toggleClass(&quot;test&quot;); &#125;</div><div class=\"line\">      &#125;).appendTo(&quot;body&quot;);</div><div class=\"line\">10$($(‘.test’))</div></pre></td></tr></table></figure></p>\n<p>源码缩进后的结构：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> selector, context, rootjQuery </span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> match, elem;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// HANDLE: $(\"\"), $(null), $(undefined), $(false)</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( !selector ) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Handle HTML strings</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> selector === <span class=\"string\">\"string\"</span> ) &#123;</div><div class=\"line\">    <span class=\"comment\">// HANDLE: $(DOMElement)</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( selector.nodeType ) &#123;</div><div class=\"line\">    <span class=\"comment\">// HANDLE: $(function)</span></div><div class=\"line\">    <span class=\"comment\">// Shortcut for document ready</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> rootjQuery.ready( selector );</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> ( selector.selector !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.selector = selector.selector;</div><div class=\"line\">    <span class=\"keyword\">this</span>.context = selector.context;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> jQuery.makeArray( selector, <span class=\"keyword\">this</span> );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure></p>\n<h4 id=\"匹配传入的字符串\"><a href=\"#匹配传入的字符串\" class=\"headerlink\" title=\"匹配传入的字符串\"></a>匹配传入的字符串</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ( selector.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\"&lt;\"</span> &amp;&amp; selector.charAt( selector.length - <span class=\"number\">1</span> ) === <span class=\"string\">\"&gt;\"</span> &amp;&amp; selector.length &gt;= <span class=\"number\">3</span> ) &#123;</div><div class=\"line\">  <span class=\"comment\">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span></div><div class=\"line\">  match = [ <span class=\"literal\">null</span>, selector, <span class=\"literal\">null</span> ];</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  match = rquickExpr.exec( selector );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过分析rquickExpr正则表达式，我们可以得出selector分别为以下几种值时返回值match的结构：</p>\n<ul>\n<li><p><code>selector = &quot;&lt;div&gt;&quot;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [<span class=\"literal\">null</span>, <span class=\"string\">\"&lt;div&gt;\"</span>, <span class=\"literal\">null</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = &quot;&lt;div&gt;content&lt;/div&gt;&quot;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [<span class=\"literal\">null</span>, <span class=\"string\">\"&lt;div&gt;content&lt;/div&gt;\"</span>, <span class=\"literal\">null</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = &quot;&lt;div&gt;&lt;/div&gt;content&quot;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [<span class=\"string\">\"&lt;div&gt;&lt;/div&gt;content\"</span>, <span class=\"string\">\"&lt;div&gt;&lt;/div&gt;\"</span>, <span class=\"literal\">null</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = #id</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = [#id, null, id]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>selector = .className</code>等</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">match = <span class=\"literal\">null</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以判断是第三种或第四种情况，当为#id时，不需要指定上下文context，当为<htmltag>时，需要指定上下文<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ( match &amp;&amp; (match[<span class=\"number\">1</span>] || !context) ) &#123;</div></pre></td></tr></table></figure></htmltag></p>\n<h4 id=\"匹配模式一：-“-id”\"><a href=\"#匹配模式一：-“-id”\" class=\"headerlink\" title=\"匹配模式一：$(“#id”)\"></a>匹配模式一：$(“#id”)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">elem = <span class=\"built_in\">document</span>.getElementById( match[<span class=\"number\">2</span>] );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Check parentNode to catch when Blackberry 4.6 returns</span></div><div class=\"line\"><span class=\"comment\">// nodes that are no longer in the document #6963</span></div><div class=\"line\"><span class=\"keyword\">if</span> ( elem &amp;&amp; elem.parentNode ) &#123;</div><div class=\"line\">  <span class=\"comment\">// Inject the element directly into the jQuery object</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>[<span class=\"number\">0</span>] = elem;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">this</span>.context = <span class=\"built_in\">document</span>;</div><div class=\"line\"><span class=\"keyword\">this</span>.selector = selector;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div></pre></td></tr></table></figure>\n<h4 id=\"匹配模式二：-lt-htmltag-gt\"><a href=\"#匹配模式二：-lt-htmltag-gt\" class=\"headerlink\" title=\"匹配模式二：$(&lt;htmltag&gt;)\"></a>匹配模式二：$(<code>&lt;htmltag&gt;</code>)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HANDLE: $(html) -&gt; $(array)</span></div><div class=\"line\"><span class=\"keyword\">if</span> ( match[<span class=\"number\">1</span>] ) &#123;</div><div class=\"line\">  context = context <span class=\"keyword\">instanceof</span> jQuery ? context[<span class=\"number\">0</span>] : context;</div><div class=\"line\">  <span class=\"comment\">// 当context为jQuery对象时，把context转换成Js的原生DOM对象</span></div><div class=\"line\">  <span class=\"comment\">// 从上面可知context[0]即document.getElementById获取的elem</span></div><div class=\"line\">  <span class=\"comment\">// scripts is true for back-compat</span></div><div class=\"line\">  jQuery.merge( <span class=\"keyword\">this</span>, jQuery.parseHTML(</div><div class=\"line\">    match[<span class=\"number\">1</span>],</div><div class=\"line\">    context &amp;&amp; context.nodeType ? context.ownerDocument || context : <span class=\"built_in\">document</span>,</div><div class=\"line\">    <span class=\"literal\">true</span></div><div class=\"line\">  ) );</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// HANDLE: $(html, props)</span></div><div class=\"line\">  <span class=\"comment\">// 对应：$(html标签, 对象)</span></div><div class=\"line\">  <span class=\"keyword\">if</span> ( rsingleTag.test( match[<span class=\"number\">1</span>] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> ( match <span class=\"keyword\">in</span> context ) &#123;</div><div class=\"line\">      <span class=\"comment\">// Properties of context are called as methods if possible</span></div><div class=\"line\">      <span class=\"keyword\">if</span> ( jQuery.isFunction( <span class=\"keyword\">this</span>[ match ] ) ) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>[ match ]( context[ match ] );</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// ...and otherwise set as attributes</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.attr( match, context[ match ] );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// HANDLE: $(#id)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>▼ <strong>关于<code>nodeType</code>：</strong><br>nodeType是DOM对象中Node类型的一个属性，返回数字值代表指定节点的节点类型。如果节点是元素节点，则返回1；如果节点是属性节点，则返回2。通过nodeType属性来判断context是不是一个节点。<br>▼ <strong>关于<code>ownerDocument</code>：</strong><br>ownerDocument也是DOM对象中Node类型的一个属性，它返回的创建这个节点的文档对象。由于可能存在iframe或者通过ajax加载的xml文档，所以要区分这些文档与默认文档window.document。<br>▼ <strong>关于<code>$.merge</code>：</strong><br>用于合并两个数组，但是不仅限于数组，还可以是key为数字的对象（类数组元素）<br>▼ <strong>关于<code>$.parseHTML</code>：</strong><br>将字符串转换为存储DOM节点的数组。第一个参数为传入的字符串，第二个为指定的根节点，第三个是boolean值，默认为false，不转换。</p>\n<h4 id=\"匹配模式三：-className\"><a href=\"#匹配模式三：-className\" class=\"headerlink\" title=\"匹配模式三：$(.className)\"></a>匹配模式三：$(.className)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( !context || context.jquery )</div></pre></td></tr></table></figure>\n<p>context为空或是context是一个jQuery对象时<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> ( context || rootjQuery ).find( selector );</div><div class=\"line\"><span class=\"comment\">// rootjQuery即为jQuery(document)</span></div><div class=\"line\"><span class=\"comment\">// 相当于 return jQuery( ducument ).find( selector );</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"匹配模式四：-className-context\"><a href=\"#匹配模式四：-className-context\" class=\"headerlink\" title=\"匹配模式四：$(.className, context)\"></a>匹配模式四：$(.className, context)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.constructor( context ).find( selector );</div><div class=\"line\"><span class=\"comment\">// this.constructor 即为jQuery对象</span></div><div class=\"line\"><span class=\"comment\">// 相当于 return jQuery( context ).find( selector );</span></div></pre></td></tr></table></figure>\n<p>▼ <strong>关于<code>$.find</code>：</strong><br>jQuery的遍历方法，在DOM树中搜索匹配的元素，并构造成一个新的jQuery对象。</p>\n<h4 id=\"匹配模式五：-jQuery对象\"><a href=\"#匹配模式五：-jQuery对象\" class=\"headerlink\" title=\"匹配模式五：$(jQuery对象)\"></a>匹配模式五：$(jQuery对象)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ( selector.selector !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.selector = selector.selector;</div><div class=\"line\">  <span class=\"keyword\">this</span>.context = selector.context;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"匹配模式六：-DOMElement\"><a href=\"#匹配模式六：-DOMElement\" class=\"headerlink\" title=\"匹配模式六：$(DOMElement)\"></a>匹配模式六：$(DOMElement)</h4><p>将DOM节点转换成jQuery对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( selector.nodeType ) &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.context = <span class=\"keyword\">this</span>[<span class=\"number\">0</span>] = selector;</div><div class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"匹配模式七：-function\"><a href=\"#匹配模式七：-function\" class=\"headerlink\" title=\"匹配模式七：$(function)\"></a>匹配模式七：$(function)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> rootjQuery.ready( selector );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>▼ <strong>关于<code>$.ready</code>：</strong><br>当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。也即当加载完成时执行selector函数。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>从本质上来说，构建的jQuery对象，其实不仅仅只是dom，还有很多附加的元素，用数组的方式存储，当然各种组合有不一样，但是存储的方式是一样的。</p>\n<p>总的来说分2大类：</p>\n<ul>\n<li>单个DOM元素，如$(ID),直接把DOM元素作数组传递给this对象</li>\n<li>多个DOM元素，集合形式，可以通过CSS选择器匹配是有的DOM元素，过滤操作,构建数据结构</li>\n</ul>\n<p>学习参考：<br><a href=\"http://www.cnblogs.com/aaronjs/p/3279314.html\" target=\"_blank\" rel=\"external\">jQuery源码分析系列</a></p>\n"},{"title":"JS变量计算","date":"2017-08-24T12:53:29.000Z","_content":"## typeof 运算符\n\n```javascript\ntypeof undefined // undefined\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof {} // object\ntypeof [] // object\ntypeof null // object\ntypeof console.log // function\n```\n\n## 变量运算 - 强制类型转换\n\n#### 字符串拼接\n\n```javascript\nvar a = 100 + 10 // 110\nvar b = 100 + '10' // '10010'\n```\n当使用减运算时：\n```javascript\nvar c = '100' - 10 // 90\n```\n\n#### == 运算符\n\n```javascript\n100 == '100' // true\n0 == '' // true\nnull == undefined // true\n```\n`==`与`===`的区别：`===`是严格等于，只有类型完全相同才会返回`true`\n```javascript\nnull === null\nundefined === undefined\nnull === undefined // false\nNaN === NaN // false\n```\n什么时候用`==`什么时候用`===`：jQuery源码中推荐写法，只有下述情况才用`==`，其他时候都用`===`。\n```javascript\nif(a == null) {\n  // 这里相当于 a === null || a === undefined\n}\n```\n\n#### if语句\n\n```javascript\nvar a = true;\nif(a) { //... } \n\nvar b = 100; // true\nif(b) { //... }\n\nvar c = ''; // false\nif(c) { //... }\n```\n`if`中被判定为`false`的几个值：`0`,`NaN`,`''`,`null`,`undefined`\n\n#### 逻辑运算\n\n```javascript\nconsole.log(10 && 0) // 0\nconsole.log('' || 'abc') // 'abc'\nconsole.log(!window.abc) // true\n\n// 判断一个变量会被当做 true 还是 false\nvar a = 100;\nconsole.log(!!a) //true\n```","source":"_posts/17-08-24-25.md","raw":"---\ntitle: JS变量计算\ndate: 2017-08-24 20:53:29\ntags:\n---\n## typeof 运算符\n\n```javascript\ntypeof undefined // undefined\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof {} // object\ntypeof [] // object\ntypeof null // object\ntypeof console.log // function\n```\n\n## 变量运算 - 强制类型转换\n\n#### 字符串拼接\n\n```javascript\nvar a = 100 + 10 // 110\nvar b = 100 + '10' // '10010'\n```\n当使用减运算时：\n```javascript\nvar c = '100' - 10 // 90\n```\n\n#### == 运算符\n\n```javascript\n100 == '100' // true\n0 == '' // true\nnull == undefined // true\n```\n`==`与`===`的区别：`===`是严格等于，只有类型完全相同才会返回`true`\n```javascript\nnull === null\nundefined === undefined\nnull === undefined // false\nNaN === NaN // false\n```\n什么时候用`==`什么时候用`===`：jQuery源码中推荐写法，只有下述情况才用`==`，其他时候都用`===`。\n```javascript\nif(a == null) {\n  // 这里相当于 a === null || a === undefined\n}\n```\n\n#### if语句\n\n```javascript\nvar a = true;\nif(a) { //... } \n\nvar b = 100; // true\nif(b) { //... }\n\nvar c = ''; // false\nif(c) { //... }\n```\n`if`中被判定为`false`的几个值：`0`,`NaN`,`''`,`null`,`undefined`\n\n#### 逻辑运算\n\n```javascript\nconsole.log(10 && 0) // 0\nconsole.log('' || 'abc') // 'abc'\nconsole.log(!window.abc) // true\n\n// 判断一个变量会被当做 true 还是 false\nvar a = 100;\nconsole.log(!!a) //true\n```","slug":"17-08-24-25","published":1,"updated":"2017-10-05T16:03:55.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2xh000nbgujbv35b6qm","content":"<h2 id=\"typeof-运算符\"><a href=\"#typeof-运算符\" class=\"headerlink\" title=\"typeof 运算符\"></a>typeof 运算符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'abc'</span> <span class=\"comment\">// string</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// function</span></div></pre></td></tr></table></figure>\n<h2 id=\"变量运算-强制类型转换\"><a href=\"#变量运算-强制类型转换\" class=\"headerlink\" title=\"变量运算 - 强制类型转换\"></a>变量运算 - 强制类型转换</h2><h4 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span> + <span class=\"number\">10</span> <span class=\"comment\">// 110</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span> + <span class=\"string\">'10'</span> <span class=\"comment\">// '10010'</span></div></pre></td></tr></table></figure>\n<p>当使用减运算时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">'100'</span> - <span class=\"number\">10</span> <span class=\"comment\">// 90</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"== 运算符\"></a>== 运算符</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">100</span> == <span class=\"string\">'100'</span> <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">''</span> <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><code>==</code>与<code>===</code>的区别：<code>===</code>是严格等于，只有类型完全相同才会返回<code>true</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">null</span></div><div class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">undefined</span></div><div class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>什么时候用<code>==</code>什么时候用<code>===</code>：jQuery源码中推荐写法，只有下述情况才用<code>==</code>，其他时候都用<code>===</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(a == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// 这里相当于 a === null || a === undefined</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">true</span>;</div><div class=\"line\"><span class=\"keyword\">if</span>(a) &#123; <span class=\"comment\">//... &#125; </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span>; <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"keyword\">if</span>(b) &#123; <span class=\"comment\">//... &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">''</span>; <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"keyword\">if</span>(c) &#123; <span class=\"comment\">//... &#125;</span></div></pre></td></tr></table></figure>\n<p><code>if</code>中被判定为<code>false</code>的几个值：<code>0</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>null</code>,<code>undefined</code></p>\n<h4 id=\"逻辑运算\"><a href=\"#逻辑运算\" class=\"headerlink\" title=\"逻辑运算\"></a>逻辑运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">10</span> &amp;&amp; <span class=\"number\">0</span>) <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">''</span> || <span class=\"string\">'abc'</span>) <span class=\"comment\">// 'abc'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(!<span class=\"built_in\">window</span>.abc) <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断一个变量会被当做 true 还是 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(!!a) <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"typeof-运算符\"><a href=\"#typeof-运算符\" class=\"headerlink\" title=\"typeof 运算符\"></a>typeof 运算符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'abc'</span> <span class=\"comment\">// string</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// function</span></div></pre></td></tr></table></figure>\n<h2 id=\"变量运算-强制类型转换\"><a href=\"#变量运算-强制类型转换\" class=\"headerlink\" title=\"变量运算 - 强制类型转换\"></a>变量运算 - 强制类型转换</h2><h4 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span> + <span class=\"number\">10</span> <span class=\"comment\">// 110</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span> + <span class=\"string\">'10'</span> <span class=\"comment\">// '10010'</span></div></pre></td></tr></table></figure>\n<p>当使用减运算时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">'100'</span> - <span class=\"number\">10</span> <span class=\"comment\">// 90</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"== 运算符\"></a>== 运算符</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">100</span> == <span class=\"string\">'100'</span> <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">''</span> <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><code>==</code>与<code>===</code>的区别：<code>===</code>是严格等于，只有类型完全相同才会返回<code>true</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">null</span></div><div class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">undefined</span></div><div class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>什么时候用<code>==</code>什么时候用<code>===</code>：jQuery源码中推荐写法，只有下述情况才用<code>==</code>，其他时候都用<code>===</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(a == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// 这里相当于 a === null || a === undefined</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">true</span>;</div><div class=\"line\"><span class=\"keyword\">if</span>(a) &#123; <span class=\"comment\">//... &#125; </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">100</span>; <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"keyword\">if</span>(b) &#123; <span class=\"comment\">//... &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">''</span>; <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"keyword\">if</span>(c) &#123; <span class=\"comment\">//... &#125;</span></div></pre></td></tr></table></figure>\n<p><code>if</code>中被判定为<code>false</code>的几个值：<code>0</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>null</code>,<code>undefined</code></p>\n<h4 id=\"逻辑运算\"><a href=\"#逻辑运算\" class=\"headerlink\" title=\"逻辑运算\"></a>逻辑运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">10</span> &amp;&amp; <span class=\"number\">0</span>) <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">''</span> || <span class=\"string\">'abc'</span>) <span class=\"comment\">// 'abc'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(!<span class=\"built_in\">window</span>.abc) <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断一个变量会被当做 true 还是 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(!!a) <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>"},{"title":"jQuery源码学习笔记(03)","date":"2017-10-14T03:41:59.000Z","_content":"## CSS选择器\n\n#### 分类\n* 群组选择器：逗号“,”\n```\ndiv, p                //选择所有<div>元素和所有<p>元素\n```\n* 简单选择器：ID、标签、类、属性、通配符\n```\n#test                 //选择id=\"test\"的所有元素\np                     //选择所有<p>元素\n.intro                //选择class=\"intro\"的所有元素\n[target]              //选择带有target属性的所有元素\n[target=_blank]       //选择target=\"_blank\"的所有元素\n[title~=flower]       //选择titl属性包含单词\"flower\"的所有元素\n[lang|=en]            //选择属性值以\"en\"开头的所有元素\na[src^=\"https\"]       //选择src属性值以\"https\"开头的所有<a>元素\na[src$=\".pdf\"]        //选择src属性值以\".pdf\"结尾的所有<a>元素\na[src*=\"abc\"]         //选择src属性值中包含\"abc\"子串的所有<a>元素\n*                     //选择所有元素\n```\n* 关系选择器：孩子、后代、相邻兄弟\n```\ndiv > p               //选择父元素为<div>元素的所有<p>元素\ndiv p                 //选择<div>元素内部的所有<p>元素\ndiv + p               //选择紧接在<div>元素之后的所有<p>元素\np ~ ul                //选择前面有<p>元素的每个<ul>元素\n```\n* 伪类选择器：动作伪类、目标伪类、语言伪类、状态伪类、结构伪类、取反伪类\n```\na:link                //选择所有未被访问的链接\na:visited             //选择所有已被访问链接\na:active              //选择活动链接\na:hover               //选择鼠标指针位于其上的链接\ninput:focus           //选择获得焦点的input元素\n:before               //在每个<p>元素的内容之前插入内容\n:after                //在每个<p>元素的内容之后插入内容\np:lang(it)            //选择带有以\"it\"开头的lang属性值的所有<p>元素\n#news:target          //选择当前活动的#news元素\ninput:enabled         //选择所有启用的<input>元素\ninput:disabled        //选择所有禁用的<input>元素\ninput:checked         //选择所有被选中的<input>元素\n::selection           //选择被用户选取的元素部分\np:first-of-type       //选择属于其父元素的首个<p>元素的所有<p>元素\np:last-of-type        //选择属于其父元素的最后<p>元素的所有<p>元素\np:only-of-type        //选择属于其父元素唯一的<p>元素的所有<p>元素\np:nth-of-type(2)      //选择属于其父元素第二个<p>元素的所有<p>元素\np:only-child          //选择属于其父元素的唯一子元素的所有<p>元素\np:nth-child(2)        //选择属于其父元素的第二个子元素的所有<p>元素\np:last-child          //选择属于其父元素最后一个子元素的所有<p>元素\np:nth-last-child(2)   //同上，从最后一个子元素开始计数\n:root                 //选择文档的根元素\n:empty                //选择没有子元素的所有<p>元素\n:not(p)               //选择非<p>元素的所有元素\n```\n\n#### CSS的解析原理\n\nHTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。\n\n在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。\n\n因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。\n\n如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。\n\n逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。\n\n但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。\n\n#### getElementBy系列 与 querySelectorAll\n\n* getElementById（或者其他）获取的是动态集合，querySelector获取的是静态集合\n\n```html\n<ul>\n  <li>aaa</li>\n  <li>bbb</li>\n  <li>ccc</li>\n</ul>\n```\n```javascript\n// demo1\nvar ul = document.getElementsByTagName('ul')[0],\n    lis = ul.getElementsByTagName('li');\n//动态插入标签\nfor(var i = 0; i < lis.length; i ++) {\n  ul.appendChild(document.creatElement('li'));\n}\nconsole.log(lis.length); //6\n\n// demo2\nvar ul = document.querySeletorAll('ul'),\n    lis = ul.querySelectorAll('li');\n//插入动态标签\nfor(var i = 0; i < lis.length; i ++) {\n  ul.appendChild(document.creatElement('li'));\n}\nconsole.log(lis.length); //3\n```\ndemo1中的lis是一个动态的NodeList，每一次调用lis都会重新对文档进行查询，导致无限循环的问题。\n\ndemo2中的lis是一个静态的NodeList，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。\n\n而在chrome浏览器中\n```javascript\ndocument.querySelectorAll('a').toString();    // return \"[object NodeList]\"\ndocument.getElementsByTagName('a').toString();    // return \"[object HTMLCollection]\"\n```\n在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象。\n\n▼ **什么是NodeList：**\nNodeList本质上是一个动态的Node集合，只是规范中对querySelectorAll有明确要求，规定其必须返回一个静态的NodeList对象。\n\n▼ **什么是HTMLCollection：**\nHTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。\n\nNodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection  对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。\n\n▼ **getElementBy系列的速度比querySelectorAll快：**\n因为getElementById只返回一个元素，而且内部做了缓存，但是querySelectorAll会返回拥有这个id值的多个元素，尽管页面id一般是唯一的，但如果出现了多个同样id的情况下，getElementById还是只返回一个元素，而querySelectorAll会返回多个。\n```javascript\ndocument.getElementsByTagName(\"div\") == document.getElementsByTagName(\"div\")  // true\ndocument.querySelectorAll(\"div\") == document.querySelectorAll(\"div\")  // false\n```\n返回true的，意味着它们拿到的同是cache引用。返回false意味着每次返回都是不一样的object。创建一个动态的NodeList对象比创建一个静态的StaticNodeList对象快。\n","source":"_posts/17-10-14-30.md","raw":"---\ntitle: jQuery源码学习笔记(03)\ndate: 2017-10-14 11:41:59\ntags:\n---\n## CSS选择器\n\n#### 分类\n* 群组选择器：逗号“,”\n```\ndiv, p                //选择所有<div>元素和所有<p>元素\n```\n* 简单选择器：ID、标签、类、属性、通配符\n```\n#test                 //选择id=\"test\"的所有元素\np                     //选择所有<p>元素\n.intro                //选择class=\"intro\"的所有元素\n[target]              //选择带有target属性的所有元素\n[target=_blank]       //选择target=\"_blank\"的所有元素\n[title~=flower]       //选择titl属性包含单词\"flower\"的所有元素\n[lang|=en]            //选择属性值以\"en\"开头的所有元素\na[src^=\"https\"]       //选择src属性值以\"https\"开头的所有<a>元素\na[src$=\".pdf\"]        //选择src属性值以\".pdf\"结尾的所有<a>元素\na[src*=\"abc\"]         //选择src属性值中包含\"abc\"子串的所有<a>元素\n*                     //选择所有元素\n```\n* 关系选择器：孩子、后代、相邻兄弟\n```\ndiv > p               //选择父元素为<div>元素的所有<p>元素\ndiv p                 //选择<div>元素内部的所有<p>元素\ndiv + p               //选择紧接在<div>元素之后的所有<p>元素\np ~ ul                //选择前面有<p>元素的每个<ul>元素\n```\n* 伪类选择器：动作伪类、目标伪类、语言伪类、状态伪类、结构伪类、取反伪类\n```\na:link                //选择所有未被访问的链接\na:visited             //选择所有已被访问链接\na:active              //选择活动链接\na:hover               //选择鼠标指针位于其上的链接\ninput:focus           //选择获得焦点的input元素\n:before               //在每个<p>元素的内容之前插入内容\n:after                //在每个<p>元素的内容之后插入内容\np:lang(it)            //选择带有以\"it\"开头的lang属性值的所有<p>元素\n#news:target          //选择当前活动的#news元素\ninput:enabled         //选择所有启用的<input>元素\ninput:disabled        //选择所有禁用的<input>元素\ninput:checked         //选择所有被选中的<input>元素\n::selection           //选择被用户选取的元素部分\np:first-of-type       //选择属于其父元素的首个<p>元素的所有<p>元素\np:last-of-type        //选择属于其父元素的最后<p>元素的所有<p>元素\np:only-of-type        //选择属于其父元素唯一的<p>元素的所有<p>元素\np:nth-of-type(2)      //选择属于其父元素第二个<p>元素的所有<p>元素\np:only-child          //选择属于其父元素的唯一子元素的所有<p>元素\np:nth-child(2)        //选择属于其父元素的第二个子元素的所有<p>元素\np:last-child          //选择属于其父元素最后一个子元素的所有<p>元素\np:nth-last-child(2)   //同上，从最后一个子元素开始计数\n:root                 //选择文档的根元素\n:empty                //选择没有子元素的所有<p>元素\n:not(p)               //选择非<p>元素的所有元素\n```\n\n#### CSS的解析原理\n\nHTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。\n\n在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。\n\n因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。\n\n如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。\n\n逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。\n\n但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。\n\n#### getElementBy系列 与 querySelectorAll\n\n* getElementById（或者其他）获取的是动态集合，querySelector获取的是静态集合\n\n```html\n<ul>\n  <li>aaa</li>\n  <li>bbb</li>\n  <li>ccc</li>\n</ul>\n```\n```javascript\n// demo1\nvar ul = document.getElementsByTagName('ul')[0],\n    lis = ul.getElementsByTagName('li');\n//动态插入标签\nfor(var i = 0; i < lis.length; i ++) {\n  ul.appendChild(document.creatElement('li'));\n}\nconsole.log(lis.length); //6\n\n// demo2\nvar ul = document.querySeletorAll('ul'),\n    lis = ul.querySelectorAll('li');\n//插入动态标签\nfor(var i = 0; i < lis.length; i ++) {\n  ul.appendChild(document.creatElement('li'));\n}\nconsole.log(lis.length); //3\n```\ndemo1中的lis是一个动态的NodeList，每一次调用lis都会重新对文档进行查询，导致无限循环的问题。\n\ndemo2中的lis是一个静态的NodeList，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。\n\n而在chrome浏览器中\n```javascript\ndocument.querySelectorAll('a').toString();    // return \"[object NodeList]\"\ndocument.getElementsByTagName('a').toString();    // return \"[object HTMLCollection]\"\n```\n在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象。\n\n▼ **什么是NodeList：**\nNodeList本质上是一个动态的Node集合，只是规范中对querySelectorAll有明确要求，规定其必须返回一个静态的NodeList对象。\n\n▼ **什么是HTMLCollection：**\nHTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。\n\nNodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection  对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。\n\n▼ **getElementBy系列的速度比querySelectorAll快：**\n因为getElementById只返回一个元素，而且内部做了缓存，但是querySelectorAll会返回拥有这个id值的多个元素，尽管页面id一般是唯一的，但如果出现了多个同样id的情况下，getElementById还是只返回一个元素，而querySelectorAll会返回多个。\n```javascript\ndocument.getElementsByTagName(\"div\") == document.getElementsByTagName(\"div\")  // true\ndocument.querySelectorAll(\"div\") == document.querySelectorAll(\"div\")  // false\n```\n返回true的，意味着它们拿到的同是cache引用。返回false意味着每次返回都是不一样的object。创建一个动态的NodeList对象比创建一个静态的StaticNodeList对象快。\n","slug":"17-10-14-30","published":1,"updated":"2017-10-14T06:45:29.112Z","_id":"cj8qyj2xk000obgujcjziulwy","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CSS选择器\"><a href=\"#CSS选择器\" class=\"headerlink\" title=\"CSS选择器\"></a>CSS选择器</h2><h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h4><ul>\n<li><p>群组选择器：逗号“,”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">div, p                //选择所有&lt;div&gt;元素和所有&lt;p&gt;元素</div></pre></td></tr></table></figure>\n</li>\n<li><p>简单选择器：ID、标签、类、属性、通配符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#test                 //选择id=&quot;test&quot;的所有元素</div><div class=\"line\">p                     //选择所有&lt;p&gt;元素</div><div class=\"line\">.intro                //选择class=&quot;intro&quot;的所有元素</div><div class=\"line\">[target]              //选择带有target属性的所有元素</div><div class=\"line\">[target=_blank]       //选择target=&quot;_blank&quot;的所有元素</div><div class=\"line\">[title~=flower]       //选择titl属性包含单词&quot;flower&quot;的所有元素</div><div class=\"line\">[lang|=en]            //选择属性值以&quot;en&quot;开头的所有元素</div><div class=\"line\">a[src^=&quot;https&quot;]       //选择src属性值以&quot;https&quot;开头的所有&lt;a&gt;元素</div><div class=\"line\">a[src$=&quot;.pdf&quot;]        //选择src属性值以&quot;.pdf&quot;结尾的所有&lt;a&gt;元素</div><div class=\"line\">a[src*=&quot;abc&quot;]         //选择src属性值中包含&quot;abc&quot;子串的所有&lt;a&gt;元素</div><div class=\"line\">*                     //选择所有元素</div></pre></td></tr></table></figure>\n</li>\n<li><p>关系选择器：孩子、后代、相邻兄弟</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &gt; p               //选择父元素为&lt;div&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">div p                 //选择&lt;div&gt;元素内部的所有&lt;p&gt;元素</div><div class=\"line\">div + p               //选择紧接在&lt;div&gt;元素之后的所有&lt;p&gt;元素</div><div class=\"line\">p ~ ul                //选择前面有&lt;p&gt;元素的每个&lt;ul&gt;元素</div></pre></td></tr></table></figure>\n</li>\n<li><p>伪类选择器：动作伪类、目标伪类、语言伪类、状态伪类、结构伪类、取反伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">a:link                //选择所有未被访问的链接</div><div class=\"line\">a:visited             //选择所有已被访问链接</div><div class=\"line\">a:active              //选择活动链接</div><div class=\"line\">a:hover               //选择鼠标指针位于其上的链接</div><div class=\"line\">input:focus           //选择获得焦点的input元素</div><div class=\"line\">:before               //在每个&lt;p&gt;元素的内容之前插入内容</div><div class=\"line\">:after                //在每个&lt;p&gt;元素的内容之后插入内容</div><div class=\"line\">p:lang(it)            //选择带有以&quot;it&quot;开头的lang属性值的所有&lt;p&gt;元素</div><div class=\"line\">#news:target          //选择当前活动的#news元素</div><div class=\"line\">input:enabled         //选择所有启用的&lt;input&gt;元素</div><div class=\"line\">input:disabled        //选择所有禁用的&lt;input&gt;元素</div><div class=\"line\">input:checked         //选择所有被选中的&lt;input&gt;元素</div><div class=\"line\">::selection           //选择被用户选取的元素部分</div><div class=\"line\">p:first-of-type       //选择属于其父元素的首个&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:last-of-type        //选择属于其父元素的最后&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:only-of-type        //选择属于其父元素唯一的&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:nth-of-type(2)      //选择属于其父元素第二个&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:only-child          //选择属于其父元素的唯一子元素的所有&lt;p&gt;元素</div><div class=\"line\">p:nth-child(2)        //选择属于其父元素的第二个子元素的所有&lt;p&gt;元素</div><div class=\"line\">p:last-child          //选择属于其父元素最后一个子元素的所有&lt;p&gt;元素</div><div class=\"line\">p:nth-last-child(2)   //同上，从最后一个子元素开始计数</div><div class=\"line\">:root                 //选择文档的根元素</div><div class=\"line\">:empty                //选择没有子元素的所有&lt;p&gt;元素</div><div class=\"line\">:not(p)               //选择非&lt;p&gt;元素的所有元素</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS的解析原理\"><a href=\"#CSS的解析原理\" class=\"headerlink\" title=\"CSS的解析原理\"></a>CSS的解析原理</h4><p>HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。</p>\n<p>在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>\n<p>因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。</p>\n<p>如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。</p>\n<p>逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。</p>\n<p>但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。</p>\n<h4 id=\"getElementBy系列-与-querySelectorAll\"><a href=\"#getElementBy系列-与-querySelectorAll\" class=\"headerlink\" title=\"getElementBy系列 与 querySelectorAll\"></a>getElementBy系列 与 querySelectorAll</h4><ul>\n<li>getElementById（或者其他）获取的是动态集合，querySelector获取的是静态集合</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>aaa<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>bbb<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>ccc<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// demo1</span></div><div class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'ul'</span>)[<span class=\"number\">0</span>],</div><div class=\"line\">    lis = ul.getElementsByTagName(<span class=\"string\">'li'</span>);</div><div class=\"line\"><span class=\"comment\">//动态插入标签</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; lis.length; i ++) &#123;</div><div class=\"line\">  ul.appendChild(<span class=\"built_in\">document</span>.creatElement(<span class=\"string\">'li'</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(lis.length); <span class=\"comment\">//6</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// demo2</span></div><div class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.querySeletorAll(<span class=\"string\">'ul'</span>),</div><div class=\"line\">    lis = ul.querySelectorAll(<span class=\"string\">'li'</span>);</div><div class=\"line\"><span class=\"comment\">//插入动态标签</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; lis.length; i ++) &#123;</div><div class=\"line\">  ul.appendChild(<span class=\"built_in\">document</span>.creatElement(<span class=\"string\">'li'</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(lis.length); <span class=\"comment\">//3</span></div></pre></td></tr></table></figure>\n<p>demo1中的lis是一个动态的NodeList，每一次调用lis都会重新对文档进行查询，导致无限循环的问题。</p>\n<p>demo2中的lis是一个静态的NodeList，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。</p>\n<p>而在chrome浏览器中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'a'</span>).toString();    <span class=\"comment\">// return \"[object NodeList]\"</span></div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'a'</span>).toString();    <span class=\"comment\">// return \"[object HTMLCollection]\"</span></div></pre></td></tr></table></figure></p>\n<p>在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象。</p>\n<p>▼ <strong>什么是NodeList：</strong><br>NodeList本质上是一个动态的Node集合，只是规范中对querySelectorAll有明确要求，规定其必须返回一个静态的NodeList对象。</p>\n<p>▼ <strong>什么是HTMLCollection：</strong><br>HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。</p>\n<p>NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection  对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。</p>\n<p>▼ <strong>getElementBy系列的速度比querySelectorAll快：</strong><br>因为getElementById只返回一个元素，而且内部做了缓存，但是querySelectorAll会返回拥有这个id值的多个元素，尽管页面id一般是唯一的，但如果出现了多个同样id的情况下，getElementById还是只返回一个元素，而querySelectorAll会返回多个。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"div\"</span>) == <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"div\"</span>)  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>) == <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>)  <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>返回true的，意味着它们拿到的同是cache引用。返回false意味着每次返回都是不一样的object。创建一个动态的NodeList对象比创建一个静态的StaticNodeList对象快。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CSS选择器\"><a href=\"#CSS选择器\" class=\"headerlink\" title=\"CSS选择器\"></a>CSS选择器</h2><h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h4><ul>\n<li><p>群组选择器：逗号“,”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">div, p                //选择所有&lt;div&gt;元素和所有&lt;p&gt;元素</div></pre></td></tr></table></figure>\n</li>\n<li><p>简单选择器：ID、标签、类、属性、通配符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#test                 //选择id=&quot;test&quot;的所有元素</div><div class=\"line\">p                     //选择所有&lt;p&gt;元素</div><div class=\"line\">.intro                //选择class=&quot;intro&quot;的所有元素</div><div class=\"line\">[target]              //选择带有target属性的所有元素</div><div class=\"line\">[target=_blank]       //选择target=&quot;_blank&quot;的所有元素</div><div class=\"line\">[title~=flower]       //选择titl属性包含单词&quot;flower&quot;的所有元素</div><div class=\"line\">[lang|=en]            //选择属性值以&quot;en&quot;开头的所有元素</div><div class=\"line\">a[src^=&quot;https&quot;]       //选择src属性值以&quot;https&quot;开头的所有&lt;a&gt;元素</div><div class=\"line\">a[src$=&quot;.pdf&quot;]        //选择src属性值以&quot;.pdf&quot;结尾的所有&lt;a&gt;元素</div><div class=\"line\">a[src*=&quot;abc&quot;]         //选择src属性值中包含&quot;abc&quot;子串的所有&lt;a&gt;元素</div><div class=\"line\">*                     //选择所有元素</div></pre></td></tr></table></figure>\n</li>\n<li><p>关系选择器：孩子、后代、相邻兄弟</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &gt; p               //选择父元素为&lt;div&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">div p                 //选择&lt;div&gt;元素内部的所有&lt;p&gt;元素</div><div class=\"line\">div + p               //选择紧接在&lt;div&gt;元素之后的所有&lt;p&gt;元素</div><div class=\"line\">p ~ ul                //选择前面有&lt;p&gt;元素的每个&lt;ul&gt;元素</div></pre></td></tr></table></figure>\n</li>\n<li><p>伪类选择器：动作伪类、目标伪类、语言伪类、状态伪类、结构伪类、取反伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">a:link                //选择所有未被访问的链接</div><div class=\"line\">a:visited             //选择所有已被访问链接</div><div class=\"line\">a:active              //选择活动链接</div><div class=\"line\">a:hover               //选择鼠标指针位于其上的链接</div><div class=\"line\">input:focus           //选择获得焦点的input元素</div><div class=\"line\">:before               //在每个&lt;p&gt;元素的内容之前插入内容</div><div class=\"line\">:after                //在每个&lt;p&gt;元素的内容之后插入内容</div><div class=\"line\">p:lang(it)            //选择带有以&quot;it&quot;开头的lang属性值的所有&lt;p&gt;元素</div><div class=\"line\">#news:target          //选择当前活动的#news元素</div><div class=\"line\">input:enabled         //选择所有启用的&lt;input&gt;元素</div><div class=\"line\">input:disabled        //选择所有禁用的&lt;input&gt;元素</div><div class=\"line\">input:checked         //选择所有被选中的&lt;input&gt;元素</div><div class=\"line\">::selection           //选择被用户选取的元素部分</div><div class=\"line\">p:first-of-type       //选择属于其父元素的首个&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:last-of-type        //选择属于其父元素的最后&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:only-of-type        //选择属于其父元素唯一的&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:nth-of-type(2)      //选择属于其父元素第二个&lt;p&gt;元素的所有&lt;p&gt;元素</div><div class=\"line\">p:only-child          //选择属于其父元素的唯一子元素的所有&lt;p&gt;元素</div><div class=\"line\">p:nth-child(2)        //选择属于其父元素的第二个子元素的所有&lt;p&gt;元素</div><div class=\"line\">p:last-child          //选择属于其父元素最后一个子元素的所有&lt;p&gt;元素</div><div class=\"line\">p:nth-last-child(2)   //同上，从最后一个子元素开始计数</div><div class=\"line\">:root                 //选择文档的根元素</div><div class=\"line\">:empty                //选择没有子元素的所有&lt;p&gt;元素</div><div class=\"line\">:not(p)               //选择非&lt;p&gt;元素的所有元素</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS的解析原理\"><a href=\"#CSS的解析原理\" class=\"headerlink\" title=\"CSS的解析原理\"></a>CSS的解析原理</h4><p>HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。</p>\n<p>在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>\n<p>因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。</p>\n<p>如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。</p>\n<p>逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。</p>\n<p>但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。</p>\n<h4 id=\"getElementBy系列-与-querySelectorAll\"><a href=\"#getElementBy系列-与-querySelectorAll\" class=\"headerlink\" title=\"getElementBy系列 与 querySelectorAll\"></a>getElementBy系列 与 querySelectorAll</h4><ul>\n<li>getElementById（或者其他）获取的是动态集合，querySelector获取的是静态集合</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>aaa<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>bbb<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>ccc<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// demo1</span></div><div class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'ul'</span>)[<span class=\"number\">0</span>],</div><div class=\"line\">    lis = ul.getElementsByTagName(<span class=\"string\">'li'</span>);</div><div class=\"line\"><span class=\"comment\">//动态插入标签</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; lis.length; i ++) &#123;</div><div class=\"line\">  ul.appendChild(<span class=\"built_in\">document</span>.creatElement(<span class=\"string\">'li'</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(lis.length); <span class=\"comment\">//6</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// demo2</span></div><div class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.querySeletorAll(<span class=\"string\">'ul'</span>),</div><div class=\"line\">    lis = ul.querySelectorAll(<span class=\"string\">'li'</span>);</div><div class=\"line\"><span class=\"comment\">//插入动态标签</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; lis.length; i ++) &#123;</div><div class=\"line\">  ul.appendChild(<span class=\"built_in\">document</span>.creatElement(<span class=\"string\">'li'</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(lis.length); <span class=\"comment\">//3</span></div></pre></td></tr></table></figure>\n<p>demo1中的lis是一个动态的NodeList，每一次调用lis都会重新对文档进行查询，导致无限循环的问题。</p>\n<p>demo2中的lis是一个静态的NodeList，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。</p>\n<p>而在chrome浏览器中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'a'</span>).toString();    <span class=\"comment\">// return \"[object NodeList]\"</span></div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'a'</span>).toString();    <span class=\"comment\">// return \"[object HTMLCollection]\"</span></div></pre></td></tr></table></figure></p>\n<p>在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象。</p>\n<p>▼ <strong>什么是NodeList：</strong><br>NodeList本质上是一个动态的Node集合，只是规范中对querySelectorAll有明确要求，规定其必须返回一个静态的NodeList对象。</p>\n<p>▼ <strong>什么是HTMLCollection：</strong><br>HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。</p>\n<p>NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection  对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。</p>\n<p>▼ <strong>getElementBy系列的速度比querySelectorAll快：</strong><br>因为getElementById只返回一个元素，而且内部做了缓存，但是querySelectorAll会返回拥有这个id值的多个元素，尽管页面id一般是唯一的，但如果出现了多个同样id的情况下，getElementById还是只返回一个元素，而querySelectorAll会返回多个。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"div\"</span>) == <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"div\"</span>)  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>) == <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>)  <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>返回true的，意味着它们拿到的同是cache引用。返回false意味着每次返回都是不一样的object。创建一个动态的NodeList对象比创建一个静态的StaticNodeList对象快。</p>\n"},{"title":"页面加载——浏览器渲染","date":"2017-08-19T10:46:53.000Z","_content":"一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n<!--more-->\n\n## 顺序执行、并发加载\n\n因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入`<link>`或`<script>`，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。\n\n对于`<img>`所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。\n\n```javascript\nwindow.addEventListener('load', function() {\n  // 页面的全部资源加载完才会执行，包括图片、视频\n})\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // DOM 渲染完即可执行，此时图片、视频可能还没加载完\n})\n```\n\n## 阻塞\n\n#### CSS阻塞\n* **css在`<head>`中阻塞页面的渲染：**即这个页面要呈现出效果需要等待这个`<link>`所对应的css资源加载完成以后才能进行渲染。如果css并不是在`<head>`中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在`<head>`标签中就引入。\n* **css阻塞js的执行：**即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作`DOM`元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。\n* **css不阻塞外部脚本的加载：**即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在`HTMLPreloadScanner`类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。\n\n#### JS阻塞\n* **直接引入的js阻塞页面的渲染：**直接引入指的是没有通过`defer`和`async`方法直接用`<script>`引入的js资源。如果在标签中指定了`defer`方法，这个资源将在页面解析到`<script>`的时候就开始下载，但不会执行，直到`DOM`加载完成（触发`onload`事件前）才会被调用。而`async`与`defer`的作用是相同的，它们的区别在于`sync`的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作`DOM`元素。\n* **js不阻塞资源的加载：**与css的加载同理，由于有扫描器的存在，资源会并行加载。\n* **js顺序执行，阻塞后续js逻辑的运行：**即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。\n\n## 引入方法\n\n#### 脚本的位置\n\n```html \n<html>\n<head>\n<title>Source Example</title>\n<script type=\"text/javascript\" src=\"script1.js\"></script>\n<script type=\"text/javascript\" src=\"script2.js\"></script>\n<script type=\"text/javascript\" src=\"script3.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n</body>\n</html>\n```\n当我们在`<head>`中引入js文件时，由于js的阻塞特性，当浏览器解析到`<script>`标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。\n```html \n<html>\n<head>\n<title>Source Example</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n\n    <!-- <script> 文件推荐放在这儿 -->\n    <script type=\"text/javascript\" src=\"script1.js\"></script>\n    <script type=\"text/javascript\" src=\"script2.js\"></script>\n    <script type=\"text/javascript\" src=\"script3.js\"></script>\n</body>\n</html>\n```\n所以建议把`<script>`放在`<body>`末尾，因为此时样式和`DOM`元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。\n\n#### 无阻塞脚本\n\n* `defer`属性：是HTML4为`<script>`拓展的属性，指明本元素所含的脚本不会修改`DOM`，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。\n\n```html \n<html>\n<head>\n<title>Script Defer Example</title>\n</head>\n<body>\n    <script type=\"text/javascript\" defer>\n        console.log(\"defer\");\n    </script>\n    <script type=\"text/javascript\">\n        console.log(\"script\");\n    </script>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            console.log(\"load\");\n        };\n    </script>\n</body>\n</html>\n```\n该段代码执行后的结果是`script`、`defer`、`load`，表明含有`defer`属性的脚本是在`onload`执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。\n* `async`属性：是HTML5为`<script>`拓展的属性，作用和`defer`一样，能够异步地加载和执行脚本。它比`defer`有更好的兼容性，但由于`async`在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。\n\n#### 动态脚本\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n该方式可以让`<script>`无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他`DOM`元素是并行的，所以可能出现这个文件中绑定操作的`DOM`元素还没加载，因为找不到而报错。\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.onload = function(){\n  console.log(\"Script loaded!\");\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n在Firefox、Opera、Chrom和Safari 3+中提供了`script.onload`事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即`readystatechange`事件。\n> `uninitialized`：默认状态\n> `loading`：下载开始\n> `loaded`：下载完成\n> `interactive`：下载完成但尚不可用\n> `complete`：所有数据已经准备好 \n\n```javascript\nvar script = document.createElement(\"script\");\nscript.type = \"text/javascript\";\n\n//Internet Explorer\nscript.onreadystatechange = function(){\n  if (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n    script.onreadystatechange = null;\n    console.log(\"Script loaded.\");\n  }\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。\n```javascript\nfunction loadScript(url, callback) {\n  var script = document.creatElement(\"script\");\n  script.type = \"text/javascript\";\n  if(script.readyState) {\n    script.onreadystatechange = function() {\n      if(script.readyState == \"loaded\" || script.readyState == \"complete\") {\n        script.onreadystatechange = null;\n        callback();\n      }\n    }\n  } else {\n    script.onload = function() {\n      callback();\n    }\n  }\n  script.src = url;\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n```\n如此就可以通过嵌套调用来保证他们的加载顺序：\n```javascript\nloadScript(\"script1.js\",function() {\n  loadScript(\"script2.js\",function() {\n\talert(\"all files are loaded!\");\n  })\n})\n```\n\n#### XMLHttpRequest(XHR)对象\n\n可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。\n\n","source":"_posts/17-08-19-24.md","raw":"---\ntitle: 页面加载——浏览器渲染\ndate: 2017-08-19 18:46:53\ntags:\n---\n一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n<!--more-->\n\n## 顺序执行、并发加载\n\n因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入`<link>`或`<script>`，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。\n\n对于`<img>`所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。\n\n```javascript\nwindow.addEventListener('load', function() {\n  // 页面的全部资源加载完才会执行，包括图片、视频\n})\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // DOM 渲染完即可执行，此时图片、视频可能还没加载完\n})\n```\n\n## 阻塞\n\n#### CSS阻塞\n* **css在`<head>`中阻塞页面的渲染：**即这个页面要呈现出效果需要等待这个`<link>`所对应的css资源加载完成以后才能进行渲染。如果css并不是在`<head>`中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在`<head>`标签中就引入。\n* **css阻塞js的执行：**即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作`DOM`元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。\n* **css不阻塞外部脚本的加载：**即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在`HTMLPreloadScanner`类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。\n\n#### JS阻塞\n* **直接引入的js阻塞页面的渲染：**直接引入指的是没有通过`defer`和`async`方法直接用`<script>`引入的js资源。如果在标签中指定了`defer`方法，这个资源将在页面解析到`<script>`的时候就开始下载，但不会执行，直到`DOM`加载完成（触发`onload`事件前）才会被调用。而`async`与`defer`的作用是相同的，它们的区别在于`sync`的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作`DOM`元素。\n* **js不阻塞资源的加载：**与css的加载同理，由于有扫描器的存在，资源会并行加载。\n* **js顺序执行，阻塞后续js逻辑的运行：**即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。\n\n## 引入方法\n\n#### 脚本的位置\n\n```html \n<html>\n<head>\n<title>Source Example</title>\n<script type=\"text/javascript\" src=\"script1.js\"></script>\n<script type=\"text/javascript\" src=\"script2.js\"></script>\n<script type=\"text/javascript\" src=\"script3.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n</body>\n</html>\n```\n当我们在`<head>`中引入js文件时，由于js的阻塞特性，当浏览器解析到`<script>`标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。\n```html \n<html>\n<head>\n<title>Source Example</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n\n    <!-- <script> 文件推荐放在这儿 -->\n    <script type=\"text/javascript\" src=\"script1.js\"></script>\n    <script type=\"text/javascript\" src=\"script2.js\"></script>\n    <script type=\"text/javascript\" src=\"script3.js\"></script>\n</body>\n</html>\n```\n所以建议把`<script>`放在`<body>`末尾，因为此时样式和`DOM`元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。\n\n#### 无阻塞脚本\n\n* `defer`属性：是HTML4为`<script>`拓展的属性，指明本元素所含的脚本不会修改`DOM`，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。\n\n```html \n<html>\n<head>\n<title>Script Defer Example</title>\n</head>\n<body>\n    <script type=\"text/javascript\" defer>\n        console.log(\"defer\");\n    </script>\n    <script type=\"text/javascript\">\n        console.log(\"script\");\n    </script>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            console.log(\"load\");\n        };\n    </script>\n</body>\n</html>\n```\n该段代码执行后的结果是`script`、`defer`、`load`，表明含有`defer`属性的脚本是在`onload`执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。\n* `async`属性：是HTML5为`<script>`拓展的属性，作用和`defer`一样，能够异步地加载和执行脚本。它比`defer`有更好的兼容性，但由于`async`在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。\n\n#### 动态脚本\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n该方式可以让`<script>`无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他`DOM`元素是并行的，所以可能出现这个文件中绑定操作的`DOM`元素还没加载，因为找不到而报错。\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.onload = function(){\n  console.log(\"Script loaded!\");\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n在Firefox、Opera、Chrom和Safari 3+中提供了`script.onload`事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即`readystatechange`事件。\n> `uninitialized`：默认状态\n> `loading`：下载开始\n> `loaded`：下载完成\n> `interactive`：下载完成但尚不可用\n> `complete`：所有数据已经准备好 \n\n```javascript\nvar script = document.createElement(\"script\");\nscript.type = \"text/javascript\";\n\n//Internet Explorer\nscript.onreadystatechange = function(){\n  if (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n    script.onreadystatechange = null;\n    console.log(\"Script loaded.\");\n  }\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。\n```javascript\nfunction loadScript(url, callback) {\n  var script = document.creatElement(\"script\");\n  script.type = \"text/javascript\";\n  if(script.readyState) {\n    script.onreadystatechange = function() {\n      if(script.readyState == \"loaded\" || script.readyState == \"complete\") {\n        script.onreadystatechange = null;\n        callback();\n      }\n    }\n  } else {\n    script.onload = function() {\n      callback();\n    }\n  }\n  script.src = url;\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n```\n如此就可以通过嵌套调用来保证他们的加载顺序：\n```javascript\nloadScript(\"script1.js\",function() {\n  loadScript(\"script2.js\",function() {\n\talert(\"all files are loaded!\");\n  })\n})\n```\n\n#### XMLHttpRequest(XHR)对象\n\n可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。\n\n","slug":"17-08-19-24","published":1,"updated":"2017-10-05T16:03:55.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2xl000pbgujbxb05r0i","content":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"顺序执行、并发加载\"><a href=\"#顺序执行、并发加载\" class=\"headerlink\" title=\"顺序执行、并发加载\"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>\n<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 页面的全部资源加载完才会执行，包括图片、视频</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><h4 id=\"CSS阻塞\"><a href=\"#CSS阻塞\" class=\"headerlink\" title=\"CSS阻塞\"></a>CSS阻塞</h4><ul>\n<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>\n<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>\n<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>\n</ul>\n<h4 id=\"JS阻塞\"><a href=\"#JS阻塞\" class=\"headerlink\" title=\"JS阻塞\"></a>JS阻塞</h4><ul>\n<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>\n<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>\n<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>\n</ul>\n<h2 id=\"引入方法\"><a href=\"#引入方法\" class=\"headerlink\" title=\"引入方法\"></a>引入方法</h2><h4 id=\"脚本的位置\"><a href=\"#脚本的位置\" class=\"headerlink\" title=\"脚本的位置\"></a>脚本的位置</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"styles.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>\n<h4 id=\"无阻塞脚本\"><a href=\"#无阻塞脚本\" class=\"headerlink\" title=\"无阻塞脚本\"></a>无阻塞脚本</h4><ul>\n<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Script Defer Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"defer\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"load\"</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>\n<ul>\n<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>\n</ul>\n<h4 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>\n<blockquote>\n<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Internet Explorer</span></div><div class=\"line\">script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>)&#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded.\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">  script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span>(script.readyState) &#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>) &#123;</div><div class=\"line\">        script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">        callback();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      callback();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  script.src = url;</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loadScript(<span class=\"string\">\"script1.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  loadScript(<span class=\"string\">\"script2.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"string\">\"all files are loaded!\"</span>);</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"XMLHttpRequest-XHR-对象\"><a href=\"#XMLHttpRequest-XHR-对象\" class=\"headerlink\" title=\"XMLHttpRequest(XHR)对象\"></a>XMLHttpRequest(XHR)对象</h4><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>\n","site":{"data":{}},"excerpt":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染","more":"</li>\n</ul>\n<h2 id=\"顺序执行、并发加载\"><a href=\"#顺序执行、并发加载\" class=\"headerlink\" title=\"顺序执行、并发加载\"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>\n<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 页面的全部资源加载完才会执行，包括图片、视频</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><h4 id=\"CSS阻塞\"><a href=\"#CSS阻塞\" class=\"headerlink\" title=\"CSS阻塞\"></a>CSS阻塞</h4><ul>\n<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>\n<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>\n<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>\n</ul>\n<h4 id=\"JS阻塞\"><a href=\"#JS阻塞\" class=\"headerlink\" title=\"JS阻塞\"></a>JS阻塞</h4><ul>\n<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>\n<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>\n<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>\n</ul>\n<h2 id=\"引入方法\"><a href=\"#引入方法\" class=\"headerlink\" title=\"引入方法\"></a>引入方法</h2><h4 id=\"脚本的位置\"><a href=\"#脚本的位置\" class=\"headerlink\" title=\"脚本的位置\"></a>脚本的位置</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"styles.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>\n<h4 id=\"无阻塞脚本\"><a href=\"#无阻塞脚本\" class=\"headerlink\" title=\"无阻塞脚本\"></a>无阻塞脚本</h4><ul>\n<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Script Defer Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"defer\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"load\"</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>\n<ul>\n<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>\n</ul>\n<h4 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>\n<blockquote>\n<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Internet Explorer</span></div><div class=\"line\">script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>)&#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded.\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">  script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span>(script.readyState) &#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>) &#123;</div><div class=\"line\">        script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">        callback();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      callback();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  script.src = url;</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loadScript(<span class=\"string\">\"script1.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  loadScript(<span class=\"string\">\"script2.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"string\">\"all files are loaded!\"</span>);</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"XMLHttpRequest-XHR-对象\"><a href=\"#XMLHttpRequest-XHR-对象\" class=\"headerlink\" title=\"XMLHttpRequest(XHR)对象\"></a>XMLHttpRequest(XHR)对象</h4><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>"},{"title":"JS定时器与单线程","date":"2017-09-25T13:28:25.000Z","_content":"## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n#### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n#### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","source":"_posts/17-09-25-26.md","raw":"---\ntitle: JS定时器与单线程\ndate: 2017-09-25 21:28:25\ntags:\n---\n## JavaScript单线程\n\n众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。\n\n这里有个例子：\n```javascript\nvar date = new Date();\n//打印才进入时的时间\nconsole.log('first time: ' + date.getTime());\n//一秒后打印setTimeout里匿名函数的时间\nsetTimeout(function(){\n  var date1 = new Date();\n  console.log('second time: ' + date1.getTime() );\n  console.log( date1.getTime() - date.getTime() );\n},1000);\n//重复操作\nfor(var i=0; i < 10000 ; i++){\n  console.log(1);\n}\n```\n\n`setTimeout`是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。\n\n其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以`setTimeout`只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。\n\n但是这里仍然有一个疑问，假设`setTimeout`后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那`setTimeout`会在紧跟着的第一个函数执行完就插队执行吗？\n\n```javascript\nvar startTime = new Date();\nsetTimeout(function() {\n  console.log(\"hellow world\");\n}, 1000);\nwhile(new Date() - startTime < 1000) {}\nconsole.log(\"wait\");\nwhile(true) {}\n```\n\n答案是并不会，`setTimeout`只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出`hellow world`。\n\n## JavaScript运行机制\n\n我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n所以当一段代码有异步操作时，执行过程是这样的：\n\n* 所有同步任务都在主线程上执行，形成一个执行栈。\n* 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。\n* 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。\n* 主线程不断重复上面的第三步。\n\n所以，**只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。**\n\n## 任务队列\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。\n\n主线程不断从“任务队列”中读取事件的过程又称为**Event Loop**。\n\n## setTimeout与setInterval\n\n#### setTimeout\n\n关于`setTimeout`在上述已经说的蛮清楚了，还有一点是关于`setTimeout(func,0)`。\n当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，`setTimeout(func,0)`相当于插了队。\n\n#### setInterval\n\n`setInterval`是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他**代码实例**时，才能将定时器代码添加到任务队列中。\n\n假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时`setInterval`的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。\n\n```javascript\nsetInterval(function() {\n  var startTime = new Date();\n  while(Date.now - startTime < 350) {}\n}, 200);\nvar startTime = new Date();\nwhile(Date.now() - startTime < 300) {}\n```\n\n由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png)\n\n在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。\n\n所以在使用setInterval做动画时要注意两个问题：\n\n* 不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间\n* 如果主进程运行时间过长，会出现跳帧的现象\n\n为了避免setInterval的两个缺点，可以使用链式`setTimeout()`：\n```\nsetTimeout(function(){     //其他处理\n  setTimeout(arguments.callee, interval); }, interval);\n```\n\n文章参考：\n[Javascript定时器学习笔记](https://yq.aliyun.com/wenji/1646)\n[阮一峰 —— JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","slug":"17-09-25-26","published":1,"updated":"2017-10-05T16:03:55.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8qyj2xm000qbgujze0jc6ka","content":"<h2 id=\"JavaScript单线程\"><a href=\"#JavaScript单线程\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>\n<p>这里有个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"comment\">//打印才进入时的时间</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'first time: '</span> + date.getTime());</div><div class=\"line\"><span class=\"comment\">//一秒后打印setTimeout里匿名函数的时间</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> date1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'second time: '</span> + date1.getTime() );</div><div class=\"line\">  <span class=\"built_in\">console</span>.log( date1.getTime() - date.getTime() );</div><div class=\"line\">&#125;,<span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"comment\">//重复操作</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span> ; i++)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>setTimeout</code>是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。</p>\n<p>其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以<code>setTimeout</code>只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。</p>\n<p>但是这里仍然有一个疑问，假设<code>setTimeout</code>后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那<code>setTimeout</code>会在紧跟着的第一个函数执行完就插队执行吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hellow world\"</span>);</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - startTime &lt; <span class=\"number\">1000</span>) &#123;&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"wait\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>答案是并不会，<code>setTimeout</code>只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出<code>hellow world</code>。</p>\n<h2 id=\"JavaScript运行机制\"><a href=\"#JavaScript运行机制\" class=\"headerlink\" title=\"JavaScript运行机制\"></a>JavaScript运行机制</h2><p>我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<p>所以当一段代码有异步操作时，执行过程是这样的：</p>\n<ul>\n<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>\n<li>主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。</li>\n<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。</li>\n<li>主线程不断重复上面的第三步。</li>\n</ul>\n<p>所以，<strong>只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。</strong></p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>\n<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p>\n<p>主线程不断从“任务队列”中读取事件的过程又称为<strong>Event Loop</strong>。</p>\n<h2 id=\"setTimeout与setInterval\"><a href=\"#setTimeout与setInterval\" class=\"headerlink\" title=\"setTimeout与setInterval\"></a>setTimeout与setInterval</h2><h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><p>关于<code>setTimeout</code>在上述已经说的蛮清楚了，还有一点是关于<code>setTimeout(func,0)</code>。<br>当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，<code>setTimeout(func,0)</code>相当于插了队。</p>\n<h4 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h4><p><code>setInterval</code>是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他<strong>代码实例</strong>时，才能将定时器代码添加到任务队列中。</p>\n<p>假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时<code>setInterval</code>的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now - startTime &lt; <span class=\"number\">350</span>) &#123;&#125;</div><div class=\"line\">&#125;, <span class=\"number\">200</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now() - startTime &lt; <span class=\"number\">300</span>) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png\" alt=\"\"></p>\n<p>在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。</p>\n<p>所以在使用setInterval做动画时要注意两个问题：</p>\n<ul>\n<li>不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间</li>\n<li>如果主进程运行时间过长，会出现跳帧的现象</li>\n</ul>\n<p>为了避免setInterval的两个缺点，可以使用链式<code>setTimeout()</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(function()&#123;     //其他处理</div><div class=\"line\">  setTimeout(arguments.callee, interval); &#125;, interval);</div></pre></td></tr></table></figure></p>\n<p>文章参考：<br><a href=\"https://yq.aliyun.com/wenji/1646\" target=\"_blank\" rel=\"external\">Javascript定时器学习笔记</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"external\">阮一峰 —— JavaScript 运行机制详解：再谈Event Loop</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JavaScript单线程\"><a href=\"#JavaScript单线程\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>众所周知，JavaScript语言是单线程的，简而言之就是在同一时间内只能执行一段代码，如果这段代码很长很长，后续的代码也只能等待前一段代码执行完才能够执行。</p>\n<p>这里有个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"comment\">//打印才进入时的时间</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'first time: '</span> + date.getTime());</div><div class=\"line\"><span class=\"comment\">//一秒后打印setTimeout里匿名函数的时间</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> date1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'second time: '</span> + date1.getTime() );</div><div class=\"line\">  <span class=\"built_in\">console</span>.log( date1.getTime() - date.getTime() );</div><div class=\"line\">&#125;,<span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"comment\">//重复操作</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span> ; i++)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>setTimeout</code>是一个定时器，设定在1000ms之后运行定义的回调函数，但是从上一个例子可以得到，执行回调函数的时间与代码开始执行的时间间隔并不是1000ms，而是大于1000ms。</p>\n<p>其中的原因便是因为JavaScript是单线程的，在1000ms的时候主线程正在执行for循环，所以<code>setTimeout</code>只能等待for循环执行完毕之后才能执行，时间自然超过了1000ms。</p>\n<p>但是这里仍然有一个疑问，假设<code>setTimeout</code>后续还有两个函数，一个函数的执行时间是1000ms，另一个是2000ms，那<code>setTimeout</code>会在紧跟着的第一个函数执行完就插队执行吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hellow world\"</span>);</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - startTime &lt; <span class=\"number\">1000</span>) &#123;&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"wait\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>答案是并不会，<code>setTimeout</code>只有在后续代码全部执行完之后才会执行它的回调函数，所以以上的代码永远也无法打印出<code>hellow world</code>。</p>\n<h2 id=\"JavaScript运行机制\"><a href=\"#JavaScript运行机制\" class=\"headerlink\" title=\"JavaScript运行机制\"></a>JavaScript运行机制</h2><p>我们可以将运行的任务分成两组，一种是同步任务，一种是异步任务。同步任务是指在主线程上排队执行的任务，只有前一个任务执行完，才能执行后一个任务；异步任务指的是，不进入主线程、而是进入“任务队列”的任务。只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<p>所以当一段代码有异步操作时，执行过程是这样的：</p>\n<ul>\n<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>\n<li>主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就不在“任务队列”中放置一个事件。</li>\n<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面面有哪些事件。那些对应的异步任务，结束等待状态，进入执行栈开始执行。</li>\n<li>主线程不断重复上面的第三步。</li>\n</ul>\n<p>所以，<strong>只有在主线程任务执行完毕之后，系统才会去读取“任务队列”。</strong></p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>\n<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p>\n<p>主线程不断从“任务队列”中读取事件的过程又称为<strong>Event Loop</strong>。</p>\n<h2 id=\"setTimeout与setInterval\"><a href=\"#setTimeout与setInterval\" class=\"headerlink\" title=\"setTimeout与setInterval\"></a>setTimeout与setInterval</h2><h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><p>关于<code>setTimeout</code>在上述已经说的蛮清楚了，还有一点是关于<code>setTimeout(func,0)</code>。<br>当设置定时器为0ms时，回调函数func也不会再0ms的时候就执行，而是采取尽可能快的执行。即当主线程程序都执行完毕，进入空闲就会立刻执行func。而相对于还在任务队列中的其他等待的程序，<code>setTimeout(func,0)</code>相当于插了队。</p>\n<h4 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h4><p><code>setInterval</code>是重复定时器，它在执行的时候有一条规则：仅当没有该定时器的任何其他<strong>代码实例</strong>时，才能将定时器代码添加到任务队列中。</p>\n<p>假设没有这条规则，因为指定的时间是定时器插入到任务队列的时间，如果主线程的运行时间非常长，此时<code>setInterval</code>的回调函数被多次插入到任务队列中，当主线程空闲时，定时器便会连续执行措辞而之间不会有任何的间隔。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now - startTime &lt; <span class=\"number\">350</span>) &#123;&#125;</div><div class=\"line\">&#125;, <span class=\"number\">200</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">Date</span>.now() - startTime &lt; <span class=\"number\">300</span>) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>由于存在上述所说的规则，某些间隔会被跳过，多个定时器的代码执行之间的间隔可能会比预期的小。我们可以画一个流程图：</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/settimeout.png\" alt=\"\"></p>\n<p>在605ms处第一个定时器代码仍然在运行，同时在代码队列中已经有了另一个定时器的代码实例。所以在这个时间点上的定时器代码 不会被添加到队列中。</p>\n<p>所以在使用setInterval做动画时要注意两个问题：</p>\n<ul>\n<li>不能使用固定步长作为做动画，一定要使用百分比: 开始值 + (目标值 - 开始值) * （Date.now() - 开始时间）/ 时间区间</li>\n<li>如果主进程运行时间过长，会出现跳帧的现象</li>\n</ul>\n<p>为了避免setInterval的两个缺点，可以使用链式<code>setTimeout()</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(function()&#123;     //其他处理</div><div class=\"line\">  setTimeout(arguments.callee, interval); &#125;, interval);</div></pre></td></tr></table></figure></p>\n<p>文章参考：<br><a href=\"https://yq.aliyun.com/wenji/1646\" target=\"_blank\" rel=\"external\">Javascript定时器学习笔记</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"external\">阮一峰 —— JavaScript 运行机制详解：再谈Event Loop</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}