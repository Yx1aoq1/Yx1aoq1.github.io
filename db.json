{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/canvas-img-1.png","path":"images/canvas-img-1.png","modified":1,"renderable":0},{"_id":"source/images/http-2.png","path":"images/http-2.png","modified":1,"renderable":0},{"_id":"source/images/http.png","path":"images/http.png","modified":1,"renderable":0},{"_id":"source/images/iconfont-img-3.png","path":"images/iconfont-img-3.png","modified":1,"renderable":0},{"_id":"source/images/iconfont-img-2.png","path":"images/iconfont-img-2.png","modified":1,"renderable":0},{"_id":"source/images/iconfont-img-4.png","path":"images/iconfont-img-4.png","modified":1,"renderable":0},{"_id":"source/images/jicheng-1.png","path":"images/jicheng-1.png","modified":1,"renderable":0},{"_id":"source/images/jicheng-2.png","path":"images/jicheng-2.png","modified":1,"renderable":0},{"_id":"source/images/stack&heap-1.png","path":"images/stack&heap-1.png","modified":1,"renderable":0},{"_id":"source/images/stack&heap-2.png","path":"images/stack&heap-2.png","modified":1,"renderable":0},{"_id":"source/images/stack&heap-3.png","path":"images/stack&heap-3.png","modified":1,"renderable":0},{"_id":"source/images/variable-1.png","path":"images/variable-1.png","modified":1,"renderable":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"source/images/iconfont-img-1.png","path":"images/iconfont-img-1.png","modified":1,"renderable":0},{"_id":"source/images/prototype.png","path":"images/prototype.png","modified":1,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1}],"Cache":[{"_id":"source/favicon.ico","hash":"9ff098fa25054b2bfd02874e7c2ba35e11643396","modified":1490344847838},{"_id":"themes/apollo/.gitignore","hash":"d6cc8c2730e89bbee83e01a5a4490f8dbf12c332","modified":1500099972134},{"_id":"themes/apollo/LICENSE","hash":"1588511f0c37609ebfb55298b83a77ae5afca870","modified":1500099972148},{"_id":"themes/apollo/README.md","hash":"bee45e9d6e41f6b9c01bc38f26bc60ba19c825f7","modified":1500099972161},{"_id":"themes/apollo/_config.yml","hash":"e32d62a2327fa0916cd9fb1a52161e0a01e84984","modified":1500105785331},{"_id":"themes/apollo/gulpfile.js","hash":"3bf61bca569665944cc61ac0483c9d568a4f58d7","modified":1500099972227},{"_id":"themes/apollo/package.json","hash":"2e81f69d66c01a6bfaacbd8bd7324b370acbed88","modified":1500099972434},{"_id":"source/_posts/17-02-28-1.md","hash":"ffee1fcdccca1009fbbe38c43488d8d2c0a8c299","modified":1500100989259},{"_id":"source/_posts/17-02-28-2.md","hash":"5fe373bf1a4448dab304226102400e1d622b9a66","modified":1500104858323},{"_id":"source/_posts/17-03-20-4.md","hash":"cd3ced56acb865dd5038d10a51151d1cc3f70c3a","modified":1500104864984},{"_id":"source/_posts/17-03-21-5.md","hash":"33bbd338a6859f614a67b712902fe954c3bdd632","modified":1500104869278},{"_id":"source/_posts/17-03-21-6.md","hash":"2a147ea41f8298d6b5823b5fc61cb98fa26198ac","modified":1500104873310},{"_id":"source/_posts/17-03-26-7.md","hash":"2bb8d08c5ce6590fa7432d5b7fb47639a840d743","modified":1500104876264},{"_id":"source/_posts/17-03-28-8.md","hash":"4cd3ff99d633e0eedd2ad67ff8501b8b465aaf7b","modified":1500104879919},{"_id":"source/_posts/17-03-29-9.md","hash":"0e9051991414cbc09b60918144e02eb1701373df","modified":1500104883362},{"_id":"source/_posts/17-04-06-11.md","hash":"c4618dd864c2a5d9b11e0a20b8cf36129b6f2454","modified":1500104886485},{"_id":"source/_posts/17-04-06-12.md","hash":"73a4e735ef9c0b4f728407641caf1a8efa9bbeac","modified":1500104889556},{"_id":"source/_posts/17-04-10-13.md","hash":"67977023412e32a36c6e7abf86b8b47bd09207b9","modified":1500104893599},{"_id":"source/_posts/17-04-21-14.md","hash":"379ff6b41ddd70e980bc545cd2e3be5a387399bb","modified":1500104897044},{"_id":"source/_posts/17-05-11-16.md","hash":"cd9b2191af2aa5a898c77d7a0b01c5aaec4ba820","modified":1500104900971},{"_id":"source/_posts/17-07-07-17.md","hash":"acd7aa1015cf1d09709e6a26c10aaec90f7bafbe","modified":1502889121586},{"_id":"source/_posts/17-07-08-18.md","hash":"b984783e173cd61ee5a62880e38c1b4ae2a213df","modified":1502889059064},{"_id":"source/_posts/17-07-15-19.md","hash":"913fefb20a31bec431acbe230bb6a612cc7e3209","modified":1502886399329},{"_id":"source/_posts/17-07-15-20.md","hash":"2a80c7d744715a02b63ca6ca48191a74ca6b737d","modified":1502886541670},{"_id":"source/_posts/17-08-15-21.md","hash":"2ad5492553f1d0c83acc5c4c8f9f2007979cc542","modified":1502888514953},{"_id":"source/_posts/17-08-16-22.md","hash":"0f0ddb93f1b002a3ad5dfc1cfab6cd82a9250bd2","modified":1503213232825},{"_id":"source/_posts/17-08-17-23.md","hash":"a8c842d62fddc77f7ad4696aa8a4058499f566c3","modified":1503139265124},{"_id":"source/_posts/17-08-19-24.md","hash":"7a0269bd717d560b595a0e42bddc61dd869c4d02","modified":1503212695381},{"_id":"source/images/avatar.jpg","hash":"b2cd72c603ca58a27504c4744bb78de605adf456","modified":1435394447271},{"_id":"source/images/canvas-img-1.png","hash":"79357cc2687e1f19ebb11c7f5d3ed032ecaf9ee7","modified":1493101204674},{"_id":"source/images/http-2.png","hash":"a52a2cc5f95862f59c494c4f285098bca833f2f6","modified":1503129223746},{"_id":"source/images/http.png","hash":"8bd1247192e8b695a72657fec3c44b95092dcdf5","modified":1503124537019},{"_id":"source/images/iconfont-img-3.png","hash":"379845359d10d9578bff906cc328b00f18683b34","modified":1490491239294},{"_id":"source/images/iconfont-img-2.png","hash":"4f9c43a8d9b5a498dadcd1e7982d8c464b60462b","modified":1490491207238},{"_id":"source/images/iconfont-img-4.png","hash":"32eac83fe1450db586186a0e51e83f68db694ca3","modified":1490491263289},{"_id":"source/images/jicheng-1.png","hash":"405f7177225c5f12a289603689ccbb51a428a80f","modified":1499443454186},{"_id":"source/images/jicheng-2.png","hash":"35606fc921e2a7f254235f72234add1136ca7fb9","modified":1499492510314},{"_id":"source/images/stack&heap-1.png","hash":"4ed0fef087862dff2c7aa0d39e475a89f508e08e","modified":1502887366861},{"_id":"source/images/stack&heap-2.png","hash":"e8413df1ec7ce0649f2fa65bce3eafd6502fd2f5","modified":1502887795242},{"_id":"source/images/stack&heap-3.png","hash":"436d00a04593ec48893bf28136880239e0f6da39","modified":1502887804400},{"_id":"source/images/variable-1.png","hash":"426cb0d62af8bf6fa08b56e56b9fd91de9d5401e","modified":1502888097846},{"_id":"themes/apollo/doc/doc-en.md","hash":"123aa670151db03ba5b1a20eaeef2cd3c9bec2b9","modified":1500099972188},{"_id":"themes/apollo/doc/doc-zh.md","hash":"f2ef939e9b39d4d150d613f68a80ca65425d406a","modified":1500099972202},{"_id":"themes/apollo/languages/en.yml","hash":"29b8e211d422cb846af005bd1c21435b45ed6457","modified":1500099972239},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"05ef430fa5586e919839bad35aba4a9690e8e672","modified":1500099972250},{"_id":"themes/apollo/layout/archive.jade","hash":"a993dddad0213cfc4adbf5d25597b7effac758b0","modified":1500099972265},{"_id":"themes/apollo/layout/index.jade","hash":"fd11746c566d9fb6de1224a2992e3e443a83c139","modified":1500099972280},{"_id":"themes/apollo/layout/post.jade","hash":"ada9f5f76819ff76d2c37c893431dfdb808e19b7","modified":1500099972422},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1500099972452},{"_id":"source/images/iconfont-img-1.png","hash":"845102fc4a31fb67e15b1395f99b3d7aeec307e2","modified":1490491145257},{"_id":"source/images/prototype.png","hash":"99ddac4ff9725edf9afb918ba03f7773655391d0","modified":1502974365708},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"47712f8bb3d84ff6a2742f923626d568779fc45a","modified":1500099972294},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"b9a6ca7d8769312cef09c86dbd6828bc04663ca2","modified":1500099972315},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"a9bd772bb172ba0c54d872d2d3364ff89d762ffb","modified":1500099972345},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"185aa2a3f86176b4924adac06ef576b365440c20","modified":1500099972356},{"_id":"themes/apollo/layout/partial/head.jade","hash":"bc1fb13056ea07b3832ed563c680ffe619d44dd9","modified":1500099972367},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"a49c19346dee6886ac8b37a1321ce170e627129a","modified":1500099972379},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"b43b1166601669cd6467bebf343efc1e5a253d64","modified":1500099972390},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"e309aff22fa5823aa65667cf2f189bd05adeb62a","modified":1500099972411},{"_id":"themes/apollo/source/css/apollo.css","hash":"a9072992f3a03003fb0ada9fb2d6d76386f066ad","modified":1500099972449},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1500099972467},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1500099972482},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"bea961e9c85a0eba26b34d5568f165f48fbc9bdb","modified":1500099972607},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"4ede69b12919439b4ae404a1e1d498cb8fd2932a","modified":1500099972508},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"3003361c281d7aa1cfed944ad0da180ac05f2c32","modified":1500099972496},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"e87b144a8389eefeab4f50c353eef18c428a761c","modified":1500099972519},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"8cd2631d46be05a9518f1966bd84e1a8b0270857","modified":1500099972532},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"a6aeb5177f370f984565f7b6f0a18fe27545d34d","modified":1500099972544},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"658eef39c7cf6f730f784751c2e4701e8eb02e0d","modified":1500099972556},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"25f38fb71ade373416af569558d56e4c2e692700","modified":1500099972572},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"612b367b0e9a0b9f66d37694ee64ce896c552967","modified":1500099972584},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"85e5dded04b7229ab4345e53473d4e9e9cbdbfb5","modified":1500099972596}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"这磨人的小妖精","date":"2017-02-27T18:17:03.000Z","_content":"\n终于！把！这个！磨人的！小妖精！建好了！！\n超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=\n大概是我太蠢了才会弄这么久哦，好气哦\n好了我要努力读书去了\n\n<!--more-->\n","source":"_posts/17-02-28-1.md","raw":"---\ntitle: 这磨人的小妖精\ndate: 2017-02-28 02:17:03\n---\n\n终于！把！这个！磨人的！小妖精！建好了！！\n超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=\n大概是我太蠢了才会弄这么久哦，好气哦\n好了我要努力读书去了\n\n<!--more-->\n","slug":"17-02-28-1","published":1,"updated":"2017-07-15T06:43:09.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecoc10000t0cg0oon2xcv","content":"<p>终于！把！这个！磨人的！小妖精！建好了！！<br>超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=<br>大概是我太蠢了才会弄这么久哦，好气哦<br>好了我要努力读书去了</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>终于！把！这个！磨人的！小妖精！建好了！！<br>超累超心痛的熬夜到四点，连银魂都忘记看了！大早上又接着起来捣鼓 =。=<br>大概是我太蠢了才会弄这么久哦，好气哦<br>好了我要努力读书去了</p>","more":""},{"title":"Sublime Text3前端插件分享","date":"2017-02-28T08:05:18.000Z","_content":"\n自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利\n\n<!--more-->\n\n***\n*  **Emmet:** \n快速编写HTML+CSS代码，快捷键**ctrl+E**\n[关于如何速写的教程](http://www.iteye.com/news/27580)\n*  **All Autocomplete:**\n搜索所有打开的文件来寻找匹配的提示词\n* **AutoFileName:**\n自动检索并补齐文件路径\n* **CSScomb:**\n使用指定排序方法对CSS的属性进行排序，快捷键**ctrl+alt+C**\n虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法\n* **HTML-CSS-JS Prettify:**\n美化代码格式，需要安装node.js才能使用，快捷键**ctrl+alt+H**，可以自动对齐\n* **ColorHighlighter:**\n可以显示颜色代码的颜色，看上去一目了然\n* **BracketHighlighter:**\n括号以及标签层级显示\n* **Sidebarenhancements:**\n扩展鼠标右键菜单，可以直接open with浏览器，超方便\n* **SublimeCodeIntel:**\n可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上\n\n打开*Package Settings > SublimeCodeIntel > Key Bindings - User*,输入代码\n```python\n[\n\t{ \n\t\t\"keys\": [\";\"], \"command\": \"run_macro_file\", \n\t  \t\"args\": {\"file\": \"Packages/User/unAutoSemiColon.sublime-macro\"} \n\t}\n]\n```\n然后打开 *Preferences > Browser Package > User*，保存文件名为*unAutoSemiColon.sublime-macro*\n```python\n[\n    {\n        \"args\":\n        {\n            \"characters\": \";\"\n        },\n        \"command\": \"insert\"\n    }\n]\n```\n之后打分号再也不会出现提示啦！！\n* **SublimeTmpl:**\n可以快速创建代码模板\n**ctrl+shift+H** HTML模板\n**ctrl+shift+C** CSS模板\n**ctrl+shift+J** Javascript模板\n**ctrl+shift+P** php模板\n*  **Colorsublime:**\n更换主题的插件，含有很多主题配色方案，偶尔转换一下心情\n***\n","source":"_posts/17-02-28-2.md","raw":"---\ntitle: Sublime Text3前端插件分享\ndate: 2017-02-28 16:05:18\n---\n\n自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利\n\n<!--more-->\n\n***\n*  **Emmet:** \n快速编写HTML+CSS代码，快捷键**ctrl+E**\n[关于如何速写的教程](http://www.iteye.com/news/27580)\n*  **All Autocomplete:**\n搜索所有打开的文件来寻找匹配的提示词\n* **AutoFileName:**\n自动检索并补齐文件路径\n* **CSScomb:**\n使用指定排序方法对CSS的属性进行排序，快捷键**ctrl+alt+C**\n虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法\n* **HTML-CSS-JS Prettify:**\n美化代码格式，需要安装node.js才能使用，快捷键**ctrl+alt+H**，可以自动对齐\n* **ColorHighlighter:**\n可以显示颜色代码的颜色，看上去一目了然\n* **BracketHighlighter:**\n括号以及标签层级显示\n* **Sidebarenhancements:**\n扩展鼠标右键菜单，可以直接open with浏览器，超方便\n* **SublimeCodeIntel:**\n可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上\n\n打开*Package Settings > SublimeCodeIntel > Key Bindings - User*,输入代码\n```python\n[\n\t{ \n\t\t\"keys\": [\";\"], \"command\": \"run_macro_file\", \n\t  \t\"args\": {\"file\": \"Packages/User/unAutoSemiColon.sublime-macro\"} \n\t}\n]\n```\n然后打开 *Preferences > Browser Package > User*，保存文件名为*unAutoSemiColon.sublime-macro*\n```python\n[\n    {\n        \"args\":\n        {\n            \"characters\": \";\"\n        },\n        \"command\": \"insert\"\n    }\n]\n```\n之后打分号再也不会出现提示啦！！\n* **SublimeTmpl:**\n可以快速创建代码模板\n**ctrl+shift+H** HTML模板\n**ctrl+shift+C** CSS模板\n**ctrl+shift+J** Javascript模板\n**ctrl+shift+P** php模板\n*  **Colorsublime:**\n更换主题的插件，含有很多主题配色方案，偶尔转换一下心情\n***\n","slug":"17-02-28-2","published":1,"updated":"2017-07-15T07:47:38.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecoca0001t0cga8nu5kg4","content":"<p>自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利</p>\n<a id=\"more\"></a>\n<hr>\n<ul>\n<li><strong>Emmet:</strong><br>快速编写HTML+CSS代码，快捷键<strong>ctrl+E</strong><br><a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"external\">关于如何速写的教程</a></li>\n<li><strong>All Autocomplete:</strong><br>搜索所有打开的文件来寻找匹配的提示词</li>\n<li><strong>AutoFileName:</strong><br>自动检索并补齐文件路径</li>\n<li><strong>CSScomb:</strong><br>使用指定排序方法对CSS的属性进行排序，快捷键<strong>ctrl+alt+C</strong><br>虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法</li>\n<li><strong>HTML-CSS-JS Prettify:</strong><br>美化代码格式，需要安装node.js才能使用，快捷键<strong>ctrl+alt+H</strong>，可以自动对齐</li>\n<li><strong>ColorHighlighter:</strong><br>可以显示颜色代码的颜色，看上去一目了然</li>\n<li><strong>BracketHighlighter:</strong><br>括号以及标签层级显示</li>\n<li><strong>Sidebarenhancements:</strong><br>扩展鼠标右键菜单，可以直接open with浏览器，超方便</li>\n<li><strong>SublimeCodeIntel:</strong><br>可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上</li>\n</ul>\n<p>打开<em>Package Settings &gt; SublimeCodeIntel &gt; Key Bindings - User</em>,输入代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">\t&#123; </div><div class=\"line\">\t\t<span class=\"string\">\"keys\"</span>: [<span class=\"string\">\";\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"run_macro_file\"</span>, </div><div class=\"line\">\t  \t<span class=\"string\">\"args\"</span>: &#123;<span class=\"string\">\"file\"</span>: <span class=\"string\">\"Packages/User/unAutoSemiColon.sublime-macro\"</span>&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>然后打开 <em>Preferences &gt; Browser Package &gt; User</em>，保存文件名为<em>unAutoSemiColon.sublime-macro</em><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"args\"</span>:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"characters\"</span>: <span class=\"string\">\";\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"command\"</span>: <span class=\"string\">\"insert\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>之后打分号再也不会出现提示啦！！</p>\n<ul>\n<li><strong>SublimeTmpl:</strong><br>可以快速创建代码模板<br><strong>ctrl+shift+H</strong> HTML模板<br><strong>ctrl+shift+C</strong> CSS模板<br><strong>ctrl+shift+J</strong> Javascript模板<br><strong>ctrl+shift+P</strong> php模板</li>\n<li><strong>Colorsublime:</strong><br>更换主题的插件，含有很多主题配色方案，偶尔转换一下心情</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<p>自从寒假抛弃了DW开始用Sublime Text3，一直沉浸在它的好用上面，打代码超快！界面又超好看！超爱哦！有几个关于前端的插件特别特别好，下面是安利</p>","more":"<hr>\n<ul>\n<li><strong>Emmet:</strong><br>快速编写HTML+CSS代码，快捷键<strong>ctrl+E</strong><br><a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"external\">关于如何速写的教程</a></li>\n<li><strong>All Autocomplete:</strong><br>搜索所有打开的文件来寻找匹配的提示词</li>\n<li><strong>AutoFileName:</strong><br>自动检索并补齐文件路径</li>\n<li><strong>CSScomb:</strong><br>使用指定排序方法对CSS的属性进行排序，快捷键<strong>ctrl+alt+C</strong><br>虽然好像很厉害的样子但是我安装了之后一直没有反应，还未找到办法</li>\n<li><strong>HTML-CSS-JS Prettify:</strong><br>美化代码格式，需要安装node.js才能使用，快捷键<strong>ctrl+alt+H</strong>，可以自动对齐</li>\n<li><strong>ColorHighlighter:</strong><br>可以显示颜色代码的颜色，看上去一目了然</li>\n<li><strong>BracketHighlighter:</strong><br>括号以及标签层级显示</li>\n<li><strong>Sidebarenhancements:</strong><br>扩展鼠标右键菜单，可以直接open with浏览器，超方便</li>\n<li><strong>SublimeCodeIntel:</strong><br>可以快速提示补全标签，但是有个缺点就是打了分号之后会弹出提示框，然后换行的时候各种误打一堆烂七八糟的代码，在网上找了挺久的办法终于找到一个可行的，附上</li>\n</ul>\n<p>打开<em>Package Settings &gt; SublimeCodeIntel &gt; Key Bindings - User</em>,输入代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">\t&#123; </div><div class=\"line\">\t\t<span class=\"string\">\"keys\"</span>: [<span class=\"string\">\";\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"run_macro_file\"</span>, </div><div class=\"line\">\t  \t<span class=\"string\">\"args\"</span>: &#123;<span class=\"string\">\"file\"</span>: <span class=\"string\">\"Packages/User/unAutoSemiColon.sublime-macro\"</span>&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>然后打开 <em>Preferences &gt; Browser Package &gt; User</em>，保存文件名为<em>unAutoSemiColon.sublime-macro</em><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"args\"</span>:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"characters\"</span>: <span class=\"string\">\";\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"command\"</span>: <span class=\"string\">\"insert\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>之后打分号再也不会出现提示啦！！</p>\n<ul>\n<li><strong>SublimeTmpl:</strong><br>可以快速创建代码模板<br><strong>ctrl+shift+H</strong> HTML模板<br><strong>ctrl+shift+C</strong> CSS模板<br><strong>ctrl+shift+J</strong> Javascript模板<br><strong>ctrl+shift+P</strong> php模板</li>\n<li><strong>Colorsublime:</strong><br>更换主题的插件，含有很多主题配色方案，偶尔转换一下心情</li>\n</ul>\n<hr>"},{"title":"关于HTTP请求小记","date":"2017-03-20T07:31:38.000Z","_content":"* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","source":"_posts/17-03-20-4.md","raw":"---\ntitle: 关于HTTP请求小记\ndate: 2017-03-20 15:31:38\n---\n* **HTTP：** 是计算机通过网络进行通信的规则\n* **步骤：**\n\t* 建立TCP连接\n\t* Web浏览器向Web服务器发送请求命令\n\t* Web浏览器发送请求头信息\n\t* Web服务器应答\n\t* Web服务器发送应答头信息\n\t* Web服务器向浏览器发送数据\n\t* Web服务器关闭TCP连接\n\n<!--more-->\n\n* **组成：**\n\t* HTTP请求的方法或动作，比如是GET还是POST请求\n\t* 正在请求的URL\n\t* 请求头，包含一些客户端环境信息，身份验证信息等\n\t* 请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等\n```http\nGET /login.php HTTP/1.1 //请求地址\n\n//请求头\nHost:localhost\nConnection:keep-alive\nAccept:text/javascript,application/javascript,application/ecmascript,\napplication/x-ecmascript,*/*;\nq=0.01\nX-Requested-With:XMLHttpRequest\nUser-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,zh;q=0.8,en;q=0.6\n\n//请求体\nusername=admin&password=123456\n```\n* **GET：** 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）\n* **POST：** 一般用于修改服务器上的资源。对所发送信息的数量无限制。\n* **GET和POST的区别：**\n\t* GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\t* 然而，在以下情况中，请使用 **POST 请求**：\n\t无法使用缓存文件（更新服务器上的文件或数据库）\n\t向服务器发送大量数据（POST 没有数据量限制）\n    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n* **HTTP响应组成：**\n\t* 一个**数字**和**文字**组成的状态码，用来显示请求是成功还是失败的\n\t* 响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等\n\t* 响应体（响应正文），服务器传来的字符串或html代码等\n```http\nHTTP/1.1 200 OK\nDate:Sun,23 Nov 2014 10:14:45 GMT\nServer:Apache\nContent-Encoding:gzip\nContent-Length:7112\nConnection:Keep-Alive\nContent-Type:application/javascript\n```\n* **HTTP状态码：** 由3位数字构成，其中首位数字定义了状态码的类型\n\t* 1XX：信息类，表示收到Web浏览器请求，正在进一步处理中\n\t* 2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK\n\t* 3XX：重定向，表示请求没有成功，客户必须采取进一步的动作\n\t* 4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found\n\t* 5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500\n\n\n* **HTTP状态码（具体）：**\n\n\t* **100  Continue**  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\t* **200  OK**   正常返回信息\n\t* **201  Created**  请求成功并且服务器创建了新的资源\n\t* **202  Accepted**  服务器已接受请求，但尚未处理\n\t* **301  Moved Permanently**  请求的网页已永久移动到新位置\n\t* **302  Found**  临时性重定向\n\t* **303  See Other**  临时性重定向，且总是使用 GET 请求新的 URI\n\t* **304  Not Modified**  自从上次请求后，请求的网页未修改过\n\t* **400  Bad Request**  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\n\t* **401  Unauthorized**  请求未授权\n\t* **403  Forbidden**  禁止访问\n\t* **404  Not Found**  找不到如何与 URI 相匹配的资源\n\t* **500  Internal Server Error**  最常见的服务器端错误\n\t* **503  Service Unavailable** 服务器端暂时无法处理请求（可能是过载或维护）\n","slug":"17-03-20-4","published":1,"updated":"2017-07-15T07:47:44.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecocj0002t0cgpg6xmj2i","content":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /login.php HTTP/1.1 //请求地址</div><div class=\"line\"></div><div class=\"line\">//请求头</div><div class=\"line\">Host:localhost</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Accept:text/javascript,application/javascript,application/ecmascript,</div><div class=\"line\">application/x-ecmascript,*/*;</div><div class=\"line\">q=0.01</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</div><div class=\"line\"></div><div class=\"line\">//请求体</div><div class=\"line\">username=admin&amp;password=123456</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</div><div class=\"line\">Server:Apache</div><div class=\"line\">Content-Encoding:gzip</div><div class=\"line\">Content-Length:7112</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Content-Type:application/javascript</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><strong>HTTP：</strong> 是计算机通过网络进行通信的规则</li>\n<li><strong>步骤：</strong><ul>\n<li>建立TCP连接</li>\n<li>Web浏览器向Web服务器发送请求命令</li>\n<li>Web浏览器发送请求头信息</li>\n<li>Web服务器应答</li>\n<li>Web服务器发送应答头信息</li>\n<li>Web服务器向浏览器发送数据</li>\n<li>Web服务器关闭TCP连接</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><p><strong>组成：</strong></p>\n<ul>\n<li>HTTP请求的方法或动作，比如是GET还是POST请求</li>\n<li>正在请求的URL</li>\n<li>请求头，包含一些客户端环境信息，身份验证信息等</li>\n<li>请求体（请求正文），包含客户提交的查询字符串信息，表单信息等等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /login.php HTTP/1.1 //请求地址</div><div class=\"line\"></div><div class=\"line\">//请求头</div><div class=\"line\">Host:localhost</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Accept:text/javascript,application/javascript,application/ecmascript,</div><div class=\"line\">application/x-ecmascript,*/*;</div><div class=\"line\">q=0.01</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">User-Agent:Mozilla/5.0(Windows NT 6.1)Referer:http//www.baidu.com/</div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6</div><div class=\"line\"></div><div class=\"line\">//请求体</div><div class=\"line\">username=admin&amp;password=123456</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>GET：</strong> 一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。（一般用于查询，不做修改，数据是安全的）</p>\n</li>\n<li><strong>POST：</strong> 一般用于修改服务器上的资源。对所发送信息的数量无限制。</li>\n<li><strong>GET和POST的区别：</strong><ul>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n<li>然而，在以下情况中，请使用 <strong>POST 请求</strong>：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n<li><p><strong>HTTP响应组成：</strong></p>\n<ul>\n<li>一个<strong>数字</strong>和<strong>文字</strong>组成的状态码，用来显示请求是成功还是失败的</li>\n<li>响应头，包含服务器信息，如服务器类型、日期时间、内容类型和长度等</li>\n<li>响应体（响应正文），服务器传来的字符串或html代码等<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date:Sun,23 Nov 2014 10:14:45 GMT</div><div class=\"line\">Server:Apache</div><div class=\"line\">Content-Encoding:gzip</div><div class=\"line\">Content-Length:7112</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Content-Type:application/javascript</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码：</strong> 由3位数字构成，其中首位数字定义了状态码的类型</p>\n<ul>\n<li>1XX：信息类，表示收到Web浏览器请求，正在进一步处理中</li>\n<li>2XX：成功，表示用户请求被正确接受，理解和处理，例如：200 OK</li>\n<li>3XX：重定向，表示请求没有成功，客户必须采取进一步的动作</li>\n<li>4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found</li>\n<li>5XX：服务器错误，表示服务器不能完成对请求的处理，例如：500</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>HTTP状态码（具体）：</strong></p>\n<ul>\n<li><strong>100  Continue</strong>  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li><strong>200  OK</strong>   正常返回信息</li>\n<li><strong>201  Created</strong>  请求成功并且服务器创建了新的资源</li>\n<li><strong>202  Accepted</strong>  服务器已接受请求，但尚未处理</li>\n<li><strong>301  Moved Permanently</strong>  请求的网页已永久移动到新位置</li>\n<li><strong>302  Found</strong>  临时性重定向</li>\n<li><strong>303  See Other</strong>  临时性重定向，且总是使用 GET 请求新的 URI</li>\n<li><strong>304  Not Modified</strong>  自从上次请求后，请求的网页未修改过</li>\n<li><strong>400  Bad Request</strong>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>\n<li><strong>401  Unauthorized</strong>  请求未授权</li>\n<li><strong>403  Forbidden</strong>  禁止访问</li>\n<li><strong>404  Not Found</strong>  找不到如何与 URI 相匹配的资源</li>\n<li><strong>500  Internal Server Error</strong>  最常见的服务器端错误</li>\n<li><strong>503  Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）</li>\n</ul>\n</li>\n</ul>"},{"title":"JSON学习笔记","date":"2017-03-21T10:16:43.000Z","_content":"> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","source":"_posts/17-03-21-6.md","raw":"---\ntitle: JSON学习笔记\ndate: 2017-03-21 18:16:43\n---\n> JSON = JavaScript Object Notation （JavaScript对象表示法）\n> JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成\n> JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行\n\n<!--more-->\n\n## 与XML比较\n* 长度比xml短\n* 读写速度更快\n* json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便\n\n## 语法规则\n* JSON数据的书写格式：名称/值对\n名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如`\"name\":\"jane\"`\n* 可以使用的数据类型\n\t* 数字（整数或浮点数）\n\t* 字符串（双引号）\n\t* 逻辑值（true or false）\n\t* 数组（ [...] ）\n\t* 对象（ {...} ）\n\t* null\n\n## JSON解析\n* eval和JSON.parse\n* 尽可能使用`JSON.parse()`方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。\n```javascript\nvar jsondata = '{\"staff\":[{\"name\":\"aaa\",\"age\":70},{\"name\":\"bbb\",\"age\":12}]}';\nvar jsonobj = JSON.parse(jsondata);\n//解析完毕\nalert(jsonobj.staff[0].name);\n//直接对对象进行操作\n```\n* **tip：** `JSON.stringify()`方法是将对象解析成JSON\n```javascript\nvar a = {a:1,b:2}\nJSON.stringify(a) //\"{\"a\":1,\"b\":2}\"\n```","slug":"17-03-21-6","published":1,"updated":"2017-07-15T07:47:53.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecocl0003t0cgi25vhvf3","content":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</div><div class=\"line\"><span class=\"comment\">//解析完毕</span></div><div class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</div><div class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JSON = JavaScript Object Notation （JavaScript对象表示法）<br>JSON 是存储和交换文本信息的语法，类似XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于及其解析和生成<br>JSON 是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来就行</p>\n</blockquote>","more":"<h2 id=\"与XML比较\"><a href=\"#与XML比较\" class=\"headerlink\" title=\"与XML比较\"></a>与XML比较</h2><ul>\n<li>长度比xml短</li>\n<li>读写速度更快</li>\n<li>json可以使用Javascript内建的方法直接进行解析，转换成Javascript对象，非常方便</li>\n</ul>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><ul>\n<li>JSON数据的书写格式：名称/值对<br>名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如<code>&quot;name&quot;:&quot;jane&quot;</code></li>\n<li>可以使用的数据类型<ul>\n<li>数字（整数或浮点数）</li>\n<li>字符串（双引号）</li>\n<li>逻辑值（true or false）</li>\n<li>数组（ […] ）</li>\n<li>对象（ {…} ）</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSON解析\"><a href=\"#JSON解析\" class=\"headerlink\" title=\"JSON解析\"></a>JSON解析</h2><ul>\n<li>eval和JSON.parse</li>\n<li><p>尽可能使用<code>JSON.parse()</code>方法解析字符串本身，该方法可以捕捉JSON中的语法错误。eval使用存在风险，特别是第三方JSON数据存在恶意代码时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsondata = <span class=\"string\">'&#123;\"staff\":[&#123;\"name\":\"aaa\",\"age\":70&#125;,&#123;\"name\":\"bbb\",\"age\":12&#125;]&#125;'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> jsonobj = <span class=\"built_in\">JSON</span>.parse(jsondata);</div><div class=\"line\"><span class=\"comment\">//解析完毕</span></div><div class=\"line\">alert(jsonobj.staff[<span class=\"number\">0</span>].name);</div><div class=\"line\"><span class=\"comment\">//直接对对象进行操作</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> <code>JSON.stringify()</code>方法是将对象解析成JSON</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a) <span class=\"comment\">//\"&#123;\"a\":1,\"b\":2&#125;\"</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"title":"AJAX学习笔记","date":"2017-03-21T08:21:19.000Z","_content":"> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","source":"_posts/17-03-21-5.md","raw":"---\ntitle: AJAX学习笔记\ndate: 2017-03-21 16:21:19\n---\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n> AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n* 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式\n* 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式\n（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）\n\n<!--more-->\n\n## 实现\n* 实现页面\n* 运用XMLHttpRequest和web服务器进行数据的异步交换\n* 运用javascript操作DOM，实现动态局部刷新\n\n## 创建ajax过程\n* 创建XMLHttpRequest对象\n* 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息\n* 设置响应HTTP请求状态变化的函数\n* 发送HTTP请求\n* 获取异步调用返回的数据\n* 使用Javascript和DOM实现局部刷新\n\n## XHR\n* 发送请求\n\t* `open(method,url,async)` \nmethod表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）\n\t* `send(string)` \nGET请求参数可不填写或写none，用POST请求需要填写。\n```javascript\nvar request = new XMLHttpRequest(); //创建XHR对象\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\n\n//创建信息\nrequest.open(\"POST\",\"post.php\",true);\nrequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n//头信息，提示服务器要发送一个表单\nrequest.send(\"name=tom&sex=man\");\n```\n* 响应请求\n\t* `responseText`：获得字符串形式的响应数据\n\t* `responseXML`：获得XML形式的响应数据（XML交互较少，一般采用json）\n\t* `status&statusText`：以数字和文本形式返回HTTP状态码\n\t* `getAllResponseHeader()`：获取所有的响应报头\n\t* `getResponseHeader()`：查询响应中的某个字段的值\n\n* 监听服务器响应\n**readyState属性：** 代表服务器响应的变化\n\t* 0：请求未初始化，open还没有调用\n\t* 1：服务器连接已经建立，open已经调用\n\t* 2：请求已接收，也就是接收到头信息了\n\t* 3：请求处理中，也就是接收到响应主体了\n\t* 4：请求已完成，且响应已就绪（完成）\n```javascript\nvar request = new XMLHttpRequest();\nrequest.open(\"GET\",\"get.php\",true);\nrequest.send();\nrequest.onreadystatechange = function() {\n\tif(request.readyState === 4 && request.status === 200){\n\t\t//request.responseText...\n\t}\n}\n```\n\n## 用jQuery实现AJAX\n* `jQuery.ajax([settings])`\n\t* `type`：类型，“POST”或“GET\",默认\"GET\"\n\t* `url`：发送请求的地址\n\t* `data`：是一个对象，连同请求发送到服务器的数据\n\t* `dataType`：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用**json格式**，可以设置为**\"json\"**\n\t* `success`：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串\n\t* `error`：是一个方法，请求失败时调用此函数。传入XHR对象\n```javascript\n$.ajax({\n\ttype:\"GET\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n\n$.ajax({\n\ttype:\"POST\",\n\turl:\"get.php\",\n\tdataType:\"json\",\n\tdata:{\n\t\tname:123\n\t\tnumber:123\n\t\t//jquery可以自动将Form Data转换成name:123&number:123这种格式\n\t\t//并自动设置Content-Type:application/x-www-form-urlencoded\n\t},\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n\n## 跨域\n* 一个域名地址的组成：`http://www.abc.com:8080/scripts/jquery.js`\n\t* 协议：http://\n\t* 子域名：www\n\t* 主域名：abc.com\n\t* 端口号：8080（默认8080，可以省略）\n\t* 请求资源地址：scripts/jquery.js\n* 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域\n* 不同域之间相互请求资源，算作“跨域”\n  比如：`http://www.abc.com/index.html` 请求 `http://www.efg.com/service.php`\n* JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象\n\n## 处理跨域的方法\n* 代理\n  通过在同域名的web服务器端创建一个代理：\n  北京服务器：`www.beijing.com`\n  上海服务器：`www.shanghai.com`\n  在北京的web服务器的后台`www.beijing.com/proxy-shanghaiservice.php`来调用`www.shanghai.com/service.php`的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了\n* JSONP\n  JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）\n\n```html\n在www.aaa.com中\n <script>\n function jsonp(json){\n \talert(json[\"name\"]);\n }\n </script>\n <script src=\"http://www.bbb.com/jsonp.js\"></script>\n\n 在www.bbb.com中\n jsonp({\"name\":\"tom\",\"age\":27});\n```\n```javascript\n//jsonp只支持get请求\n$.ajax({\n\ttype:\"GET\",\n\turl:\"http://www.bbb.com/service.php\",\n\tdataType:\"jsonp\",\n\tjsonp:\"callback\",//取值任意，与后端相连接\n\tsuccess:function(data){\n\t\t//成功后的操作\n\t},\n\terror:function(jqXHR){\n\t\talert(\"error:\"+jqXHR.status);\n\t}\n})\n```\n* XHR2\n  HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）\n  在服务器端做一些小改造即可：\n  `header('Access-Control-Allow-Origin:*');`\n  `header('Access-Control-Allow-Methods:POST,GET');`","slug":"17-03-21-5","published":1,"updated":"2017-07-15T07:47:49.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecocm0004t0cgjoyzgslb","content":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建信息</span></div><div class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></div><div class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"number\">123</span></div><div class=\"line\">\t\tnumber:<span class=\"number\">123</span></div><div class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></div><div class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">在www.aaa.com中</div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\"> \talert(json[<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> 在www.bbb.com中</div><div class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></div><div class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<ul>\n<li>同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</li>\n<li>异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</li>\n</ul>\n</blockquote>","more":"<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li>实现页面</li>\n<li>运用XMLHttpRequest和web服务器进行数据的异步交换</li>\n<li>运用javascript操作DOM，实现动态局部刷新</li>\n</ul>\n<h2 id=\"创建ajax过程\"><a href=\"#创建ajax过程\" class=\"headerlink\" title=\"创建ajax过程\"></a>创建ajax过程</h2><ul>\n<li>创建XMLHttpRequest对象</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用Javascript和DOM实现局部刷新</li>\n</ul>\n<h2 id=\"XHR\"><a href=\"#XHR\" class=\"headerlink\" title=\"XHR\"></a>XHR</h2><ul>\n<li><p>发送请求</p>\n<ul>\n<li><code>open(method,url,async)</code><br>method表示发送方法(GET,POST)，url表示请求地址（相对或绝对），async表示同步或异步（异步true，默认值，同步false）</li>\n<li><code>send(string)</code><br>GET请求参数可不填写或写none，用POST请求需要填写。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建XHR对象</span></div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建信息</span></div><div class=\"line\">request.open(<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"post.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\"><span class=\"comment\">//头信息，提示服务器要发送一个表单</span></div><div class=\"line\">request.send(<span class=\"string\">\"name=tom&amp;sex=man\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>响应请求</p>\n<ul>\n<li><code>responseText</code>：获得字符串形式的响应数据</li>\n<li><code>responseXML</code>：获得XML形式的响应数据（XML交互较少，一般采用json）</li>\n<li><code>status&amp;statusText</code>：以数字和文本形式返回HTTP状态码</li>\n<li><code>getAllResponseHeader()</code>：获取所有的响应报头</li>\n<li><code>getResponseHeader()</code>：查询响应中的某个字段的值</li>\n</ul>\n</li>\n<li><p>监听服务器响应<br><strong>readyState属性：</strong> 代表服务器响应的变化</p>\n<ul>\n<li>0：请求未初始化，open还没有调用</li>\n<li>1：服务器连接已经建立，open已经调用</li>\n<li>2：请求已接收，也就是接收到头信息了</li>\n<li>3：请求处理中，也就是接收到响应主体了</li>\n<li>4：请求已完成，且响应已就绪（完成）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">request.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"get.php\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\">request.send();</div><div class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//request.responseText...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用jQuery实现AJAX\"><a href=\"#用jQuery实现AJAX\" class=\"headerlink\" title=\"用jQuery实现AJAX\"></a>用jQuery实现AJAX</h2><ul>\n<li><code>jQuery.ajax([settings])</code><ul>\n<li><code>type</code>：类型，“POST”或“GET”,默认”GET”</li>\n<li><code>url</code>：发送请求的地址</li>\n<li><code>data</code>：是一个对象，连同请求发送到服务器的数据</li>\n<li><code>dataType</code>：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来只能判断，一般采用<strong>json格式</strong>，可以设置为<strong>“json”</strong></li>\n<li><code>success</code>：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串</li>\n<li><code>error</code>：是一个方法，请求失败时调用此函数。传入XHR对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"get.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"number\">123</span></div><div class=\"line\">\t\tnumber:<span class=\"number\">123</span></div><div class=\"line\">\t\t<span class=\"comment\">//jquery可以自动将Form Data转换成name:123&amp;number:123这种格式</span></div><div class=\"line\">\t\t<span class=\"comment\">//并自动设置Content-Type:application/x-www-form-urlencoded</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li>一个域名地址的组成：<code>http://www.abc.com:8080/scripts/jquery.js</code><ul>\n<li>协议：http://</li>\n<li>子域名：www</li>\n<li>主域名：abc.com</li>\n<li>端口号：8080（默认8080，可以省略）</li>\n<li>请求资源地址：scripts/jquery.js</li>\n</ul>\n</li>\n<li>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</li>\n<li>不同域之间相互请求资源，算作“跨域”<br>比如：<code>http://www.abc.com/index.html</code> 请求 <code>http://www.efg.com/service.php</code></li>\n<li>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。简单说就是a.com域名下的js无法操作b.com或者c.a.com域名下的对象</li>\n</ul>\n<h2 id=\"处理跨域的方法\"><a href=\"#处理跨域的方法\" class=\"headerlink\" title=\"处理跨域的方法\"></a>处理跨域的方法</h2><ul>\n<li>代理<br>通过在同域名的web服务器端创建一个代理：<br>北京服务器：<code>www.beijing.com</code><br>上海服务器：<code>www.shanghai.com</code><br>在北京的web服务器的后台<code>www.beijing.com/proxy-shanghaiservice.php</code>来调用<code>www.shanghai.com/service.php</code>的服务器，然后把响应结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了</li>\n<li>JSONP<br>JSONP可用于解决主流浏览器的跨域数据访问的问题（json+padding，内填充）</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">在www.aaa.com中</div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonp</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\"> \talert(json[<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.bbb.com/jsonp.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> 在www.bbb.com中</div><div class=\"line\"> jsonp(&#123;\"name\":\"tom\",\"age\":27&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jsonp只支持get请求</span></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">\"http://www.bbb.com/service.php\"</span>,</div><div class=\"line\">\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"callback\"</span>,<span class=\"comment\">//取值任意，与后端相连接</span></div><div class=\"line\">\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//成功后的操作</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"error:\"</span>+jqXHR.status);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>XHR2<br>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能（不支持IE10以下）<br>在服务器端做一些小改造即可：<br><code>header(&#39;Access-Control-Allow-Origin:*&#39;);</code><br><code>header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);</code></li>\n</ul>"},{"title":"从零开始的backbone.js（一）","date":"2017-03-28T08:24:10.000Z","_content":"实习项目用的框架：backbone.js\n\n> Backbone.js为复杂WEB应用程序提供**模型(models)**、**集合(collections)**、**视图(views)**的结构。\n\n<!--more-->\n\n## Backbone.Model（模型）\n* Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。\n```javascript\n//相当于public class ...\n//可以存放基本的数值以及方法\nvar Man = Backbone.Model.extend({\n\t//模型在服务器上位置的url\n\t//调用save方法时会post对象的所有属性到server端，数据形式是json\n\turl: '/man/',\n\t//定义了一个Model，实现了初始化方法（initialize函数）\n\tinitialize: function() {\n\t\talert('Hey,you create me!');\n\t\t//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个\n\t\t//当name发生改变时触发该函数\n\t\tthis.bind(\"change:name\",function(){\n\t\t\tvar name = this.get(\"name\");\n\t\t\talert(\"you change the name:\" + name);\n\t\t});\n\t\tthis.bind(\"invalid\",function(model,error){\n\t\t\talert(error);\n\t\t\t//error是来自validate校验的错误\n\t\t})\n\t},\n\t//定义默认值（属性）name & age\n\tdefaults: {\n\t\tname: 'tom',\n\t\tage: '18'\n\t},\n\t//Model.validate(attributes, options)，默认为未定义\n\t//默认在save之前调用，如果{validate:true}，则也能在set之前调用\n\t//当校验失败时，会触发\"invalid\"事件\n\tvalidate: function(attributes) {\n\t\tif(attributes.name == '') return \"name不能为空\";\n\t},\n\t//定义了名为aboutMe的一个方法（函数）\n\taboutMe: function() {\n\t\treturn \"I'm\" + this.get('name') + \",\" + this.get('age') \n\t\t+ \"years old.\";\n\t}\n});\n//实例化Model，并会直接调用initialize函数\nvar man = new Man;\n//Model.set(attribute),用来给Model修改或设置属性\n//改变了name的值，可以触发change事件，alert\nman.set({name : 'jane'});\n//设置时并不会触发校验\nman.set({name : ''});\n//model.save(attributes, options)，保存模型到数据库\n//如果验证成功，返回jqXHR，否则false\n//触发校验，根据验证规则弹出错误提示。\nman.save();\n//从服务器端获取数据\nvar man1 = new Man;\n//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作\nman1.fetch();\n//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json\nman1.fetch({url : '/man/'});\n//在服务器端返回数据的方法：\nman1.fetch({url:'/man/',success:function(model,response) {\n\t\t//model为获取到的数据\n\t\talert('success');\n\t\talert(model.get('name'));\n\t},error:function(){\n\t\t//当返回格式不正确或不是json数据时，会执行此方法\n\t\talert('error');\n\t}\n});\n```\n* **tip：** 关于`$(selector).bind(event,data,function)`\nevent：必填项，可以添加一个或多个，用空格隔开。\ndata：可以填可以不填，用来传递额外的数据\nfunction：必填项，事件发生时运行的函数\n[关于jQuery的事件方法](http://www.w3school.com.cn/jquery/jquery_ref_events.asp)\n\n","source":"_posts/17-03-28-8.md","raw":"---\ntitle: 从零开始的backbone.js（一）\ndate: 2017-03-28 16:24:10\n---\n实习项目用的框架：backbone.js\n\n> Backbone.js为复杂WEB应用程序提供**模型(models)**、**集合(collections)**、**视图(views)**的结构。\n\n<!--more-->\n\n## Backbone.Model（模型）\n* Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。\n```javascript\n//相当于public class ...\n//可以存放基本的数值以及方法\nvar Man = Backbone.Model.extend({\n\t//模型在服务器上位置的url\n\t//调用save方法时会post对象的所有属性到server端，数据形式是json\n\turl: '/man/',\n\t//定义了一个Model，实现了初始化方法（initialize函数）\n\tinitialize: function() {\n\t\talert('Hey,you create me!');\n\t\t//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个\n\t\t//当name发生改变时触发该函数\n\t\tthis.bind(\"change:name\",function(){\n\t\t\tvar name = this.get(\"name\");\n\t\t\talert(\"you change the name:\" + name);\n\t\t});\n\t\tthis.bind(\"invalid\",function(model,error){\n\t\t\talert(error);\n\t\t\t//error是来自validate校验的错误\n\t\t})\n\t},\n\t//定义默认值（属性）name & age\n\tdefaults: {\n\t\tname: 'tom',\n\t\tage: '18'\n\t},\n\t//Model.validate(attributes, options)，默认为未定义\n\t//默认在save之前调用，如果{validate:true}，则也能在set之前调用\n\t//当校验失败时，会触发\"invalid\"事件\n\tvalidate: function(attributes) {\n\t\tif(attributes.name == '') return \"name不能为空\";\n\t},\n\t//定义了名为aboutMe的一个方法（函数）\n\taboutMe: function() {\n\t\treturn \"I'm\" + this.get('name') + \",\" + this.get('age') \n\t\t+ \"years old.\";\n\t}\n});\n//实例化Model，并会直接调用initialize函数\nvar man = new Man;\n//Model.set(attribute),用来给Model修改或设置属性\n//改变了name的值，可以触发change事件，alert\nman.set({name : 'jane'});\n//设置时并不会触发校验\nman.set({name : ''});\n//model.save(attributes, options)，保存模型到数据库\n//如果验证成功，返回jqXHR，否则false\n//触发校验，根据验证规则弹出错误提示。\nman.save();\n//从服务器端获取数据\nvar man1 = new Man;\n//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作\nman1.fetch();\n//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json\nman1.fetch({url : '/man/'});\n//在服务器端返回数据的方法：\nman1.fetch({url:'/man/',success:function(model,response) {\n\t\t//model为获取到的数据\n\t\talert('success');\n\t\talert(model.get('name'));\n\t},error:function(){\n\t\t//当返回格式不正确或不是json数据时，会执行此方法\n\t\talert('error');\n\t}\n});\n```\n* **tip：** 关于`$(selector).bind(event,data,function)`\nevent：必填项，可以添加一个或多个，用空格隔开。\ndata：可以填可以不填，用来传递额外的数据\nfunction：必填项，事件发生时运行的函数\n[关于jQuery的事件方法](http://www.w3school.com.cn/jquery/jquery_ref_events.asp)\n\n","slug":"17-03-28-8","published":1,"updated":"2017-07-15T07:47:59.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecoct0005t0cg10b1kalj","content":"<p>实习项目用的框架：backbone.js</p>\n<blockquote>\n<p>Backbone.js为复杂WEB应用程序提供<strong>模型(models)</strong>、<strong>集合(collections)</strong>、<strong>视图(views)</strong>的结构。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Backbone-Model（模型）\"><a href=\"#Backbone-Model（模型）\" class=\"headerlink\" title=\"Backbone.Model（模型）\"></a>Backbone.Model（模型）</h2><ul>\n<li><p>Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//相当于public class ...</span></div><div class=\"line\"><span class=\"comment\">//可以存放基本的数值以及方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> Man = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//模型在服务器上位置的url</span></div><div class=\"line\">\t<span class=\"comment\">//调用save方法时会post对象的所有属性到server端，数据形式是json</span></div><div class=\"line\">\turl: <span class=\"string\">'/man/'</span>,</div><div class=\"line\">\t<span class=\"comment\">//定义了一个Model，实现了初始化方法（initialize函数）</span></div><div class=\"line\">\tinitialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">'Hey,you create me!'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个</span></div><div class=\"line\">\t\t<span class=\"comment\">//当name发生改变时触发该函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"change:name\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.get(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">\t\t\talert(<span class=\"string\">\"you change the name:\"</span> + name);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"invalid\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,error</span>)</span>&#123;</div><div class=\"line\">\t\t\talert(error);</div><div class=\"line\">\t\t\t<span class=\"comment\">//error是来自validate校验的错误</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义默认值（属性）name &amp; age</span></div><div class=\"line\">\tdefaults: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">'tom'</span>,</div><div class=\"line\">\t\t<span class=\"attr\">age</span>: <span class=\"string\">'18'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//Model.validate(attributes, options)，默认为未定义</span></div><div class=\"line\">\t<span class=\"comment\">//默认在save之前调用，如果&#123;validate:true&#125;，则也能在set之前调用</span></div><div class=\"line\">\t<span class=\"comment\">//当校验失败时，会触发\"invalid\"事件</span></div><div class=\"line\">\tvalidate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">attributes</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(attributes.name == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"name不能为空\"</span>;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义了名为aboutMe的一个方法（函数）</span></div><div class=\"line\">\taboutMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"I'm\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'name'</span>) + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'age'</span>) </div><div class=\"line\">\t\t+ <span class=\"string\">\"years old.\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化Model，并会直接调用initialize函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> man = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//Model.set(attribute),用来给Model修改或设置属性</span></div><div class=\"line\"><span class=\"comment\">//改变了name的值，可以触发change事件，alert</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'jane'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//设置时并不会触发校验</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">''</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//model.save(attributes, options)，保存模型到数据库</span></div><div class=\"line\"><span class=\"comment\">//如果验证成功，返回jqXHR，否则false</span></div><div class=\"line\"><span class=\"comment\">//触发校验，根据验证规则弹出错误提示。</span></div><div class=\"line\">man.save();</div><div class=\"line\"><span class=\"comment\">//从服务器端获取数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> man1 = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作</span></div><div class=\"line\">man1.fetch();</div><div class=\"line\"><span class=\"comment\">//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span> : <span class=\"string\">'/man/'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//在服务器端返回数据的方法：</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span>:<span class=\"string\">'/man/'</span>,<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,response</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//model为获取到的数据</span></div><div class=\"line\">\t\talert(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t\talert(model.get(<span class=\"string\">'name'</span>));</div><div class=\"line\">\t&#125;,<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//当返回格式不正确或不是json数据时，会执行此方法</span></div><div class=\"line\">\t\talert(<span class=\"string\">'error'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> 关于<code>$(selector).bind(event,data,function)</code><br>event：必填项，可以添加一个或多个，用空格隔开。<br>data：可以填可以不填，用来传递额外的数据<br>function：必填项，事件发生时运行的函数<br><a href=\"http://www.w3school.com.cn/jquery/jquery_ref_events.asp\" target=\"_blank\" rel=\"external\">关于jQuery的事件方法</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>实习项目用的框架：backbone.js</p>\n<blockquote>\n<p>Backbone.js为复杂WEB应用程序提供<strong>模型(models)</strong>、<strong>集合(collections)</strong>、<strong>视图(views)</strong>的结构。</p>\n</blockquote>","more":"<h2 id=\"Backbone-Model（模型）\"><a href=\"#Backbone-Model（模型）\" class=\"headerlink\" title=\"Backbone.Model（模型）\"></a>Backbone.Model（模型）</h2><ul>\n<li><p>Model的作用：对业务中实体对象的抽象，把数据以文件、数据库的形式存储在磁盘上，与服务器端进行数据交互。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//相当于public class ...</span></div><div class=\"line\"><span class=\"comment\">//可以存放基本的数值以及方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> Man = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//模型在服务器上位置的url</span></div><div class=\"line\">\t<span class=\"comment\">//调用save方法时会post对象的所有属性到server端，数据形式是json</span></div><div class=\"line\">\turl: <span class=\"string\">'/man/'</span>,</div><div class=\"line\">\t<span class=\"comment\">//定义了一个Model，实现了初始化方法（initialize函数）</span></div><div class=\"line\">\tinitialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">'Hey,you create me!'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//jQuery.bind(),对jQuery对象进行事件绑定，可绑定一个或者多个</span></div><div class=\"line\">\t\t<span class=\"comment\">//当name发生改变时触发该函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"change:name\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.get(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">\t\t\talert(<span class=\"string\">\"you change the name:\"</span> + name);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.bind(<span class=\"string\">\"invalid\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,error</span>)</span>&#123;</div><div class=\"line\">\t\t\talert(error);</div><div class=\"line\">\t\t\t<span class=\"comment\">//error是来自validate校验的错误</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义默认值（属性）name &amp; age</span></div><div class=\"line\">\tdefaults: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">'tom'</span>,</div><div class=\"line\">\t\t<span class=\"attr\">age</span>: <span class=\"string\">'18'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//Model.validate(attributes, options)，默认为未定义</span></div><div class=\"line\">\t<span class=\"comment\">//默认在save之前调用，如果&#123;validate:true&#125;，则也能在set之前调用</span></div><div class=\"line\">\t<span class=\"comment\">//当校验失败时，会触发\"invalid\"事件</span></div><div class=\"line\">\tvalidate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">attributes</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(attributes.name == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"name不能为空\"</span>;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//定义了名为aboutMe的一个方法（函数）</span></div><div class=\"line\">\taboutMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"I'm\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'name'</span>) + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.get(<span class=\"string\">'age'</span>) </div><div class=\"line\">\t\t+ <span class=\"string\">\"years old.\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化Model，并会直接调用initialize函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> man = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//Model.set(attribute),用来给Model修改或设置属性</span></div><div class=\"line\"><span class=\"comment\">//改变了name的值，可以触发change事件，alert</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'jane'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//设置时并不会触发校验</span></div><div class=\"line\">man.set(&#123;<span class=\"attr\">name</span> : <span class=\"string\">''</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//model.save(attributes, options)，保存模型到数据库</span></div><div class=\"line\"><span class=\"comment\">//如果验证成功，返回jqXHR，否则false</span></div><div class=\"line\"><span class=\"comment\">//触发校验，根据验证规则弹出错误提示。</span></div><div class=\"line\">man.save();</div><div class=\"line\"><span class=\"comment\">//从服务器端获取数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> man1 = <span class=\"keyword\">new</span> Man;</div><div class=\"line\"><span class=\"comment\">//第一种情况，他会发送get请求到model.url中，在服务器端判断来进行操作</span></div><div class=\"line\">man1.fetch();</div><div class=\"line\"><span class=\"comment\">//第二种情况，他会发送get请求到/getmans/这个url种，然后返回json</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span> : <span class=\"string\">'/man/'</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//在服务器端返回数据的方法：</span></div><div class=\"line\">man1.fetch(&#123;<span class=\"attr\">url</span>:<span class=\"string\">'/man/'</span>,<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model,response</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//model为获取到的数据</span></div><div class=\"line\">\t\talert(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t\talert(model.get(<span class=\"string\">'name'</span>));</div><div class=\"line\">\t&#125;,<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//当返回格式不正确或不是json数据时，会执行此方法</span></div><div class=\"line\">\t\talert(<span class=\"string\">'error'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tip：</strong> 关于<code>$(selector).bind(event,data,function)</code><br>event：必填项，可以添加一个或多个，用空格隔开。<br>data：可以填可以不填，用来传递额外的数据<br>function：必填项，事件发生时运行的函数<br><a href=\"http://www.w3school.com.cn/jquery/jquery_ref_events.asp\" target=\"_blank\" rel=\"external\">关于jQuery的事件方法</a></p>\n</li>\n</ul>"},{"title":"iconfont使用方法","date":"2017-03-26T01:12:56.000Z","_content":"实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","source":"_posts/17-03-26-7.md","raw":"---\ntitle: iconfont使用方法\ndate: 2017-03-26 09:12:56\n---\n实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程\n\n首先在[Iconfont-阿里巴巴矢量图标库](http://www.iconfont.cn/)上将需要的图标点击购物车按钮加入**暂存库**。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png)\n\n<!--more-->\n\n选择所有要用的图标后，**存储为项目**，给它命名。然后在**图标管理-图标应用项目**中找到这个项目，获取在线连接，把里面的代码复制到CSS中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png)\n\n在HTML中需要使用到图标时，使用iconfont类名。\n```html\n<i class=\"iconfont\">&#xe600;</i>\n```\n里面写上你想用的图标下面的Unicode：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png)\n\n可以通过控制iconfont类的属性改变图标的样式：\n```css\n.iconfont{\n\tfont-family:\"iconfont\";\n\tfont-size:16px;\n\tfont-style:normal;\n\t-webkit-font-smoothing: antialiased;\n        -webkit-text-stroke-width: 0.2px;\n        -moz-osx-font-smoothing: grayscale; \n        padding-left:20px\n}\n```\n\n也可以下载到本地使用。图标都加入暂存架后选择**下载到本地**，会得到以下几个文件：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png)\n浏览器打开demo.html可以看到每个图标的Unicode，把**iconfont.css**里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。\n\n***\n作者：班星灿\n链接：https://www.zhihu.com/question/25952487/answer/71917554\n来源：知乎","slug":"17-03-26-7","published":1,"updated":"2017-07-15T07:47:56.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecocy0006t0cgqkmar40t","content":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt=\"\"></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt=\"\"></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</div><div class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </div><div class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt=\"\"><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>\n","site":{"data":{}},"excerpt":"<p>实习的时候需要用到iconfont，然而看了官方文档觉得一脸懵逼，找了一下教程</p>\n<p>首先在<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">Iconfont-阿里巴巴矢量图标库</a>上将需要的图标点击购物车按钮加入<strong>暂存库</strong>。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-1.png\" alt=\"\"></p>","more":"<p>选择所有要用的图标后，<strong>存储为项目</strong>，给它命名。然后在<strong>图标管理-图标应用项目</strong>中找到这个项目，获取在线连接，把里面的代码复制到CSS中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-2.png\" alt=\"\"></p>\n<p>在HTML中需要使用到图标时，使用iconfont类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"iconfont\"</span>&gt;</span>&amp;#xe600;<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>里面写上你想用的图标下面的Unicode：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-3.png\" alt=\"\"></p>\n<p>可以通过控制iconfont类的属性改变图标的样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.iconfont</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">font-family</span>:<span class=\"string\">\"iconfont\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</div><div class=\"line\">\t<span class=\"attribute\">font-style</span>:normal;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">        <span class=\"attribute\">-webkit-text-stroke-width</span>: <span class=\"number\">0.2px</span>;</div><div class=\"line\">        <span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale; </div><div class=\"line\">        <span class=\"attribute\">padding-left</span>:<span class=\"number\">20px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也可以下载到本地使用。图标都加入暂存架后选择<strong>下载到本地</strong>，会得到以下几个文件：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/iconfont-img-4.png\" alt=\"\"><br>浏览器打开demo.html可以看到每个图标的Unicode，把<strong>iconfont.css</strong>里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p>\n<hr>\n<p>作者：班星灿<br>链接：<a href=\"https://www.zhihu.com/question/25952487/answer/71917554\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/25952487/answer/71917554</a><br>来源：知乎</p>"},{"title":"从零开始的backbone.js（二）","date":"2017-03-29T08:06:16.000Z","_content":"## Backbone.View（视图）\n* view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。\n* 相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。\n\n<!--more-->\n\n```javascript\nvar searchView = Backbone.View.extend({\n\t//引用的DOM元素（没有指定也会指向一个空的div）\n\tel:\"#search_container\",\n\t//绑定事件\n\tevents:{\n\t\t\"click input[type=button]\":\"doSearch\"\n\t\t//当点击input时，会调用doSearch\n\t},\n\t//初始化函数（一开始就会调用）\n\tinitialize:function() {\n\t\t//调用render渲染页面\n\t\tthis.render({search_label:\"搜索按钮\"});\n\t},\n\t//渲染页面函数\n\trender:function(context) {\n\t\t//html模板\n\t\tvar template = _.template($(\"#search_template\").html());\n\t\t$(this.el).html(template(context));\n\t},\n\t//doSearch函数定义\n\tdoSearch:function(){\n\t\talert(\"search for\" + $(\"#search_input\").val());\n\t}\n});\n//实例化\nvar SearchView = new searchView();\n```\n","source":"_posts/17-03-29-9.md","raw":"---\ntitle: 从零开始的backbone.js（二）\ndate: 2017-03-29 16:06:16\n---\n## Backbone.View（视图）\n* view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。\n* 相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。\n\n<!--more-->\n\n```javascript\nvar searchView = Backbone.View.extend({\n\t//引用的DOM元素（没有指定也会指向一个空的div）\n\tel:\"#search_container\",\n\t//绑定事件\n\tevents:{\n\t\t\"click input[type=button]\":\"doSearch\"\n\t\t//当点击input时，会调用doSearch\n\t},\n\t//初始化函数（一开始就会调用）\n\tinitialize:function() {\n\t\t//调用render渲染页面\n\t\tthis.render({search_label:\"搜索按钮\"});\n\t},\n\t//渲染页面函数\n\trender:function(context) {\n\t\t//html模板\n\t\tvar template = _.template($(\"#search_template\").html());\n\t\t$(this.el).html(template(context));\n\t},\n\t//doSearch函数定义\n\tdoSearch:function(){\n\t\talert(\"search for\" + $(\"#search_input\").val());\n\t}\n});\n//实例化\nvar SearchView = new searchView();\n```\n","slug":"17-03-29-9","published":1,"updated":"2017-07-15T07:48:03.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecod00007t0cg2s912nlt","content":"<h2 id=\"Backbone-View（视图）\"><a href=\"#Backbone-View（视图）\" class=\"headerlink\" title=\"Backbone.View（视图）\"></a>Backbone.View（视图）</h2><ul>\n<li>view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。</li>\n<li>相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> searchView = Backbone.View.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//引用的DOM元素（没有指定也会指向一个空的div）</span></div><div class=\"line\">\tel:<span class=\"string\">\"#search_container\"</span>,</div><div class=\"line\">\t<span class=\"comment\">//绑定事件</span></div><div class=\"line\">\tevents:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"click input[type=button]\"</span>:<span class=\"string\">\"doSearch\"</span></div><div class=\"line\">\t\t<span class=\"comment\">//当点击input时，会调用doSearch</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//初始化函数（一开始就会调用）</span></div><div class=\"line\">\tinitialize:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//调用render渲染页面</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.render(&#123;<span class=\"attr\">search_label</span>:<span class=\"string\">\"搜索按钮\"</span>&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//渲染页面函数</span></div><div class=\"line\">\trender:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//html模板</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> template = _.template($(<span class=\"string\">\"#search_template\"</span>).html());</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.el).html(template(context));</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//doSearch函数定义</span></div><div class=\"line\">\tdoSearch:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"search for\"</span> + $(<span class=\"string\">\"#search_input\"</span>).val());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> SearchView = <span class=\"keyword\">new</span> searchView();</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Backbone-View（视图）\"><a href=\"#Backbone-View（视图）\" class=\"headerlink\" title=\"Backbone.View（视图）\"></a>Backbone.View（视图）</h2><ul>\n<li>view的功能就是将model中的数据显示在页面上，同时也可用来监听DOM上的事件然后做出响应。</li>\n<li>相比较AngularJS，其model变化之后页面数据也会自动变化，而Backbone要手动处理。</li>\n</ul>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> searchView = Backbone.View.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//引用的DOM元素（没有指定也会指向一个空的div）</span></div><div class=\"line\">\tel:<span class=\"string\">\"#search_container\"</span>,</div><div class=\"line\">\t<span class=\"comment\">//绑定事件</span></div><div class=\"line\">\tevents:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"click input[type=button]\"</span>:<span class=\"string\">\"doSearch\"</span></div><div class=\"line\">\t\t<span class=\"comment\">//当点击input时，会调用doSearch</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//初始化函数（一开始就会调用）</span></div><div class=\"line\">\tinitialize:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//调用render渲染页面</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.render(&#123;<span class=\"attr\">search_label</span>:<span class=\"string\">\"搜索按钮\"</span>&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//渲染页面函数</span></div><div class=\"line\">\trender:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//html模板</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> template = _.template($(<span class=\"string\">\"#search_template\"</span>).html());</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>.el).html(template(context));</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">//doSearch函数定义</span></div><div class=\"line\">\tdoSearch:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"string\">\"search for\"</span> + $(<span class=\"string\">\"#search_input\"</span>).val());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> SearchView = <span class=\"keyword\">new</span> searchView();</div></pre></td></tr></table></figure>"},{"title":"从零开始的backbone.js（三）","date":"2017-04-06T05:47:54.000Z","_content":"## Backbone.Collection（集合）\n* model是现实中物体的抽象，而collection则是model对象的一个有序的集合\n\n<!--more-->\n\n```javascript\nvar Book = Backbone.Model.extend({\n\tdefaults:{\n\t\ttitle:\"default\"\n\t},\n\tinitialize:function(){\n\t\talert(this.title);\n\t}\n});\n\nvar BookShelf = Backbone.Collection.extend({\n\t//model Book的集合\n\tmodel:Book;\n});\n\n//创建三个Book model\nvar book1 = new Book({title:\"book1\"});\nvar book2 = new Book({title:\"book2\"});\nvar book3 = new Book({title:\"book3\"});\n//创建一个bookShelf数组集合\nvar bookShelf = new BookShelf([book1,book2,book3]);\n//或者，可以使用add将book1,book2,book3加入到集合中\n/*\nbookShelf.add(book1);\nbookShelf.add(book2);\nbookShelf.add(book3);\n*/\n//还可以对里面的model进行其他操作\nbookShelf.remove(book3);\n//可以用each对其进行遍历\nbookShelf.each(function(book){\n\talert(book.get(\"title\"));\n});\n//相当于ajax的操作\nbookShelf.url = '/books/'\nbookShelf.fetch({\n\tsuccess:function(){\n\t\t//...\n\t},\n\terror:function(){\n\t\t//...\n\t}\n});\n//create方法，将model对象（json数据）POST到对应的url上\nvar NewBooks = Backbone.Collection.extend({\n\tmodel:Book,\n\turl:'/books/'\n});\nvar books =  new NewBooks;\nvar onebook = books.create({\n\ttitle: \"I'm coming\"\n});\n```","source":"_posts/17-04-06-11.md","raw":"---\ntitle: 从零开始的backbone.js（三）\ndate: 2017-04-06 13:47:54\n---\n## Backbone.Collection（集合）\n* model是现实中物体的抽象，而collection则是model对象的一个有序的集合\n\n<!--more-->\n\n```javascript\nvar Book = Backbone.Model.extend({\n\tdefaults:{\n\t\ttitle:\"default\"\n\t},\n\tinitialize:function(){\n\t\talert(this.title);\n\t}\n});\n\nvar BookShelf = Backbone.Collection.extend({\n\t//model Book的集合\n\tmodel:Book;\n});\n\n//创建三个Book model\nvar book1 = new Book({title:\"book1\"});\nvar book2 = new Book({title:\"book2\"});\nvar book3 = new Book({title:\"book3\"});\n//创建一个bookShelf数组集合\nvar bookShelf = new BookShelf([book1,book2,book3]);\n//或者，可以使用add将book1,book2,book3加入到集合中\n/*\nbookShelf.add(book1);\nbookShelf.add(book2);\nbookShelf.add(book3);\n*/\n//还可以对里面的model进行其他操作\nbookShelf.remove(book3);\n//可以用each对其进行遍历\nbookShelf.each(function(book){\n\talert(book.get(\"title\"));\n});\n//相当于ajax的操作\nbookShelf.url = '/books/'\nbookShelf.fetch({\n\tsuccess:function(){\n\t\t//...\n\t},\n\terror:function(){\n\t\t//...\n\t}\n});\n//create方法，将model对象（json数据）POST到对应的url上\nvar NewBooks = Backbone.Collection.extend({\n\tmodel:Book,\n\turl:'/books/'\n});\nvar books =  new NewBooks;\nvar onebook = books.create({\n\ttitle: \"I'm coming\"\n});\n```","slug":"17-04-06-11","published":1,"updated":"2017-07-15T07:48:06.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecod90008t0cgdtsvm1pj","content":"<h2 id=\"Backbone-Collection（集合）\"><a href=\"#Backbone-Collection（集合）\" class=\"headerlink\" title=\"Backbone.Collection（集合）\"></a>Backbone.Collection（集合）</h2><ul>\n<li>model是现实中物体的抽象，而collection则是model对象的一个有序的集合</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">defaults</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">title</span>:<span class=\"string\">\"default\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.title);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BookShelf = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//model Book的集合</span></div><div class=\"line\">\tmodel:Book;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建三个Book model</span></div><div class=\"line\"><span class=\"keyword\">var</span> book1 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book1\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book2\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book3 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book3\"</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//创建一个bookShelf数组集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> bookShelf = <span class=\"keyword\">new</span> BookShelf([book1,book2,book3]);</div><div class=\"line\"><span class=\"comment\">//或者，可以使用add将book1,book2,book3加入到集合中</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">bookShelf.add(book1);</div><div class=\"line\">bookShelf.add(book2);</div><div class=\"line\">bookShelf.add(book3);</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"comment\">//还可以对里面的model进行其他操作</span></div><div class=\"line\">bookShelf.remove(book3);</div><div class=\"line\"><span class=\"comment\">//可以用each对其进行遍历</span></div><div class=\"line\">bookShelf.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>)</span>&#123;</div><div class=\"line\">\talert(book.get(<span class=\"string\">\"title\"</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//相当于ajax的操作</span></div><div class=\"line\">bookShelf.url = <span class=\"string\">'/books/'</span></div><div class=\"line\">bookShelf.fetch(&#123;</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//create方法，将model对象（json数据）POST到对应的url上</span></div><div class=\"line\"><span class=\"keyword\">var</span> NewBooks = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">model</span>:Book,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">'/books/'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> books =  <span class=\"keyword\">new</span> NewBooks;</div><div class=\"line\"><span class=\"keyword\">var</span> onebook = books.create(&#123;</div><div class=\"line\">\t<span class=\"attr\">title</span>: <span class=\"string\">\"I'm coming\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Backbone-Collection（集合）\"><a href=\"#Backbone-Collection（集合）\" class=\"headerlink\" title=\"Backbone.Collection（集合）\"></a>Backbone.Collection（集合）</h2><ul>\n<li>model是现实中物体的抽象，而collection则是model对象的一个有序的集合</li>\n</ul>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = Backbone.Model.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">defaults</span>:&#123;</div><div class=\"line\">\t\t<span class=\"attr\">title</span>:<span class=\"string\">\"default\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.title);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BookShelf = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"comment\">//model Book的集合</span></div><div class=\"line\">\tmodel:Book;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建三个Book model</span></div><div class=\"line\"><span class=\"keyword\">var</span> book1 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book1\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book2\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> book3 = <span class=\"keyword\">new</span> Book(&#123;<span class=\"attr\">title</span>:<span class=\"string\">\"book3\"</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//创建一个bookShelf数组集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> bookShelf = <span class=\"keyword\">new</span> BookShelf([book1,book2,book3]);</div><div class=\"line\"><span class=\"comment\">//或者，可以使用add将book1,book2,book3加入到集合中</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">bookShelf.add(book1);</div><div class=\"line\">bookShelf.add(book2);</div><div class=\"line\">bookShelf.add(book3);</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"comment\">//还可以对里面的model进行其他操作</span></div><div class=\"line\">bookShelf.remove(book3);</div><div class=\"line\"><span class=\"comment\">//可以用each对其进行遍历</span></div><div class=\"line\">bookShelf.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>)</span>&#123;</div><div class=\"line\">\talert(book.get(<span class=\"string\">\"title\"</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//相当于ajax的操作</span></div><div class=\"line\">bookShelf.url = <span class=\"string\">'/books/'</span></div><div class=\"line\">bookShelf.fetch(&#123;</div><div class=\"line\">\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">error</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//create方法，将model对象（json数据）POST到对应的url上</span></div><div class=\"line\"><span class=\"keyword\">var</span> NewBooks = Backbone.Collection.extend(&#123;</div><div class=\"line\">\t<span class=\"attr\">model</span>:Book,</div><div class=\"line\">\t<span class=\"attr\">url</span>:<span class=\"string\">'/books/'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> books =  <span class=\"keyword\">new</span> NewBooks;</div><div class=\"line\"><span class=\"keyword\">var</span> onebook = books.create(&#123;</div><div class=\"line\">\t<span class=\"attr\">title</span>: <span class=\"string\">\"I'm coming\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"前端模块化","date":"2017-04-06T06:46:01.000Z","_content":"## AMD\n\n* AMD 即`Asynchronous Module Definition`，中文名是**异步模块定义**的意思。它是一个在浏览器端模块化开发的规范。\n\n<!--more-->\n\n* 应用：**RequireJS**\n  解决的主要问题：\n\t* 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\t* js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n* `define([id], [dependencies], factory);`\n\t* id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\t* dependencies：是一个当前模块依赖的模块名称数组\n\t* factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n* `require([dependencies], function(){});`\n\t* dependencies：一个数组，表示所依赖的模块\n\t* function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\t* `require()`函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n* 使用例子：\n```javascript\n// 定义模块 myModule.js\ndefine(['dependency'], function(){\n    var name = 'Byron';\n    function printName(){\n        console.log(name);\n    }\n    return {\n        printName: printName\n    };\n});\n\n// 加载模块\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n## CMD\n\n* CMD 即`Common Module Definition`通用模块定义\n* 应用：**SeaJS**\n  SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n* `define([id],[deps],factory)`\n\t* 一个文件一个模块，所以经常就用文件名作为模块id\n\t* CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\t* factory有三个参数：`function(require, exports, module)`\n* `require(id)`\n\t* require 是一个方法，接受**模块标识**作为唯一参数，用来获取其他模块提供的接口\n* `exports`\n\t* exports 是一个对象，用来向外提供模块接口\n* `module`\n\t* module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n* 使用例子：\n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n\n});\n```\n\n## AMD与CMD的区别\n\n> AMD 是提前执行，CMD 是延迟执行\n> 在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require","source":"_posts/17-04-06-12.md","raw":"---\ntitle: 前端模块化\ndate: 2017-04-06 14:46:01\n---\n## AMD\n\n* AMD 即`Asynchronous Module Definition`，中文名是**异步模块定义**的意思。它是一个在浏览器端模块化开发的规范。\n\n<!--more-->\n\n* 应用：**RequireJS**\n  解决的主要问题：\n\t* 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\t* js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n* `define([id], [dependencies], factory);`\n\t* id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\t* dependencies：是一个当前模块依赖的模块名称数组\n\t* factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n* `require([dependencies], function(){});`\n\t* dependencies：一个数组，表示所依赖的模块\n\t* function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\t* `require()`函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n* 使用例子：\n```javascript\n// 定义模块 myModule.js\ndefine(['dependency'], function(){\n    var name = 'Byron';\n    function printName(){\n        console.log(name);\n    }\n    return {\n        printName: printName\n    };\n});\n\n// 加载模块\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n## CMD\n\n* CMD 即`Common Module Definition`通用模块定义\n* 应用：**SeaJS**\n  SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n* `define([id],[deps],factory)`\n\t* 一个文件一个模块，所以经常就用文件名作为模块id\n\t* CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\t* factory有三个参数：`function(require, exports, module)`\n* `require(id)`\n\t* require 是一个方法，接受**模块标识**作为唯一参数，用来获取其他模块提供的接口\n* `exports`\n\t* exports 是一个对象，用来向外提供模块接口\n* `module`\n\t* module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n* 使用例子：\n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n\n});\n```\n\n## AMD与CMD的区别\n\n> AMD 是提前执行，CMD 是延迟执行\n> 在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require","slug":"17-04-06-12","published":1,"updated":"2017-07-15T07:48:09.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodb0009t0cg37h5o1gh","content":"<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><ul>\n<li>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>应用：<strong>RequireJS</strong><br>解决的主要问题：<ul>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ul>\n</li>\n<li><code>define([id], [dependencies], factory);</code><ul>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ul>\n</li>\n<li><code>require([dependencies], function(){});</code><ul>\n<li>dependencies：一个数组，表示所依赖的模块</li>\n<li>function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n<li><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块 myModule.js</span></div><div class=\"line\">define([<span class=\"string\">'dependency'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Byron'</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">printName</span>: printName</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'myModule'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\">　 my.printName();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><ul>\n<li>CMD 即<code>Common Module Definition</code>通用模块定义</li>\n<li>应用：<strong>SeaJS</strong><br>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</li>\n<li><code>define([id],[deps],factory)</code><ul>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n<li>factory有三个参数：<code>function(require, exports, module)</code></li>\n</ul>\n</li>\n<li><code>require(id)</code><ul>\n<li>require 是一个方法，接受<strong>模块标识</strong>作为唯一参数，用来获取其他模块提供的接口</li>\n</ul>\n</li>\n<li><code>exports</code><ul>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n</ul>\n</li>\n<li><code>module</code><ul>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块  myModule.js</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</div><div class=\"line\">  $(<span class=\"string\">'div'</span>).addClass(<span class=\"string\">'active'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\">seajs.use([<span class=\"string\">'myModule.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"AMD与CMD的区别\"><a href=\"#AMD与CMD的区别\" class=\"headerlink\" title=\"AMD与CMD的区别\"></a>AMD与CMD的区别</h2><blockquote>\n<p>AMD 是提前执行，CMD 是延迟执行<br>在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><ul>\n<li>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范。</li>\n</ul>","more":"<ul>\n<li>应用：<strong>RequireJS</strong><br>解决的主要问题：<ul>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ul>\n</li>\n<li><code>define([id], [dependencies], factory);</code><ul>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ul>\n</li>\n<li><code>require([dependencies], function(){});</code><ul>\n<li>dependencies：一个数组，表示所依赖的模块</li>\n<li>function：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n<li><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块 myModule.js</span></div><div class=\"line\">define([<span class=\"string\">'dependency'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Byron'</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">printName</span>: printName</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'myModule'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\">　 my.printName();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><ul>\n<li>CMD 即<code>Common Module Definition</code>通用模块定义</li>\n<li>应用：<strong>SeaJS</strong><br>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</li>\n<li><code>define([id],[deps],factory)</code><ul>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n<li>factory有三个参数：<code>function(require, exports, module)</code></li>\n</ul>\n</li>\n<li><code>require(id)</code><ul>\n<li>require 是一个方法，接受<strong>模块标识</strong>作为唯一参数，用来获取其他模块提供的接口</li>\n</ul>\n</li>\n<li><code>exports</code><ul>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n</ul>\n</li>\n<li><code>module</code><ul>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ul>\n</li>\n<li>使用例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义模块  myModule.js</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</div><div class=\"line\">  $(<span class=\"string\">'div'</span>).addClass(<span class=\"string\">'active'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载模块</span></div><div class=\"line\">seajs.use([<span class=\"string\">'myModule.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">my</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"AMD与CMD的区别\"><a href=\"#AMD与CMD的区别\" class=\"headerlink\" title=\"AMD与CMD的区别\"></a>AMD与CMD的区别</h2><blockquote>\n<p>AMD 是提前执行，CMD 是延迟执行<br>在模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块，CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>"},{"title":"有关CSS的tip","date":"2017-04-10T02:16:38.000Z","_content":"#### position的值，relative和absolute分别是相对于谁进行定位的？\n* `absolute` 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。\n* `fixed` （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。\n* `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。\n* `static` 默认值。没有定位，元素出现在正常的流中\n\n<!--more-->\n\n#### display:none和visibility:hidden的区别？\n* `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n* `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n#### position:absolute和float属性的异同\n* 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n* 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。\n\n#### CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n* 选择符\n```\n1.id选择器（ #myid）\n\n2.类选择器（.myclassname）\n\n3.标签选择器（div, h1, p）\n\n4.相邻选择器（h1 + p）\n\n5.子选择器（ul > li）\n\n6.后代选择器（li a）\n\n7.通配符选择器（ * ）\n\n8.属性选择器（a[rel = \"external\"]）\n\n9.伪类选择器（a: hover, li:nth-child）\n```\n* 继承\n\t* **不可继承：** display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi\n\t* **所有元素可继承：** visibility、cursor\n\t* **内联元素可继承：** letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction\n\t* **终端块状元素可继承：** text-indent和text-align\n\t* **列表元素可继承：** list-style、list-style-type、list-style-position、list-style-image\n* 优先级\n```\n!important > id > class > tag\n```\n* 新增伪类\n```\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\np:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:enabled  :disabled 控制表单控件的禁用状态。\n\n:checked        单选框或复选框被选中。\n```\n\n#### CSS3有哪些新特性？\n```\nCSS3实现圆角（border-radius）\n\n阴影（box-shadow）\n\n对文字加特效（text-shadow）\n\n线性渐变（gradient）\n\n动画（animation）\n\n变换（transform）\n\ntransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n//旋转,缩放,定位,倾斜\n\n增加了更多的CSS选择器  多背景 rgba\n\n在CSS3中唯一引入的伪元素是::selection.\n\n媒体查询，多栏布局\n\nborder-image\n\n盒模型计算方式（box-sizing）\n```\n\n#### 有关盒模型计算\n* **content-box（默认）**\n\n布局所占宽度Width：\n```\nWidth = width + padding-left + padding-right + border-left + border-right\n```\n布局所占高度Height：\n```\nHeight = height + padding-top + padding-bottom + border-top + border-bottom\n```\n\n* **padding-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right) + border-top + border-bottom\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom) + border-top + border-bottom\n```\n\n* **border-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right + border-left + border-right)\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom + border-top + border-bottom)\n```\n\n#### 清除浮动的技巧\n* **使用空标签清除浮动。**\n这种方法是在所有浮动标签后面添加一个空标签，定义css `clear:both` ，弊端就是增加了无意义。\n* **使用overflow。**\n给包含浮动元素的父标签添加css属性 `overflow:auto; zoom:1; zoom:1` 用于兼容IE6。\n* **使用after伪对象清除浮动。**\n该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n```css\n#parent:after{\n\tcontent:\".\";\n\theight:0;\n\tvisibility:hidden;\n\tdisplay:block;\n\tclear:both;\n}\n```\n\n#### 浮动元素引起的问题和解决办法\n* 浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n* 解决办法：\n（1）使用CSS中的`clear:both;`属性来清除元素的浮动可解决2、3问题\n（2）对于问题1，添加如下样式，给父元素添加`clearfix`样式：\n```css\n.clearfix:after{\n\tcontent: \".\";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix{\n\tdisplay: inline-block;\n} /* for IE/Mac */\n```","source":"_posts/17-04-10-13.md","raw":"---\ntitle: 有关CSS的tip\ndate: 2017-04-10 10:16:38\n---\n#### position的值，relative和absolute分别是相对于谁进行定位的？\n* `absolute` 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。\n* `fixed` （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。\n* `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。\n* `static` 默认值。没有定位，元素出现在正常的流中\n\n<!--more-->\n\n#### display:none和visibility:hidden的区别？\n* `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n* `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n#### position:absolute和float属性的异同\n* 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n* 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。\n\n#### CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n* 选择符\n```\n1.id选择器（ #myid）\n\n2.类选择器（.myclassname）\n\n3.标签选择器（div, h1, p）\n\n4.相邻选择器（h1 + p）\n\n5.子选择器（ul > li）\n\n6.后代选择器（li a）\n\n7.通配符选择器（ * ）\n\n8.属性选择器（a[rel = \"external\"]）\n\n9.伪类选择器（a: hover, li:nth-child）\n```\n* 继承\n\t* **不可继承：** display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi\n\t* **所有元素可继承：** visibility、cursor\n\t* **内联元素可继承：** letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction\n\t* **终端块状元素可继承：** text-indent和text-align\n\t* **列表元素可继承：** list-style、list-style-type、list-style-position、list-style-image\n* 优先级\n```\n!important > id > class > tag\n```\n* 新增伪类\n```\np:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\np:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\np:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\np:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n:enabled  :disabled 控制表单控件的禁用状态。\n\n:checked        单选框或复选框被选中。\n```\n\n#### CSS3有哪些新特性？\n```\nCSS3实现圆角（border-radius）\n\n阴影（box-shadow）\n\n对文字加特效（text-shadow）\n\n线性渐变（gradient）\n\n动画（animation）\n\n变换（transform）\n\ntransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n//旋转,缩放,定位,倾斜\n\n增加了更多的CSS选择器  多背景 rgba\n\n在CSS3中唯一引入的伪元素是::selection.\n\n媒体查询，多栏布局\n\nborder-image\n\n盒模型计算方式（box-sizing）\n```\n\n#### 有关盒模型计算\n* **content-box（默认）**\n\n布局所占宽度Width：\n```\nWidth = width + padding-left + padding-right + border-left + border-right\n```\n布局所占高度Height：\n```\nHeight = height + padding-top + padding-bottom + border-top + border-bottom\n```\n\n* **padding-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right) + border-top + border-bottom\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom) + border-top + border-bottom\n```\n\n* **border-box**\n\n布局所占宽度Width：\n```\nWidth = width(包含padding-left + padding-right + border-left + border-right)\n```\n布局所占高度Height：\n```\nHeight = height(包含padding-top + padding-bottom + border-top + border-bottom)\n```\n\n#### 清除浮动的技巧\n* **使用空标签清除浮动。**\n这种方法是在所有浮动标签后面添加一个空标签，定义css `clear:both` ，弊端就是增加了无意义。\n* **使用overflow。**\n给包含浮动元素的父标签添加css属性 `overflow:auto; zoom:1; zoom:1` 用于兼容IE6。\n* **使用after伪对象清除浮动。**\n该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n```css\n#parent:after{\n\tcontent:\".\";\n\theight:0;\n\tvisibility:hidden;\n\tdisplay:block;\n\tclear:both;\n}\n```\n\n#### 浮动元素引起的问题和解决办法\n* 浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n* 解决办法：\n（1）使用CSS中的`clear:both;`属性来清除元素的浮动可解决2、3问题\n（2）对于问题1，添加如下样式，给父元素添加`clearfix`样式：\n```css\n.clearfix:after{\n\tcontent: \".\";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix{\n\tdisplay: inline-block;\n} /* for IE/Mac */\n```","slug":"17-04-10-13","published":1,"updated":"2017-07-15T07:48:13.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodc000at0cgwt1pmq7t","content":"<h4 id=\"position的值，relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值，relative和absolute分别是相对于谁进行定位的？\"></a>position的值，relative和absolute分别是相对于谁进行定位的？</h4><ul>\n<li><code>absolute</code> 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。</li>\n<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h4><ul>\n<li><code>display:none</code> 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>\n<li><code>visibility:hidden</code> 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>\n</ul>\n<h4 id=\"position-absolute和float属性的异同\"><a href=\"#position-absolute和float属性的异同\" class=\"headerlink\" title=\"position:absolute和float属性的异同\"></a>position:absolute和float属性的异同</h4><ul>\n<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>\n<li>不同点：float仍会占据位置，position会覆盖文档流中的其他元素。</li>\n</ul>\n<h4 id=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\"><a href=\"#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><ul>\n<li><p>选择符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.id选择器（ #myid）</div><div class=\"line\"></div><div class=\"line\">2.类选择器（.myclassname）</div><div class=\"line\"></div><div class=\"line\">3.标签选择器（div, h1, p）</div><div class=\"line\"></div><div class=\"line\">4.相邻选择器（h1 + p）</div><div class=\"line\"></div><div class=\"line\">5.子选择器（ul &gt; li）</div><div class=\"line\"></div><div class=\"line\">6.后代选择器（li a）</div><div class=\"line\"></div><div class=\"line\">7.通配符选择器（ * ）</div><div class=\"line\"></div><div class=\"line\">8.属性选择器（a[rel = &quot;external&quot;]）</div><div class=\"line\"></div><div class=\"line\">9.伪类选择器（a: hover, li:nth-child）</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承</p>\n<ul>\n<li><strong>不可继承：</strong> display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li>\n<li><strong>所有元素可继承：</strong> visibility、cursor</li>\n<li><strong>内联元素可继承：</strong> letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</li>\n<li><strong>终端块状元素可继承：</strong> text-indent和text-align</li>\n<li><strong>列表元素可继承：</strong> list-style、list-style-type、list-style-position、list-style-image</li>\n</ul>\n</li>\n<li><p>优先级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">!important &gt; id &gt; class &gt; tag</div></pre></td></tr></table></figure>\n</li>\n<li><p>新增伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">:enabled  :disabled 控制表单控件的禁用状态。</div><div class=\"line\"></div><div class=\"line\">:checked        单选框或复选框被选中。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSS3实现圆角（border-radius）</div><div class=\"line\"></div><div class=\"line\">阴影（box-shadow）</div><div class=\"line\"></div><div class=\"line\">对文字加特效（text-shadow）</div><div class=\"line\"></div><div class=\"line\">线性渐变（gradient）</div><div class=\"line\"></div><div class=\"line\">动画（animation）</div><div class=\"line\"></div><div class=\"line\">变换（transform）</div><div class=\"line\"></div><div class=\"line\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);</div><div class=\"line\">//旋转,缩放,定位,倾斜</div><div class=\"line\"></div><div class=\"line\">增加了更多的CSS选择器  多背景 rgba</div><div class=\"line\"></div><div class=\"line\">在CSS3中唯一引入的伪元素是::selection.</div><div class=\"line\"></div><div class=\"line\">媒体查询，多栏布局</div><div class=\"line\"></div><div class=\"line\">border-image</div><div class=\"line\"></div><div class=\"line\">盒模型计算方式（box-sizing）</div></pre></td></tr></table></figure>\n<h4 id=\"有关盒模型计算\"><a href=\"#有关盒模型计算\" class=\"headerlink\" title=\"有关盒模型计算\"></a>有关盒模型计算</h4><ul>\n<li><strong>content-box（默认）</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>padding-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>border-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure></p>\n<h4 id=\"清除浮动的技巧\"><a href=\"#清除浮动的技巧\" class=\"headerlink\" title=\"清除浮动的技巧\"></a>清除浮动的技巧</h4><ul>\n<li><strong>使用空标签清除浮动。</strong><br>这种方法是在所有浮动标签后面添加一个空标签，定义css <code>clear:both</code> ，弊端就是增加了无意义。</li>\n<li><strong>使用overflow。</strong><br>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1; zoom:1</code> 用于兼容IE6。</li>\n<li><strong>使用after伪对象清除浮动。</strong><br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#parent</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>:hidden;</div><div class=\"line\">\t<span class=\"attribute\">display</span>:block;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>:both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"浮动元素引起的问题和解决办法\"><a href=\"#浮动元素引起的问题和解决办法\" class=\"headerlink\" title=\"浮动元素引起的问题和解决办法\"></a>浮动元素引起的问题和解决办法</h4><ul>\n<li>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n<li>解决办法：<br>（1）使用CSS中的<code>clear:both;</code>属性来清除元素的浮动可解决2、3问题<br>（2）对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>: both;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">&#125; <span class=\"comment\">/* for IE/Mac */</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"position的值，relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值，relative和absolute分别是相对于谁进行定位的？\"></a>position的值，relative和absolute分别是相对于谁进行定位的？</h4><ul>\n<li><code>absolute</code> 生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。</li>\n<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n</ul>","more":"<h4 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h4><ul>\n<li><code>display:none</code> 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>\n<li><code>visibility:hidden</code> 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>\n</ul>\n<h4 id=\"position-absolute和float属性的异同\"><a href=\"#position-absolute和float属性的异同\" class=\"headerlink\" title=\"position:absolute和float属性的异同\"></a>position:absolute和float属性的异同</h4><ul>\n<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>\n<li>不同点：float仍会占据位置，position会覆盖文档流中的其他元素。</li>\n</ul>\n<h4 id=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\"><a href=\"#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><ul>\n<li><p>选择符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.id选择器（ #myid）</div><div class=\"line\"></div><div class=\"line\">2.类选择器（.myclassname）</div><div class=\"line\"></div><div class=\"line\">3.标签选择器（div, h1, p）</div><div class=\"line\"></div><div class=\"line\">4.相邻选择器（h1 + p）</div><div class=\"line\"></div><div class=\"line\">5.子选择器（ul &gt; li）</div><div class=\"line\"></div><div class=\"line\">6.后代选择器（li a）</div><div class=\"line\"></div><div class=\"line\">7.通配符选择器（ * ）</div><div class=\"line\"></div><div class=\"line\">8.属性选择器（a[rel = &quot;external&quot;]）</div><div class=\"line\"></div><div class=\"line\">9.伪类选择器（a: hover, li:nth-child）</div></pre></td></tr></table></figure>\n</li>\n<li><p>继承</p>\n<ul>\n<li><strong>不可继承：</strong> display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li>\n<li><strong>所有元素可继承：</strong> visibility、cursor</li>\n<li><strong>内联元素可继承：</strong> letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</li>\n<li><strong>终端块状元素可继承：</strong> text-indent和text-align</li>\n<li><strong>列表元素可继承：</strong> list-style、list-style-type、list-style-position、list-style-image</li>\n</ul>\n</li>\n<li><p>优先级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">!important &gt; id &gt; class &gt; tag</div></pre></td></tr></table></figure>\n</li>\n<li><p>新增伪类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</div><div class=\"line\"></div><div class=\"line\">:enabled  :disabled 控制表单控件的禁用状态。</div><div class=\"line\"></div><div class=\"line\">:checked        单选框或复选框被选中。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSS3实现圆角（border-radius）</div><div class=\"line\"></div><div class=\"line\">阴影（box-shadow）</div><div class=\"line\"></div><div class=\"line\">对文字加特效（text-shadow）</div><div class=\"line\"></div><div class=\"line\">线性渐变（gradient）</div><div class=\"line\"></div><div class=\"line\">动画（animation）</div><div class=\"line\"></div><div class=\"line\">变换（transform）</div><div class=\"line\"></div><div class=\"line\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);</div><div class=\"line\">//旋转,缩放,定位,倾斜</div><div class=\"line\"></div><div class=\"line\">增加了更多的CSS选择器  多背景 rgba</div><div class=\"line\"></div><div class=\"line\">在CSS3中唯一引入的伪元素是::selection.</div><div class=\"line\"></div><div class=\"line\">媒体查询，多栏布局</div><div class=\"line\"></div><div class=\"line\">border-image</div><div class=\"line\"></div><div class=\"line\">盒模型计算方式（box-sizing）</div></pre></td></tr></table></figure>\n<h4 id=\"有关盒模型计算\"><a href=\"#有关盒模型计算\" class=\"headerlink\" title=\"有关盒模型计算\"></a>有关盒模型计算</h4><ul>\n<li><strong>content-box（默认）</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>padding-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>border-box</strong></li>\n</ul>\n<p>布局所占宽度Width：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure></p>\n<p>布局所占高度Height：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure></p>\n<h4 id=\"清除浮动的技巧\"><a href=\"#清除浮动的技巧\" class=\"headerlink\" title=\"清除浮动的技巧\"></a>清除浮动的技巧</h4><ul>\n<li><strong>使用空标签清除浮动。</strong><br>这种方法是在所有浮动标签后面添加一个空标签，定义css <code>clear:both</code> ，弊端就是增加了无意义。</li>\n<li><strong>使用overflow。</strong><br>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1; zoom:1</code> 用于兼容IE6。</li>\n<li><strong>使用after伪对象清除浮动。</strong><br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#parent</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>:hidden;</div><div class=\"line\">\t<span class=\"attribute\">display</span>:block;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>:both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"浮动元素引起的问题和解决办法\"><a href=\"#浮动元素引起的问题和解决办法\" class=\"headerlink\" title=\"浮动元素引起的问题和解决办法\"></a>浮动元素引起的问题和解决办法</h4><ul>\n<li>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n<li>解决办法：<br>（1）使用CSS中的<code>clear:both;</code>属性来清除元素的浮动可解决2、3问题<br>（2）对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">clear</span>: both;</div><div class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">&#125; <span class=\"comment\">/* for IE/Mac */</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"title":"JavaScript正则表达式","date":"2017-04-21T07:22:18.000Z","_content":">正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n<!--more-->\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","source":"_posts/17-04-21-14.md","raw":"---\ntitle: JavaScript正则表达式\ndate: 2017-04-21 15:22:18\n---\n>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。\n\n<!--more-->\n\n## 正则表达式的定义\n* 一种是使用正则表达式直接量，将其包含在一对斜杠`/`之间的字符\n```javascript\nvar pattern = /s$/;\n```\n* 另一种是使用`RegExp()`构造函数\n```javascript\nvar pattern = new RegExp('s');\n```\n上面两种表达方式是等价的，用来匹配所有以`s`结尾的字符串\n正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的\n\n## 直接量字符\n非字母的字符匹配，通过`\\`反斜杠作为前缀转义\n```\n\\0\t匹配null字符(\\u0000)\n[\\b]\t匹配退格符(\\u0008)，区别\\b\n\\t  \t匹配制表符tab(\\u0009)\n\\n  \t匹配换行符(\\u000A)\n\\v      匹配垂直制表符(\\u000B)\n\\f\t匹配换页符(\\u000C)\n\\r\t匹配回车键(\\u000D)\n\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符\n\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符\n\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符\n```\n\n## 字符类\n```\n[...]   匹配方括号内的任意字符\n[^...] \t匹配除方括号内的以外的任意字符\n. \t除换行符和其他Unicode行终止符之外的任意字符\n-\t匹配范围，如[a-z]表示所有的小写字母\n\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s \t任何Unicode空白符\n\\S\t任何非Unicode空白符的字符\n\\d\t任何非ASCII数字，等价于[0-9]\n\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]\n```\n\n## 重复\n```\n{n,m} \t匹配前一项至少n次，至多m次\n{n,} \t匹配前一项至少n次，次数可能比n大\n{n} \t匹配前一项n次\n?\t匹配前一项0次或者1次，等价于{0,1}\n+\t匹配前一项1次或者更多次，等价于{1,}\n*\t匹配前一项0次或者更多次，等价于{0,}\n```\n注意：因为可以匹配0次，所以正在表达式`/a/`实际上与字符`bbb`匹配，因为这个字符串含0个`a`\n\n## 非贪婪的重复\n默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为**贪婪的**匹配\n而**非贪婪**的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可\n```javascript\n//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组\nvar a = /a+/.exec('aaa');\t//[\"aaa\"]\nvar b = /a+?/.exec('aaa');\t//[\"a\"]\n```\n\n## 选择、分组和引用\n```\n|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef\n\t并且，如果匹配了ab就不会再往后匹配\n(...) \t把单独的项组合成子表达式\n\\n\t引用第n个带括号的子表达式\n\n```\n```javascript\n//test() 方法用于检测一个字符串是否匹配某个模式\n//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false\nvar bool = /(.)b(.)\\1b\\2/.test('abcabc')\t//true\n```\n* 上面的代码中，`\\1`表示第一个括号匹配的内容，即第一个`(.)`，匹配的是`'a'`；`\\2`表示第二个括号`(.)`，匹配的是`'c'`\n* 因为子表达式可以嵌套，所以`(s(ss))`的`\\2`所表示的是`(ss)`\n* 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用\n\n```javascript\nvar res1 = /(a|b)c\\1/.test('aca');\t//true\nvar res2 = /(a|b)c\\1/.test('acb');\t//false\n//'(a|b)'匹配了a之后，'\\1'也代表a\n```\n\n## 指定匹配边界\n```\n^\t匹配字符串的开头，在多行检索中，匹配一行的开头\n$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾\n\\b \t匹配一个单词的边界\n\\B \t匹配非单词边界的位置\n(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配\n```\n\n## 修饰符\n```\ni \t执行不区分大小写的匹配\ng \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止\nm \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配\n\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾\n```\n```javascript\nvar x = /test/ig\n```\n\n## 用于模式匹配的String方法\n* `search`：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1\n```javascript\n\"javascript\".search(/script/i);\t//4\n```\n* `match`：返回一个数组，成员是所有匹配的子字符串，**该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本**\n```javascript\n\"1 plus 2 equals 3\".match(/\\d+/g); //[\"1\",\"2\",\"3\"]\n```\n* `replace`：按照给定的正则表达式进行替换，返回替换后的字符串\n```\n第二个参数：\n$`\t指代匹配结果前面的文本\n$'\t指代匹配结果后面的文本\n$n \t指代匹配成功后的第n组内容，n从1开始\n$$ \t指代美元符号$\n```\n\t```javascript\n\"hello world\".replace(/(\\w+)\\s(\\w+)/,'$2 $1'); //\"world hello\"\n```\n\n* `split`：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员\n```javascript\n\"123,456,789\".split(','); //[\"123\",\"456\",\"789\"]\n```\n\n## RegExp对象\n构造函数带有两个参数，第二个参数是可选的\n```javascript\nvar regexp = new RegExp('\\\\d{5}','g'); //全局查找5个数字\n```\n包含5个属性：\n* source：只读字符串，包含正则表达式的文本\n* global：只读布尔值，用以说明这个正则表达式是否带有修饰符g\n* ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i\n* multiline：只读布尔值，用以说明正则表达式是否带有修饰符m\n* lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置\n\n## RegExp方法\n* `exec`：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null\n* `test`：返回一个布尔值，表示当前模式是否能匹配参数字符串","slug":"17-04-21-14","published":1,"updated":"2017-07-15T07:48:17.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodh000bt0cgh4wztv35","content":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\0\t匹配null字符(\\u0000)</div><div class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</div><div class=\"line\">\\t  \t匹配制表符tab(\\u0009)</div><div class=\"line\">\\n  \t匹配换行符(\\u000A)</div><div class=\"line\">\\v      匹配垂直制表符(\\u000B)</div><div class=\"line\">\\f\t匹配换页符(\\u000C)</div><div class=\"line\">\\r\t匹配回车键(\\u000D)</div><div class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</div><div class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</div><div class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</div></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...]   匹配方括号内的任意字符</div><div class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</div><div class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</div><div class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</div><div class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</div><div class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</div><div class=\"line\">\\s \t任何Unicode空白符</div><div class=\"line\">\\S\t任何非Unicode空白符的字符</div><div class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</div><div class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</div></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</div><div class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</div><div class=\"line\">&#123;n&#125; \t匹配前一项n次</div><div class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</div><div class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</div><div class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</div></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</div><div class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</div><div class=\"line\">(...) \t把单独的项组合成子表达式</div><div class=\"line\">\\n\t引用第n个带括号的子表达式</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></div><div class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></div></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</div><div class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</div><div class=\"line\">\\b \t匹配一个单词的边界</div><div class=\"line\">\\B \t匹配非单词边界的位置</div><div class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</div><div class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">i \t执行不区分大小写的匹配</div><div class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</div><div class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</div><div class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></div></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第二个参数：</div><div class=\"line\">$`\t指代匹配结果前面的文本</div><div class=\"line\">$&apos;\t指代匹配结果后面的文本</div><div class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</div><div class=\"line\">$$ \t指代美元符号$</div></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></div></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正则表达式是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法。</p>\n</blockquote>","more":"<h2 id=\"正则表达式的定义\"><a href=\"#正则表达式的定义\" class=\"headerlink\" title=\"正则表达式的定义\"></a>正则表达式的定义</h2><ul>\n<li><p>一种是使用正则表达式直接量，将其包含在一对斜杠<code>/</code>之间的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/s$/</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>另一种是使用<code>RegExp()</code>构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'s'</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面两种表达方式是等价的，用来匹配所有以<code>s</code>结尾的字符串<br>正则表达式的模式规则是由一个字符序列组成的，所有字母和数字都是按照字面含义进行匹配的</p>\n<h2 id=\"直接量字符\"><a href=\"#直接量字符\" class=\"headerlink\" title=\"直接量字符\"></a>直接量字符</h2><p>非字母的字符匹配，通过<code>\\</code>反斜杠作为前缀转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\0\t匹配null字符(\\u0000)</div><div class=\"line\">[\\b]\t匹配退格符(\\u0008)，区别\\b</div><div class=\"line\">\\t  \t匹配制表符tab(\\u0009)</div><div class=\"line\">\\n  \t匹配换行符(\\u000A)</div><div class=\"line\">\\v      匹配垂直制表符(\\u000B)</div><div class=\"line\">\\f\t匹配换页符(\\u000C)</div><div class=\"line\">\\r\t匹配回车键(\\u000D)</div><div class=\"line\">\\xnn\t匹配一个以两位16进制数(\\x00-\\xFF)表示的字符</div><div class=\"line\">\\uxxxx\t匹配一个以四位16进制数(\\u0000-\\uFFFF)表示的Unicode字符</div><div class=\"line\">\\cX\t表示Ctrl-[X]，其中的X是A-Z之中的任一个英文字母，用来匹配控制字符</div></pre></td></tr></table></figure></p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...]   匹配方括号内的任意字符</div><div class=\"line\">[^...] \t匹配除方括号内的以外的任意字符</div><div class=\"line\">. \t除换行符和其他Unicode行终止符之外的任意字符</div><div class=\"line\">-\t匹配范围，如[a-z]表示所有的小写字母</div><div class=\"line\">\\w      任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</div><div class=\"line\">\\W \t任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]</div><div class=\"line\">\\s \t任何Unicode空白符</div><div class=\"line\">\\S\t任何非Unicode空白符的字符</div><div class=\"line\">\\d\t任何非ASCII数字，等价于[0-9]</div><div class=\"line\">\\D\t除了ASCII数字之外的任何字符，等价于[^0-9]</div></pre></td></tr></table></figure>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;n,m&#125; \t匹配前一项至少n次，至多m次</div><div class=\"line\">&#123;n,&#125; \t匹配前一项至少n次，次数可能比n大</div><div class=\"line\">&#123;n&#125; \t匹配前一项n次</div><div class=\"line\">?\t匹配前一项0次或者1次，等价于&#123;0,1&#125;</div><div class=\"line\">+\t匹配前一项1次或者更多次，等价于&#123;1,&#125;</div><div class=\"line\">*\t匹配前一项0次或者更多次，等价于&#123;0,&#125;</div></pre></td></tr></table></figure>\n<p>注意：因为可以匹配0次，所以正在表达式<code>/a/</code>实际上与字符<code>bbb</code>匹配，因为这个字符串含0个<code>a</code></p>\n<h2 id=\"非贪婪的重复\"><a href=\"#非贪婪的重复\" class=\"headerlink\" title=\"非贪婪的重复\"></a>非贪婪的重复</h2><p>默认情况下，匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，即匹配知道下一个字符不满足匹配规则为止，这称为<strong>贪婪的</strong>匹配<br>而<strong>非贪婪</strong>的匹配，一旦条件满足，就不再往下匹配，只需在待匹配的字符后跟随一个问号即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"regexp\">/a+/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"aaa\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"regexp\">/a+?/</span>.exec(<span class=\"string\">'aaa'</span>);\t<span class=\"comment\">//[\"a\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"选择、分组和引用\"><a href=\"#选择、分组和引用\" class=\"headerlink\" title=\"选择、分组和引用\"></a>选择、分组和引用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">|\t分隔供选择的字符，如/ab|cd|ef/表示可以匹配ab或cd或ef</div><div class=\"line\">\t并且，如果匹配了ab就不会再往后匹配</div><div class=\"line\">(...) \t把单独的项组合成子表达式</div><div class=\"line\">\\n\t引用第n个带括号的子表达式</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//test() 方法用于检测一个字符串是否匹配某个模式</span></div><div class=\"line\"><span class=\"comment\">//如果字符串中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false</span></div><div class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"regexp\">/(.)b(.)\\1b\\2/</span>.test(<span class=\"string\">'abcabc'</span>)\t<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容，即第一个<code>(.)</code>，匹配的是<code>&#39;a&#39;</code>；<code>\\2</code>表示第二个括号<code>(.)</code>，匹配的是<code>&#39;c&#39;</code></li>\n<li>因为子表达式可以嵌套，所以<code>(s(ss))</code>的<code>\\2</code>所表示的是<code>(ss)</code></li>\n<li>对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是哪个模式相匹配的文本的引用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'aca'</span>);\t<span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"regexp\">/(a|b)c\\1/</span>.test(<span class=\"string\">'acb'</span>);\t<span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"comment\">//'(a|b)'匹配了a之后，'\\1'也代表a</span></div></pre></td></tr></table></figure>\n<h2 id=\"指定匹配边界\"><a href=\"#指定匹配边界\" class=\"headerlink\" title=\"指定匹配边界\"></a>指定匹配边界</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">^\t匹配字符串的开头，在多行检索中，匹配一行的开头</div><div class=\"line\">$ \t匹配字符串的结尾，在多行检索中，匹配一行的结尾</div><div class=\"line\">\\b \t匹配一个单词的边界</div><div class=\"line\">\\B \t匹配非单词边界的位置</div><div class=\"line\">(?=p)\t零宽正向先行断言，要求接下来的字符都与p匹配</div><div class=\"line\">(?!p)\t零宽负向先行断言，要求接下来的字符不与p匹配</div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">i \t执行不区分大小写的匹配</div><div class=\"line\">g \t执行一个全局匹配，找到所有的匹配而不是找到一个后就停止</div><div class=\"line\">m \t多行模式匹配，在这种模式下，如果待检索的字符串包含多行那么^和$除了匹配</div><div class=\"line\">\t整个字符串的开始和结尾之外，还能匹配每行的开始和结尾</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"regexp\">/test/ig</span></div></pre></td></tr></table></figure>\n<h2 id=\"用于模式匹配的String方法\"><a href=\"#用于模式匹配的String方法\" class=\"headerlink\" title=\"用于模式匹配的String方法\"></a>用于模式匹配的String方法</h2><ul>\n<li><p><code>search</code>：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"javascript\"</span>.search(<span class=\"regexp\">/script/i</span>);\t<span class=\"comment\">//4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>match</code>：返回一个数组，成员是所有匹配的子字符串，<strong>该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"1 plus 2 equals 3\"</span>.match(<span class=\"regexp\">/\\d+/g</span>); <span class=\"comment\">//[\"1\",\"2\",\"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>replace</code>：按照给定的正则表达式进行替换，返回替换后的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第二个参数：</div><div class=\"line\">$`\t指代匹配结果前面的文本</div><div class=\"line\">$&apos;\t指代匹配结果后面的文本</div><div class=\"line\">$n \t指代匹配成功后的第n组内容，n从1开始</div><div class=\"line\">$$ \t指代美元符号$</div></pre></td></tr></table></figure>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello world\"</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>,<span class=\"string\">'$2 $1'</span>); <span class=\"comment\">//\"world hello\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>split</code>：按照给定规则进行字符串分割，返回一个数组，包含分隔后的各个成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"123,456,789\"</span>.split(<span class=\"string\">','</span>); <span class=\"comment\">//[\"123\",\"456\",\"789\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>构造函数带有两个参数，第二个参数是可选的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'\\\\d&#123;5&#125;'</span>,<span class=\"string\">'g'</span>); <span class=\"comment\">//全局查找5个数字</span></div></pre></td></tr></table></figure></p>\n<p>包含5个属性：</p>\n<ul>\n<li>source：只读字符串，包含正则表达式的文本</li>\n<li>global：只读布尔值，用以说明这个正则表达式是否带有修饰符g</li>\n<li>ignoreCase：只读布尔值，用以说明正则表达式是否带有修饰符i</li>\n<li>multiline：只读布尔值，用以说明正则表达式是否带有修饰符m</li>\n<li>lastIndex：可读写的整数，如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置</li>\n</ul>\n<h2 id=\"RegExp方法\"><a href=\"#RegExp方法\" class=\"headerlink\" title=\"RegExp方法\"></a>RegExp方法</h2><ul>\n<li><code>exec</code>：返回匹配结果，如果发现匹配就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null</li>\n<li><code>test</code>：返回一个布尔值，表示当前模式是否能匹配参数字符串</li>\n</ul>"},{"title":"Vue.js学习笔记（一）","date":"2017-05-11T13:25:58.000Z","_content":"> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API\n\n<!--more-->\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- 默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`\n```js\n//import表示导入组件\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n``` ","source":"_posts/17-05-11-16.md","raw":"---\ntitle: Vue.js学习笔记（一）\ndate: 2017-05-11 21:25:58\n---\n> Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API\n\n<!--more-->\n\n## 搭建开发环境\n\n使用git，输入指令\n```python\n# 安装vue-cli\n$ cnpm install -g vue-cli\n# 创建一个基于 \"webpack\" 模板的新项目\n$ vue init webpack my-project\n# 安装依赖\n$ cd my-project\n$ cnmp install\n# 开启项目\n$ npm run dev\n```\n\n## 模板解析\n`index.html`\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>blog-project</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- 默认调用src里的main.js -->\n  </body>\n</html>\n```\n\n`src/main.js`\n```js\n//import表示导入组件\nimport Vue from 'vue'   //导入vue框架\nimport App from './App'   //同级目录下的App.vue\nimport router from './router'   //同级目录下的router文件夹\n\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }  //注册一个app\n})\n``` ","slug":"17-05-11-16","published":1,"updated":"2017-07-15T07:48:20.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodk000ct0cgtmzrrzve","content":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装vue-cli</span></div><div class=\"line\">$ cnpm install -g vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖</span></div><div class=\"line\">$ cd my-project</div><div class=\"line\">$ cnmp install</div><div class=\"line\"><span class=\"comment\"># 开启项目</span></div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 默认调用src里的main.js --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code></p>\n<pre><code class=\"js\"><span class=\"comment\">//import表示导入组件</span>\n<span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span>\n<span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span>\n<span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span>\n\n\nVue.config.productionTip = <span class=\"literal\">false</span>\n\n<span class=\"comment\">/* eslint-disable no-new */</span>\n<span class=\"keyword\">new</span> Vue({\n  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,\n  router,\n  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;App/&gt;'</span>,\n  <span class=\"attr\">components</span>: { App }  <span class=\"comment\">//注册一个app</span>\n})\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API</p>\n</blockquote>","more":"<h2 id=\"搭建开发环境\"><a href=\"#搭建开发环境\" class=\"headerlink\" title=\"搭建开发环境\"></a>搭建开发环境</h2><p>使用git，输入指令<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装vue-cli</span></div><div class=\"line\">$ cnpm install -g vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 \"webpack\" 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖</span></div><div class=\"line\">$ cd my-project</div><div class=\"line\">$ cnmp install</div><div class=\"line\"><span class=\"comment\"># 开启项目</span></div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure></p>\n<h2 id=\"模板解析\"><a href=\"#模板解析\" class=\"headerlink\" title=\"模板解析\"></a>模板解析</h2><p><code>index.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>blog-project<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 默认调用src里的main.js --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>src/main.js</code></p>\n<pre><code class=\"js\"><span class=\"comment\">//import表示导入组件</span>\n<span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//导入vue框架</span>\n<span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>   <span class=\"comment\">//同级目录下的App.vue</span>\n<span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span>   <span class=\"comment\">//同级目录下的router文件夹</span>\n\n\nVue.config.productionTip = <span class=\"literal\">false</span>\n\n<span class=\"comment\">/* eslint-disable no-new */</span>\n<span class=\"keyword\">new</span> Vue({\n  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,\n  router,\n  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;App/&gt;'</span>,\n  <span class=\"attr\">components</span>: { App }  <span class=\"comment\">//注册一个app</span>\n})\n</code></pre>"},{"title":"JS继承笔记","date":"2017-07-07T14:02:11.000Z","_content":"在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n<!--more-->\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","source":"_posts/17-07-07-17.md","raw":"---\ntitle: JS继承笔记\ndate: 2017-07-07 22:02:11\n---\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。\n\n<!--more-->\n\n看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png)\n通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。\n\n在以上基础下，得出了几种继承方法：\n```javascript\n//现有两个构造函数\n\nfunction Animal() {\n  this.species = \"动物\";\n}\n\nfunction Cat(name,color) {\n  this.name = name;\n  this.color = color;\n}\n```\n\n## 构造函数的继承\n\n* **构造函数绑定：**使用`call`或`apply`方法，将父对象的构造函数绑定在子对象上\n```javascript\nfunction Cat(name,color) {\n  Animal.apply(this.arguments);\n  this.name = name;\n  this.color = color;\n}\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **prototype模式：**将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal\n//但是constructor是必须指向其构造函数的，所以要修正成Cat\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); //动物\n```\n\n* **直接继承prototype：**由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n```javascript\nfuntion Animal() {}\nAnimal.prototype.species = \"动物\";\n\nCat.prototype = Animal.prototype;\nCat.prototype.constructor = Cat;\n```\n\t此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。\n\n* **利用空对象作中介：**（重点方法）\n```javascript\nvar F = function() {}\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\n```\n\t可以将此方法封装为一个函数\n```javascript\nfunction extend(child,parent) {\n  var temp = function() {};\n  temp.prototype = parent.prototype;\n  child.prototype = new temp();\n  child.prototype.constructor = child;\n  child.uber = parent.prototype;//为了实现继承的完备性，纯属备用性质\n}\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png)\n","slug":"17-07-07-17","published":1,"updated":"2017-08-16T13:12:01.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodn000dt0cgoehiqqwb","content":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>\n<a id=\"more\"></a>\n<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt=\"\"><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//现有两个构造函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  Animal.apply(<span class=\"keyword\">this</span>.arguments);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div><div class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></div><div class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">funtion Animal() &#123;&#125;</div><div class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">F.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">  temp.prototype = parent.prototype;</div><div class=\"line\">  child.prototype = <span class=\"keyword\">new</span> temp();</div><div class=\"line\">  child.prototype.constructor = child;</div><div class=\"line\">  child.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。<br>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript并不存在类，所以需要通过其他的方法模拟出“类”。</p>","more":"<p>看了阮一峰的继承博文，理了理里面各种属性的关系，整理成一张图，大概是这样：<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-1.png\" alt=\"\"><br>通过prototype属性，实例dogA和实例dogB可以共同享有species属性，并且实现了联动修改，节约了内存占用。</p>\n<p>在以上基础下，得出了几种继承方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//现有两个构造函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h2><ul>\n<li><p><strong>构造函数绑定：</strong>使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name,color</span>) </span>&#123;</div><div class=\"line\">  Animal.apply(<span class=\"keyword\">this</span>.arguments);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prototype模式：</strong>将“猫”的prototype对象指向一个Animal的实例，那么“猫”的实例就能继承Animal了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div><div class=\"line\"><span class=\"comment\">//由于修改了Cat的prototype属性，所以Cat.prototype.constructor会指向Animal</span></div><div class=\"line\"><span class=\"comment\">//但是constructor是必须指向其构造函数的，所以要修正成Cat</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</div><div class=\"line\">alert(cat1.species); <span class=\"comment\">//动物</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接继承prototype：</strong>由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">funtion Animal() &#123;&#125;</div><div class=\"line\">Animal.prototype.species = <span class=\"string\">\"动物\"</span>;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  此方法虽然提高了效率（不用执行和建立Animal的实例），但有一个缺点，就是如果修改了Cat.prototype.species，那么Animal.prototype.species也会联动修改。</p>\n</li>\n<li><p><strong>利用空对象作中介：</strong>（重点方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">F.prototype = Animal.prototype;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();</div><div class=\"line\">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>\n<p>  可以将此方法封装为一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">child,parent</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">  temp.prototype = parent.prototype;</div><div class=\"line\">  child.prototype = <span class=\"keyword\">new</span> temp();</div><div class=\"line\">  child.prototype.constructor = child;</div><div class=\"line\">  child.uber = parent.prototype;<span class=\"comment\">//为了实现继承的完备性，纯属备用性质</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/jicheng-2.png\" alt=\"\"></p>"},{"title":"JS之this指针笔记","date":"2017-07-08T05:48:43.000Z","_content":"## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!--more-->\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n  this.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n  alert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n  test: function () {\n    this.x = 1;\n  } //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n  test: function () {\n    //在构造函数的时候也会调用其他的函数，所以this的指向就会变\n    $(this.xx).on(\"click\",function(){\n      //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n    })\n  } \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n  name: \"小明\",\n  sex: \"男\",\n  age: \"18\",\n  say: function() {\n    alert(this.name + \",\" + this.sex + \",\" + this.age);\n  }\n}\n\nvar xh = {\n  name: \"小红\",\n  sex: \"女\",\n  age: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n  this.txt = \"这是一个对象属性\";\n  $(\"div\").click($.proxy(this.myClick,this));\n  //本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n  alert(this.txt);\n  alert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","source":"_posts/17-07-08-18.md","raw":"---\ntitle: JS之this指针笔记\ndate: 2017-07-08 13:48:43\n---\n## this指针\n> this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n\n<!--more-->\n\n* **定义在全局中的函数**\n```javascript\nfunction test() {\n  this.x = 1; //此处的this指的是window\n}\nx = 0; //在全局修改这个x，函数中这个this.x也是会一起改变的\n```\n* **作为对象方法的调用**\n```javascript\nfunction test() {\n  alert(this.x);\n}\n\nvar o = {};\no.x = 1;\no.m = test;\no.m(); //1\n```\n* **作为构造函数调用**\n```javascript\nvar o = {\n  test: function () {\n    this.x = 1;\n  } //这是定义在对象中的函数，而此时this指的是对象o\n}\n```\n## this指向的改变\n```javascript\nvar o = {\n  test: function () {\n    //在构造函数的时候也会调用其他的函数，所以this的指向就会变\n    $(this.xx).on(\"click\",function(){\n      //比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了\n    })\n  } \n}\n```\n在javascript中有几个函数是可以改变this的指向的\n```javascript\nvar xm = {\n  name: \"小明\",\n  sex: \"男\",\n  age: \"18\",\n  say: function() {\n    alert(this.name + \",\" + this.sex + \",\" + this.age);\n  }\n}\n\nvar xh = {\n  name: \"小红\",\n  sex: \"女\",\n  age: \"20\"\n}\n```\n* `apply(thisObj,[argArray])`\n参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.apply(xh); //小红,女,20\n```\n\n* `call(thisObj,arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：应用某一对象的一个方法，用另一个对象替换当前对象\n```javascript\nxm.say.call(xh); //小红,女,20\n```\n\n* `bind(thisObj)(arg1,arg2...)`\n参数：替换目标对象，需要的参数arg1,arg2...\n定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）\n```javascript\nxm.say.bind(xh)(); //小红,女,20\n```\n\n* `$.proxy(fn,context)`\n参数：函数，函数所在的对象的名称\n定义：用于向上下文指向不同对象的元素添加事件。\n```javascript\ntest = function() {\n  this.txt = \"这是一个对象属性\";\n  $(\"div\").click($.proxy(this.myClick,this));\n  //本来调用click的话，this会指向div，但是使用$.proxy后this还是test\n};\n\ntest.prototype.myClick = function(event) {\n  alert(this.txt);\n  alert(event.currentTarget.nodeName);\n};\n\nvar x = new test();\n```\n","slug":"17-07-08-18","published":1,"updated":"2017-08-16T13:10:59.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodq000et0cg4ujqatf4","content":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></div><div class=\"line\">&#125;</div><div class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">  &#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class=\"line\">    $(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"男\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"18\"</span>,</div><div class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小红\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"女\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</div><div class=\"line\">  $(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</div><div class=\"line\">  <span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.txt);</div><div class=\"line\">  alert(event.currentTarget.nodeName);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><blockquote>\n<p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>\n</blockquote>","more":"<ul>\n<li><p><strong>定义在全局中的函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>; <span class=\"comment\">//此处的this指的是window</span></div><div class=\"line\">&#125;</div><div class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">//在全局修改这个x，函数中这个this.x也是会一起改变的</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为对象方法的调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作为构造函数调用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">  &#125; <span class=\"comment\">//这是定义在对象中的函数，而此时this指的是对象o</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"this指向的改变\"><a href=\"#this指向的改变\" class=\"headerlink\" title=\"this指向的改变\"></a>this指向的改变</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在构造函数的时候也会调用其他的函数，所以this的指向就会变</span></div><div class=\"line\">    $(<span class=\"keyword\">this</span>.xx).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"comment\">//比如调用了on绑定事件的函数，那么这个函数里的this就不是对象o了</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在javascript中有几个函数是可以改变this的指向的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"男\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"18\"</span>,</div><div class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"keyword\">this</span>.name + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.sex + <span class=\"string\">\",\"</span> + <span class=\"keyword\">this</span>.age);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"小红\"</span>,</div><div class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">\"女\"</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>apply(thisObj,[argArray])</code><br>参数：替换目标对象（如果为空，则指的是window对象），数组（存放所需要的参数）<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.apply(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>call(thisObj,arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.call(xh); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind(thisObj)(arg1,arg2...)</code><br>参数：替换目标对象，需要的参数arg1,arg2…<br>定义：创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>说明：bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xm.say.bind(xh)(); <span class=\"comment\">//小红,女,20</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>$.proxy(fn,context)</code><br>参数：函数，函数所在的对象的名称<br>定义：用于向上下文指向不同对象的元素添加事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.txt = <span class=\"string\">\"这是一个对象属性\"</span>;</div><div class=\"line\">  $(<span class=\"string\">\"div\"</span>).click($.proxy(<span class=\"keyword\">this</span>.myClick,<span class=\"keyword\">this</span>));</div><div class=\"line\">  <span class=\"comment\">//本来调用click的话，this会指向div，但是使用$.proxy后this还是test</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.prototype.myClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.txt);</div><div class=\"line\">  alert(event.currentTarget.nodeName);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> test();</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"搭建Hexo博客之后","date":"2017-07-15T06:59:11.000Z","_content":"\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!--more-->\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n#### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n#### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n#### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n#### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n#### 更换电脑后的操作\n\n* 使用`git clone`将远程仓库克隆到本地\n* 在本地的仓库执行`npm install hexo`、`npm install`、`npm install hexo-git-backup --save`，就完成了更换电脑更新的操作啦（记得，不需要`hexo init`这条指令）。\n\n","source":"_posts/17-07-15-19.md","raw":"---\ntitle: 搭建Hexo博客之后\ndate: 2017-07-15 14:59:11\n---\n\n这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？\n然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。\n恩，然后找到了方法，然而感觉讲的太！不！清！楚！\n折腾了半天，终于弄好了，以下整理了一下步骤：\n\n<!--more-->\n\n## 使用分支方法解决hexo博客无法在两台电脑上更新的问题\n\n#### 创建本地仓库\n\n首先，创建一个新的文件夹，和github上的仓库同名：`username.github.io`\n然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令\n```git\n$ touch README.md\n$ git init \n$ git add README.md\n$ git commit -m \"first commit\"\n$ git remote add origin 你的项目地址\n$ git push -u origin master\n```\n在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决\n```git\n$ git pull --rebase origin master\n$ git push -u origin master\n```\n这样就可以将本地仓库里的文件更新到github仓库啦~\\(≧▽≦)/~\n\n#### 创建hexo分支\n\n```git\n$ git branch hexo\n$ git push origin hexo\n```\n这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~\n\n#### 在hexo分支中安装hexo\n\n```git\n$ git checkout hexo\n$ npm install hexo\n$ hexo init\n$ npm install\n```\n这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上\n原文中提供的安装方法好像不管用，重新找了个名字叫[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n安装指令：\n```git\n$ npm install hexo-git-backup --save\n```\n\n#### 配置_config.yml文件\n\n打开_config.yml文件，拉到最下，我们需要改动一些东西\n```yml\ndeploy:\n\ttype: git #部署类型，使用github\n\trepository: #你的项目地址\n\tbranch: master #部署分支，必须是master\n\tmessage: update #默认类型\n\n#我们还需要添加那个插件的功能\nbackup:\n\ttype: git\n\trepository:\n\t\tgithub: 项目地址,hexo #将这个本地仓库更新到hexo分支\n```\n然后我们在执行一下指令\n```git\n$ hexo g \n$ hexo d //部署博客\n$ hexo b //将hexo文件中的更改提交到hexo分支\n```\n然后，事情就完美的解决啦~~\n\n#### 更换电脑后的操作\n\n* 使用`git clone`将远程仓库克隆到本地\n* 在本地的仓库执行`npm install hexo`、`npm install`、`npm install hexo-git-backup --save`，就完成了更换电脑更新的操作啦（记得，不需要`hexo init`这条指令）。\n\n","slug":"17-07-15-19","published":1,"updated":"2017-08-16T12:26:39.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodr000ft0cgimi37wc1","content":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>\n<a id=\"more\"></a>\n<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch README.md</div><div class=\"line\">$ git init </div><div class=\"line\">$ git add README.md</div><div class=\"line\">$ git commit -m &quot;first commit&quot;</div><div class=\"line\">$ git remote add origin 你的项目地址</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull --rebase origin master</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h4 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch hexo</div><div class=\"line\">$ git push origin hexo</div></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h4 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div><div class=\"line\">$ npm install hexo</div><div class=\"line\">$ hexo init</div><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h4><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></div><div class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></div><div class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></div><div class=\"line\"><span class=\"attr\">backup:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span></div><div class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g </div><div class=\"line\">$ hexo d //部署博客</div><div class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h4 id=\"更换电脑后的操作\"><a href=\"#更换电脑后的操作\" class=\"headerlink\" title=\"更换电脑后的操作\"></a>更换电脑后的操作</h4><ul>\n<li>使用<code>git clone</code>将远程仓库克隆到本地</li>\n<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这几天在公司实习，用着公司的电脑，划水的时候想着更新一下博客，然后问题来了：博客的相关文件都在自家电脑没拷来，莫不是要重新搭一个环境？？那我部署之后岂不是之前的都被覆盖了？？？<br>然后突然觉得这丫的好像换电脑更新有点小问题呀就开始百度解决。<br>恩，然后找到了方法，然而感觉讲的太！不！清！楚！<br>折腾了半天，终于弄好了，以下整理了一下步骤：</p>","more":"<h2 id=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"><a href=\"#使用分支方法解决hexo博客无法在两台电脑上更新的问题\" class=\"headerlink\" title=\"使用分支方法解决hexo博客无法在两台电脑上更新的问题\"></a>使用分支方法解决hexo博客无法在两台电脑上更新的问题</h2><h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><p>首先，创建一个新的文件夹，和github上的仓库同名：<code>username.github.io</code><br>然后开始创建本地仓库，以下是创建一个新的本地仓库的git指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch README.md</div><div class=\"line\">$ git init </div><div class=\"line\">$ git add README.md</div><div class=\"line\">$ git commit -m &quot;first commit&quot;</div><div class=\"line\">$ git remote add origin 你的项目地址</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>在执行push指令的时候可能会报错，让你先pull，这里可以执行以下命令解决<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull --rebase origin master</div><div class=\"line\">$ git push -u origin master</div></pre></td></tr></table></figure></p>\n<p>这样就可以将本地仓库里的文件更新到github仓库啦~(≧▽≦)/~</p>\n<h4 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch hexo</div><div class=\"line\">$ git push origin hexo</div></pre></td></tr></table></figure>\n<p>这样这个博客仓库中就多了一条分支，我们就准备将hexo一些必要文件传在这个分支中，这样换电脑的时候就可以直接克隆这个项目的文件，麻麻再也不用担心我换电脑或者把博客数据搞丢了~~</p>\n<h4 id=\"在hexo分支中安装hexo\"><a href=\"#在hexo分支中安装hexo\" class=\"headerlink\" title=\"在hexo分支中安装hexo\"></a>在hexo分支中安装hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div><div class=\"line\">$ npm install hexo</div><div class=\"line\">$ hexo init</div><div class=\"line\">$ npm install</div></pre></td></tr></table></figure>\n<p>这样我们就在hexo分支中安装好了hexo，然后你就会发现这个文件夹不是本地仓库了（不懂为什么hexo有这种设定），于是我们需要安装一个插件让hexo支持可以上传到github上<br>原文中提供的安装方法好像不管用，重新找了个名字叫<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a><br>安装指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-git-backup --save</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h4><p>打开_config.yml文件，拉到最下，我们需要改动一些东西<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span> <span class=\"comment\">#部署类型，使用github</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span> <span class=\"comment\">#你的项目地址</span></div><div class=\"line\">\t<span class=\"attr\">branch:</span> <span class=\"string\">master</span> <span class=\"comment\">#部署分支，必须是master</span></div><div class=\"line\">\t<span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"comment\">#默认类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#我们还需要添加那个插件的功能</span></div><div class=\"line\"><span class=\"attr\">backup:</span></div><div class=\"line\">\t<span class=\"attr\">type:</span> <span class=\"string\">git</span></div><div class=\"line\">\t<span class=\"attr\">repository:</span></div><div class=\"line\">\t\t<span class=\"attr\">github:</span> <span class=\"string\">项目地址,hexo</span> <span class=\"comment\">#将这个本地仓库更新到hexo分支</span></div></pre></td></tr></table></figure></p>\n<p>然后我们在执行一下指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g </div><div class=\"line\">$ hexo d //部署博客</div><div class=\"line\">$ hexo b //将hexo文件中的更改提交到hexo分支</div></pre></td></tr></table></figure></p>\n<p>然后，事情就完美的解决啦~~</p>\n<h4 id=\"更换电脑后的操作\"><a href=\"#更换电脑后的操作\" class=\"headerlink\" title=\"更换电脑后的操作\"></a>更换电脑后的操作</h4><ul>\n<li>使用<code>git clone</code>将远程仓库克隆到本地</li>\n<li>在本地的仓库执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-git-backup --save</code>，就完成了更换电脑更新的操作啦（记得，不需要<code>hexo init</code>这条指令）。</li>\n</ul>"},{"title":"异步编程之promise与trigger","date":"2017-07-15T08:13:01.000Z","_content":"这周的学习任务：`promise`与`trigger`\n<!--more-->\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\n\n#### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n#### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n#### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","source":"_posts/17-07-15-20.md","raw":"---\ntitle: 异步编程之promise与trigger\ndate: 2017-07-15 16:13:01\n---\n这周的学习任务：`promise`与`trigger`\n<!--more-->\n\n## 异步编程\n\n> Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\n\n#### 实现异步编程的四种方法\n\n* **回调函数**\n\n回调函数可以理解为，被另一个函数调用的函数。\n可以想成这样一个应用场景：\n```javascript\nf1(); //一个十分耗时的函数\nf2(); //等待f1执行完才能执行的函数\nf3(); //等待f1执行完才能执行的函数\n```\nJavascript语言的执行环境是\"单线程\"，就是指一次只能完成一件任务。所以上面函数的执行顺序会是`f1->f2->f3`，但如果`f3`是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待`f1`与`f2`都执行完才能执行，这就导致了页面加载时间过长，体验很不好。\n```javascript\nfunction f1(callback) {\n  //f1执行代码\n  callback();\n}\n\nf1(f2);\nf3();\n```\n如果采用回调函数的方法（异步），函数的执行顺序就可以变成`f1->f3->f2`，加载时间就节省了`f2`执行的时间，也算是一点优化了。\n**优点：** 简单、容易理解和部署。\n**缺点：** 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n\n* **事件监听**\n\n事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如`click`、`keydown`之类的，可以通过`on`来绑定。\n```javascript\nf1.on('click',f2); //在发送点击事件之后，会执行f2函数\n```\n而`trigger`的作用是，可以通过`$.Event('eventName')`来自定义一个事件，然后通过`trigger`触发这个事件。\n```javascript\nvar $null = $({}); //绑定空对象\nvar hideEvent = $.Event('hide.tab');\n\nfunction f1() {\n  //f1执行代码\n  f1.trigger('hide.tab');\n}\n\n$null.on('hide.tab',f2);\n```\n当`f1`执行完后就会触发`hide.tab`事件，从而开始执行`f2`。\n而且这个自定义的事件可以通过`trigger`绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用`trigger`来触发事件，然后通过事件绑定调用子函数的方法。\n**优点：** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合\"，有利于实现模块化。\n**缺点：** 整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n* **发布/订阅**\n\n发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式\"，又称“观察者模式”。\n实现步骤如下：\n```javascript\njQuery.subscribe('done',f2); //通过订阅中心jQuery订阅\"done\"信号\n\nfunction f1() {\n  //f1执行代码\n  jQuery.public('done'); //f1执行完后，向信号中心发布\"done\"信号，引发f2执行\n}\n\njQuery.unsubscribe('done',f2); //取消订阅\n```\n**优点：** 可以通过查看\"消息中心\"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n* **deferred对象**\n\ndeferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。\n```javascript\nf1().then(f2);\n\nfunction f1(){\n  var dfd = $.Deferred();\n　// f1的任务代码\n　dfd.resolve();\n　return dfd.promise;\n}\n```\n**优点：** 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。\n\n## deferred对象详解\n\n#### deferred对象的应用场景\n\n* **让异步操作代码像同步代码那样书写和阅读，流程更加清晰**\n* **优化ajax的嵌套执行**\n\n原本我们在执行`ajax`的时候，如果这个请求中还有`ajax`请求，就会有以下这种写法：\n```javascript\n$.ajax({\n  url: \"test.html\",\n  success: function() {\n    $.ajax({\n      url: ...,\n      success: function() {\n        ....\n      }\n    });\n  }\n});\n```\n我们可以将两个`ajax`分开封装\n```javascript\nfunction A() {\n  return $.ajax({\n    url: \"test.html\",\n    ...\n  });\n}\n\nfunction B() {\n  return $.ajax({\n    url: \"...\",\n    ...\n  });\n}\n\n$.when(A(),B()).then(function() {\n  dosth();\n});\n```\n\n#### 方法总结\n\n* `$.Deferred()`：生成一个deferred对象\n* `deferred.done()`：指定操作成功时的回调函数\n* `deferred.fail()`：指定操作失败时的回调函数\n* `deferred.promise()`：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。\n* `deferred.resolve()`：手动改变deferred对象的运行状态为“已完成”，从而立即触发`done()`方法\n* `deferred.reject()`：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法\n* `$.when()`：为多个操作指定回调函数。当所有操作都成功时执行`done()`\n* `deferred.then()`：有时为了省事，可以把`done()`和`fail()`合在一起写，这就是`then()`方法\n","slug":"17-07-15-20","published":1,"updated":"2017-08-16T12:29:01.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodt000gt0cgzy4f22iz","content":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code><br><a id=\"more\"></a></p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h4 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h4><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></div><div class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div><div class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  callback();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1(f2);</div><div class=\"line\">f3();</div></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1().then(f2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</div><div class=\"line\">　<span class=\"comment\">// f1的任务代码</span></div><div class=\"line\">　dfd.resolve();</div><div class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h4 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h4><ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">      <span class=\"attr\">url</span>: ...,</div><div class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        ....</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"...\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  dosth();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h4><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这周的学习任务：<code>promise</code>与<code>trigger</code><br>","more":"</p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>Javascript语言将任务的执行模式分为同步（Synchronous）和异步（Asynchronous），“同步模式”指的是后一个任务只有等待前一个任务完成之后才能执行，程序执行顺序与任务的排列顺序是一致的、同步的。而“异步模式”指的是每个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</blockquote>\n<h4 id=\"实现异步编程的四种方法\"><a href=\"#实现异步编程的四种方法\" class=\"headerlink\" title=\"实现异步编程的四种方法\"></a>实现异步编程的四种方法</h4><ul>\n<li><strong>回调函数</strong></li>\n</ul>\n<p>回调函数可以理解为，被另一个函数调用的函数。<br>可以想成这样一个应用场景：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1(); <span class=\"comment\">//一个十分耗时的函数</span></div><div class=\"line\">f2(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div><div class=\"line\">f3(); <span class=\"comment\">//等待f1执行完才能执行的函数</span></div></pre></td></tr></table></figure></p>\n<p>Javascript语言的执行环境是”单线程”，就是指一次只能完成一件任务。所以上面函数的执行顺序会是<code>f1-&gt;f2-&gt;f3</code>，但如果<code>f3</code>是一个与页面加载有关的函数，那就比较蛋疼了，因为它必须等待<code>f1</code>与<code>f2</code>都执行完才能执行，这就导致了页面加载时间过长，体验很不好。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  callback();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1(f2);</div><div class=\"line\">f3();</div></pre></td></tr></table></figure></p>\n<p>如果采用回调函数的方法（异步），函数的执行顺序就可以变成<code>f1-&gt;f3-&gt;f2</code>，加载时间就节省了<code>f2</code>执行的时间，也算是一点优化了。<br><strong>优点：</strong> 简单、容易理解和部署。<br><strong>缺点：</strong> 不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>\n<ul>\n<li><strong>事件监听</strong></li>\n</ul>\n<p>事件监听指的是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。jQuery中有许多事件，例如<code>click</code>、<code>keydown</code>之类的，可以通过<code>on</code>来绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1.on(<span class=\"string\">'click'</span>,f2); <span class=\"comment\">//在发送点击事件之后，会执行f2函数</span></div></pre></td></tr></table></figure></p>\n<p>而<code>trigger</code>的作用是，可以通过<code>$.Event(&#39;eventName&#39;)</code>来自定义一个事件，然后通过<code>trigger</code>触发这个事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $<span class=\"literal\">null</span> = $(&#123;&#125;); <span class=\"comment\">//绑定空对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> hideEvent = $.Event(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  f1.trigger(<span class=\"string\">'hide.tab'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$<span class=\"literal\">null</span>.on(<span class=\"string\">'hide.tab'</span>,f2);</div></pre></td></tr></table></figure></p>\n<p>当<code>f1</code>执行完后就会触发<code>hide.tab</code>事件，从而开始执行<code>f2</code>。<br>而且这个自定义的事件可以通过<code>trigger</code>绑定在多个函数之中，也就是说，可以通过多个操作来触发同一个事件。也可以实现两个不同模块的相互通信，比如一个子函数可以调用父函数的方法，那么父函数如果要调用子函数的方法要怎么办呢？这个时候就可以利用<code>trigger</code>来触发事件，然后通过事件绑定调用子函数的方法。<br><strong>优点：</strong> 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<br><strong>缺点：</strong> 整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>\n<ul>\n<li><strong>发布/订阅</strong></li>\n</ul>\n<p>发布/订阅可以理解为存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。<br>实现步骤如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//通过订阅中心jQuery订阅\"done\"信号</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//f1执行代码</span></div><div class=\"line\">  jQuery.public(<span class=\"string\">'done'</span>); <span class=\"comment\">//f1执行完后，向信号中心发布\"done\"信号，引发f2执行</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>,f2); <span class=\"comment\">//取消订阅</span></div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<ul>\n<li><strong>deferred对象</strong></li>\n</ul>\n<p>deferred对象就是jQuery的回调函数解决方案，可以通过链式写法执行回调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">f1().then(f2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dfd = $.Deferred();</div><div class=\"line\">　<span class=\"comment\">// f1的任务代码</span></div><div class=\"line\">　dfd.resolve();</div><div class=\"line\">　<span class=\"keyword\">return</span> dfd.promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>优点：</strong> 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。</p>\n<h2 id=\"deferred对象详解\"><a href=\"#deferred对象详解\" class=\"headerlink\" title=\"deferred对象详解\"></a>deferred对象详解</h2><h4 id=\"deferred对象的应用场景\"><a href=\"#deferred对象的应用场景\" class=\"headerlink\" title=\"deferred对象的应用场景\"></a>deferred对象的应用场景</h4><ul>\n<li><strong>让异步操作代码像同步代码那样书写和阅读，流程更加清晰</strong></li>\n<li><strong>优化ajax的嵌套执行</strong></li>\n</ul>\n<p>原本我们在执行<code>ajax</code>的时候，如果这个请求中还有<code>ajax</code>请求，就会有以下这种写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">      <span class=\"attr\">url</span>: ...,</div><div class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        ....</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们可以将两个<code>ajax</code>分开封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"test.html\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> $.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">\"...\"</span>,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$.when(A(),B()).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  dosth();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"方法总结\"><a href=\"#方法总结\" class=\"headerlink\" title=\"方法总结\"></a>方法总结</h4><ul>\n<li><code>$.Deferred()</code>：生成一个deferred对象</li>\n<li><code>deferred.done()</code>：指定操作成功时的回调函数</li>\n<li><code>deferred.fail()</code>：指定操作失败时的回调函数</li>\n<li><code>deferred.promise()</code>：没有参数时，返回一个新的deferred对象，该对象的运行状态无法改变；接受参数时，作用为在参数对象上部署deferred接口。</li>\n<li><code>deferred.resolve()</code>：手动改变deferred对象的运行状态为“已完成”，从而立即触发<code>done()</code>方法</li>\n<li><code>deferred.reject()</code>：与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法</li>\n<li><code>$.when()</code>：为多个操作指定回调函数。当所有操作都成功时执行<code>done()</code></li>\n<li><code>deferred.then()</code>：有时为了省事，可以把<code>done()</code>和<code>fail()</code>合在一起写，这就是<code>then()</code>方法</li>\n</ul>"},{"title":"JS变量、作用域和内存问题","date":"2017-08-15T12:30:52.000Z","_content":"## 变量\n\n#### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n<!--more-->\n\n```JavaScript\n//eg1\nvar num = 4;\nnum = 3; //这里的值操作并不是修改，而是覆盖\n\n//eg2\nvar str = 'string';\nvar anotherStr = str.replace('s',''); \n//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr\n\n```\n基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是`Number`，字符的包装对象是`String`。包装对象包含了这个类型的属性和方法。\n\n#### 堆栈\n\n在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。\n\n因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-1.png)\n\n#### 变量的比较\n\n```javascript\n//基本类型的比较\nvar xmScore = 4;\nvar xhScore =4;\nconsole.log(xmScore === xhScore) //true\n\n//引用类型的比较\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = {\n  age: 18,\n  score: 4\n};\nconsole.log(xm === xh); //false\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-2.png)\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-3.png)\n在引用类型中，只有指向同一个引用，变量才是相等的。\n\n\n```javascript\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用\nconsole.log(xm === xh); //true;\n```\n那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。\n```javascript\nfunction equalObjs(a,b) {\n  for(var p in a) {\n    if(a[p] !== b[p] return false;\n  }\n  return true;\n}\n\nfunction equalArrays(a,b) {\n  if(a.length !== b.length) return false;\n  for(var i = 0; i < a.length; i ++) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n```\n\n#### 变量的复制\n\n当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。\n```javascript\nfunction copyObj(obj) {\n  var newObj = {};\n  for(var p in obj) {\n   newObj[p] = obj[p];\n  }\n  return newObj;\n}\n```\n以上的方法便是**浅拷贝**，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。\n* `$.extend(deep,target,object1,objectN)`\n参数说明：\n`deep`：可选。布尔值。指是否深度合并对象，默认`false`。\n`target`：目标对象，其他对象的成员属性将被附加到该对象上。\n`object1`：可选。指第一个被合并的对象。\n`objectN`：可选。指第N个被合并的对象。\n\n#### 参数传递\n\n```javascript\nfunction fn(a,b) {\n  return a + b;\n} // 在函数里声明的a与b是形参\nfn(1,2); //在调用函数时传入的参数是实参\n```\n当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。\n```javascript\n//eg1 当变量为基本类型时\nfunction addTen(num) {\n  return num + 10;\n}\nvar score = 10;\naddTen(score);\n//相当于\nnum = score;\n\n//eg2 当变量为引用类型时\nfunction setName(obj) {\n  return obj.name = 'xm';\n}\nvar person = {};\nsetName(person);\n```\n当传递的参数是引用类型时，也相当于`obj = person`，因为引用类型赋值时是对地址进行复制的，所以`obj`与`person`实际上指向的都是同一个引用，所以我们对`obj`的修改也能反应到`person`上。\n\n#### 类型检测\n\n`typeof`：返回字符串类型。可以区分基本类型，但是无法区分引用类型（`null`，对象和数组返回的都是`object`）。\n`instanceof`：用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法`[] instanceof Array`。\n\n## 作用域\n\n> 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量\n\n#### 全局与局部\n\n在JS中，变量的作用域分为两种：全局变量和局部变量\n全局变量的声明方式有两种：\n```javascript\nvar n = 999; //直接在外部声明\nfunction f1() {\n  i = 888; //在函数内部声明，但是不适用var命令\n}\n```\n全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。\n在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用`{}`包含的域。在其他语言，例如C++，`if`和`for`中声明的变量在外部也是无法访问到的。但是JS中，在`if`和`for`中声明的变量在整个函数内部都可以访问。\n```\nfor(var i = 0; i < 10; i ++) { }\n//等同于\nvar i = 0;\nfor(i < 10; i ++) { }\n```\n\n#### 变量的作用域链\n\n```javascript\nvar name = 'xm';\nfunuction fn(argument) {\n  var name = 'xh';\n  var sex = 'male';\n  function fn2(argument) {\n    var name = 'xhei';\n    var age = 18;\n  }\n}\n```\n\n所有全局空间中的属性和方法，都是属于window的（`window.name = 'xm';`）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（`fn.sex`与`fn.fn2`不存在）。\n作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。\n**作用链：** 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png)\n\n* **延长作用域链**\n\n```javascript\nvar person = {};\nperson.name = 'xm';\nperson.sex = 'male';\nvar score = 4;\n\nwith(person) {\n  name = 'xh';\n  sex = 'female';\n  score = 44;\n}\n\nconsole.log(person.name); //xh\nconsole.log(person.sex); //female\nconsole.log(score); //44\n```\n使用`with`的时候，当修改`name`与`sex`时，此时查找的作用域是`person`，但是`person`中并不存在`score`这个属性，于是with就随着作用域链查找到`window`下的`score`，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。\n\n* **闭包**\n\n在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //999\n  }\n  return f2; //将f2作为返回值\n}\n\nvar result = f1();\nresult(); //999\n```\n以上代码中的f2函数就是闭包，也就是闭包可以理解为**\"定义在一个函数内部的函数\"**。\n* **闭包的两个用途**：\n  * 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。\n  * 将某些变量的值始终保持在内存中。（JS的垃圾回收机制）\n\n#### JS解析机制-预解析\n\nJS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。\n```javascript\nvar name = 'xm';\nvar age = 18;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\nfn(); //undefined\n```\n就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的`var`找出来，并且将所有的变量都赋值为`undefined`。然后查找该域中的`function`，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是`undefined`。\n```\n//window域预解析\nvar name = undefiied;\nvar age = undefined;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\n\n//fn域预解析\nvar name = undefined;\nvar age = undefined;\n\n//逐行解析\nname = 'xm';\nage = 18;\nfn(argument) {\n  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined\n  name = 'xh';\n  age = 10;\n}\n```\n在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。\n```javascript\nconsole.log(a);\na = 1; //预解析不解析没有var的变量，所以浏览器会报错\n```\n\n## 内存\n\n#### 垃圾回收机制\n**垃圾回收机制：**释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。\n**标识无用数据的策略：**\n  * **标记清除：**垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。**环境中的变量**指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。\n  * **引用计数：**引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。\n  * **循环引用问题：**\n  \n```javascript\nfunction fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n}\nfun();\nxm = null; //0\nxh = null; //0\n\nfunctioni fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n  xm.wife = xh; //2\n  xh.husband = xm; //2\n}\nfn();\nxm = null; //1\nxh = null; //1\n```\n由于`xm`与`xh`相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。\n\n#### 管理内存\n\n为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为`null`。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","source":"_posts/17-08-15-21.md","raw":"---\ntitle: JS变量、作用域和内存问题\ndate: 2017-08-15 20:30:52\ntags:\n---\n## 变量\n\n#### 数据类型\n\n在JavaScript中，数据类型分为基本类型和引用类型。\n* **基本类型：**数字，字符，布尔值，undefined，null\n* **引用类型：**数组，对象，函数\n* **区别：**基本类型的值是可以修改的，而引用类型的值不可修改\n<!--more-->\n\n```JavaScript\n//eg1\nvar num = 4;\nnum = 3; //这里的值操作并不是修改，而是覆盖\n\n//eg2\nvar str = 'string';\nvar anotherStr = str.replace('s',''); \n//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr\n\n```\n基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是`Number`，字符的包装对象是`String`。包装对象包含了这个类型的属性和方法。\n\n#### 堆栈\n\n在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。\n\n因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-1.png)\n\n#### 变量的比较\n\n```javascript\n//基本类型的比较\nvar xmScore = 4;\nvar xhScore =4;\nconsole.log(xmScore === xhScore) //true\n\n//引用类型的比较\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = {\n  age: 18,\n  score: 4\n};\nconsole.log(xm === xh); //false\n```\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-2.png)\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&heap-3.png)\n在引用类型中，只有指向同一个引用，变量才是相等的。\n\n\n```javascript\nvar xm = {\n  age: 18,\n  score: 4\n};\nvar xh = xm; //xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用\nconsole.log(xm === xh); //true;\n```\n那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。\n```javascript\nfunction equalObjs(a,b) {\n  for(var p in a) {\n    if(a[p] !== b[p] return false;\n  }\n  return true;\n}\n\nfunction equalArrays(a,b) {\n  if(a.length !== b.length) return false;\n  for(var i = 0; i < a.length; i ++) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n```\n\n#### 变量的复制\n\n当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。\n```javascript\nfunction copyObj(obj) {\n  var newObj = {};\n  for(var p in obj) {\n   newObj[p] = obj[p];\n  }\n  return newObj;\n}\n```\n以上的方法便是**浅拷贝**，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。\n* `$.extend(deep,target,object1,objectN)`\n参数说明：\n`deep`：可选。布尔值。指是否深度合并对象，默认`false`。\n`target`：目标对象，其他对象的成员属性将被附加到该对象上。\n`object1`：可选。指第一个被合并的对象。\n`objectN`：可选。指第N个被合并的对象。\n\n#### 参数传递\n\n```javascript\nfunction fn(a,b) {\n  return a + b;\n} // 在函数里声明的a与b是形参\nfn(1,2); //在调用函数时传入的参数是实参\n```\n当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。\n```javascript\n//eg1 当变量为基本类型时\nfunction addTen(num) {\n  return num + 10;\n}\nvar score = 10;\naddTen(score);\n//相当于\nnum = score;\n\n//eg2 当变量为引用类型时\nfunction setName(obj) {\n  return obj.name = 'xm';\n}\nvar person = {};\nsetName(person);\n```\n当传递的参数是引用类型时，也相当于`obj = person`，因为引用类型赋值时是对地址进行复制的，所以`obj`与`person`实际上指向的都是同一个引用，所以我们对`obj`的修改也能反应到`person`上。\n\n#### 类型检测\n\n`typeof`：返回字符串类型。可以区分基本类型，但是无法区分引用类型（`null`，对象和数组返回的都是`object`）。\n`instanceof`：用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法`[] instanceof Array`。\n\n## 作用域\n\n> 变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量\n\n#### 全局与局部\n\n在JS中，变量的作用域分为两种：全局变量和局部变量\n全局变量的声明方式有两种：\n```javascript\nvar n = 999; //直接在外部声明\nfunction f1() {\n  i = 888; //在函数内部声明，但是不适用var命令\n}\n```\n全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。\n在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用`{}`包含的域。在其他语言，例如C++，`if`和`for`中声明的变量在外部也是无法访问到的。但是JS中，在`if`和`for`中声明的变量在整个函数内部都可以访问。\n```\nfor(var i = 0; i < 10; i ++) { }\n//等同于\nvar i = 0;\nfor(i < 10; i ++) { }\n```\n\n#### 变量的作用域链\n\n```javascript\nvar name = 'xm';\nfunuction fn(argument) {\n  var name = 'xh';\n  var sex = 'male';\n  function fn2(argument) {\n    var name = 'xhei';\n    var age = 18;\n  }\n}\n```\n\n所有全局空间中的属性和方法，都是属于window的（`window.name = 'xm';`）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（`fn.sex`与`fn.fn2`不存在）。\n作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。\n**作用链：** 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png)\n\n* **延长作用域链**\n\n```javascript\nvar person = {};\nperson.name = 'xm';\nperson.sex = 'male';\nvar score = 4;\n\nwith(person) {\n  name = 'xh';\n  sex = 'female';\n  score = 44;\n}\n\nconsole.log(person.name); //xh\nconsole.log(person.sex); //female\nconsole.log(score); //44\n```\n使用`with`的时候，当修改`name`与`sex`时，此时查找的作用域是`person`，但是`person`中并不存在`score`这个属性，于是with就随着作用域链查找到`window`下的`score`，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。\n\n* **闭包**\n\n在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //999\n  }\n  return f2; //将f2作为返回值\n}\n\nvar result = f1();\nresult(); //999\n```\n以上代码中的f2函数就是闭包，也就是闭包可以理解为**\"定义在一个函数内部的函数\"**。\n* **闭包的两个用途**：\n  * 读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。\n  * 将某些变量的值始终保持在内存中。（JS的垃圾回收机制）\n\n#### JS解析机制-预解析\n\nJS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。\n```javascript\nvar name = 'xm';\nvar age = 18;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\nfn(); //undefined\n```\n就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的`var`找出来，并且将所有的变量都赋值为`undefined`。然后查找该域中的`function`，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是`undefined`。\n```\n//window域预解析\nvar name = undefiied;\nvar age = undefined;\nfunction fn(argument) {\n  console.log(name);\n  var name = 'xh';\n  var age = 10;\n}\n\n//fn域预解析\nvar name = undefined;\nvar age = undefined;\n\n//逐行解析\nname = 'xm';\nage = 18;\nfn(argument) {\n  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined\n  name = 'xh';\n  age = 10;\n}\n```\n在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。\n```javascript\nconsole.log(a);\na = 1; //预解析不解析没有var的变量，所以浏览器会报错\n```\n\n## 内存\n\n#### 垃圾回收机制\n**垃圾回收机制：**释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。\n**标识无用数据的策略：**\n  * **标记清除：**垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。**环境中的变量**指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。\n  * **引用计数：**引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。\n  * **循环引用问题：**\n  \n```javascript\nfunction fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n}\nfun();\nxm = null; //0\nxh = null; //0\n\nfunctioni fn(argument) {\n  var xm = {}; //1\n  var xh = {}; //1\n  xm.wife = xh; //2\n  xh.husband = xm; //2\n}\nfn();\nxm = null; //1\nxh = null; //1\n```\n由于`xm`与`xh`相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。\n\n#### 管理内存\n\n为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为`null`。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。","slug":"17-08-15-21","published":1,"updated":"2017-08-16T13:01:54.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecodu000ht0cg6yv71sjz","content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改<a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1</span></div><div class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">4</span>;</div><div class=\"line\">num = <span class=\"number\">3</span>; <span class=\"comment\">//这里的值操作并不是修改，而是覆盖</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'string'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.replace(<span class=\"string\">'s'</span>,<span class=\"string\">''</span>); </div><div class=\"line\"><span class=\"comment\">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></div></pre></td></tr></table></figure>\n<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>\n<h4 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h4><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>\n<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png\" alt=\"\"></p>\n<h4 id=\"变量的比较\"><a href=\"#变量的比较\" class=\"headerlink\" title=\"变量的比较\"></a>变量的比较</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//基本类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xmScore = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> xhScore =<span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xmScore === xhScore) <span class=\"comment\">//true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//引用类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//false</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png\" alt=\"\"><br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png\" alt=\"\"><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = xm; <span class=\"comment\">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//true;</span></div></pre></td></tr></table></figure>\n<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalObjs</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> a) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[p] !== b[p] <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalArrays</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(a.length !== b.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[i] !== b[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的复制\"><a href=\"#变量的复制\" class=\"headerlink\" title=\"变量的复制\"></a>变量的复制</h4><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObj</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">   newObj[p] = obj[p];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> newObj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>\n<ul>\n<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>\n</ul>\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125; <span class=\"comment\">// 在函数里声明的a与b是形参</span></div><div class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//在调用函数时传入的参数是实参</span></div></pre></td></tr></table></figure>\n<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1 当变量为基本类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTen</span>(<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">10</span>;</div><div class=\"line\">addTen(score);</div><div class=\"line\"><span class=\"comment\">//相当于</span></div><div class=\"line\">num = score;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2 当变量为引用类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">setName(person);</div></pre></td></tr></table></figure></p>\n<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>\n<h4 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h4><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>\n</blockquote>\n<h4 id=\"全局与局部\"><a href=\"#全局与局部\" class=\"headerlink\" title=\"全局与局部\"></a>全局与局部</h4><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">999</span>; <span class=\"comment\">//直接在外部声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  i = <span class=\"number\">888</span>; <span class=\"comment\">//在函数内部声明，但是不适用var命令</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</div><div class=\"line\">//等同于</div><div class=\"line\">var i = 0;</div><div class=\"line\">for(i &lt; 10; i ++) &#123; &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的作用域链\"><a href=\"#变量的作用域链\" class=\"headerlink\" title=\"变量的作用域链\"></a>变量的作用域链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">funuction fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> sex = <span class=\"string\">'male'</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'xhei'</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png\" alt=\"\"></p>\n<ul>\n<li><strong>延长作用域链</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.sex = <span class=\"string\">'male'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">4</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span>(person) &#123;</div><div class=\"line\">  name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  sex = <span class=\"string\">'female'</span>;</div><div class=\"line\">  score = <span class=\"number\">44</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">//xh</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//female</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(score); <span class=\"comment\">//44</span></div></pre></td></tr></table></figure>\n<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>\n<ul>\n<li><strong>闭包</strong></li>\n</ul>\n<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(n); <span class=\"comment\">//999</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> f2; <span class=\"comment\">//将f2作为返回值</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result = f1();</div><div class=\"line\">result(); <span class=\"comment\">//999</span></div></pre></td></tr></table></figure></p>\n<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>\n<ul>\n<li><strong>闭包的两个用途</strong>：<ul>\n<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>\n<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JS解析机制-预解析\"><a href=\"#JS解析机制-预解析\" class=\"headerlink\" title=\"JS解析机制-预解析\"></a>JS解析机制-预解析</h4><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fn(); <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure></p>\n<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//window域预解析</div><div class=\"line\">var name = undefiied;</div><div class=\"line\">var age = undefined;</div><div class=\"line\">function fn(argument) &#123;</div><div class=\"line\">  console.log(name);</div><div class=\"line\">  var name = &apos;xh&apos;;</div><div class=\"line\">  var age = 10;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//fn域预解析</div><div class=\"line\">var name = undefined;</div><div class=\"line\">var age = undefined;</div><div class=\"line\"></div><div class=\"line\">//逐行解析</div><div class=\"line\">name = &apos;xm&apos;;</div><div class=\"line\">age = 18;</div><div class=\"line\">fn(argument) &#123;</div><div class=\"line\">  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</div><div class=\"line\">  name = &apos;xh&apos;;</div><div class=\"line\">  age = 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">a = <span class=\"number\">1</span>; <span class=\"comment\">//预解析不解析没有var的变量，所以浏览器会报错</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><h4 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h4><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>\n<ul>\n<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>\n<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>\n<li><strong>循环引用问题：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">&#125;</div><div class=\"line\">fun();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\"></div><div class=\"line\">functioni fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  xm.wife = xh; <span class=\"comment\">//2</span></div><div class=\"line\">  xh.husband = xm; <span class=\"comment\">//2</span></div><div class=\"line\">&#125;</div><div class=\"line\">fn();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>\n<h4 id=\"管理内存\"><a href=\"#管理内存\" class=\"headerlink\" title=\"管理内存\"></a>管理内存</h4><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>在JavaScript中，数据类型分为基本类型和引用类型。</p>\n<ul>\n<li><strong>基本类型：</strong>数字，字符，布尔值，undefined，null</li>\n<li><strong>引用类型：</strong>数组，对象，函数</li>\n<li><strong>区别：</strong>基本类型的值是可以修改的，而引用类型的值不可修改","more":"</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1</span></div><div class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">4</span>;</div><div class=\"line\">num = <span class=\"number\">3</span>; <span class=\"comment\">//这里的值操作并不是修改，而是覆盖</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'string'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.replace(<span class=\"string\">'s'</span>,<span class=\"string\">''</span>); </div><div class=\"line\"><span class=\"comment\">//字符串操作方法replace在执行后并不会改变原来的值str，而是生成一个新的字符串anotherStr</span></div></pre></td></tr></table></figure>\n<p>基本类型是无法添加属性的，但是它们却存在各自的方法以及属性。这是因为每一个基本类型都存在它们自己的包装对象，如数字的包装对象是<code>Number</code>，字符的包装对象是<code>String</code>。包装对象包含了这个类型的属性和方法。</p>\n<h4 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h4><p>在JavaScript中，数据采用堆栈的方式保存。内存分为栈和堆。栈内存是有序排列，每个栈有序号，并且大小是固定的，在读取的时候是按顺序读取的。堆内存是无序排列，大小不固定。因为基本类型是不可修改的，大小不会改变，所以基本类型是保存在栈内存中的。而引用类型是保存在堆内存中的。</p>\n<p>因为引用类型保存在堆中，如果直接在堆中查找会很困难，并且相当的消耗资源，所以引用类型会通过地址来定位，地址则保存在有序的栈中。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-1.png\" alt=\"\"></p>\n<h4 id=\"变量的比较\"><a href=\"#变量的比较\" class=\"headerlink\" title=\"变量的比较\"></a>变量的比较</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//基本类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xmScore = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> xhScore =<span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xmScore === xhScore) <span class=\"comment\">//true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//引用类型的比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//false</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-2.png\" alt=\"\"><br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/stack&amp;heap-3.png\" alt=\"\"><br>在引用类型中，只有指向同一个引用，变量才是相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xm = &#123;</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">score</span>: <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> xh = xm; <span class=\"comment\">//xm保存的是对象的地址，将地址赋值给xh，所以xh所指向和xm是同一个引用</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xm === xh); <span class=\"comment\">//true;</span></div></pre></td></tr></table></figure>\n<p>那么如何比较两个引用类型的属性值是不是相同呢？我们无法通过直接的方式对它们进行比较，只能通过循环遍历它们内部的属性和值来进行比较。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalObjs</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> a) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[p] !== b[p] <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">equalArrays</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(a.length !== b.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(a[i] !== b[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的复制\"><a href=\"#变量的复制\" class=\"headerlink\" title=\"变量的复制\"></a>变量的复制</h4><p>当两个变量指向的是同一个引用类型的时候，如果其中一个变量的属性值发生了改变，那么另一个变量的属性值也会发生改变。如果我们想将一个引用类型赋值给另一个，并且不想发生上述情况的话，还是要用遍历的方式去生成一个新的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObj</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">   newObj[p] = obj[p];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> newObj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上的方法便是<strong>浅拷贝</strong>，之所以是‘浅’,是因为当这个对象有一个属性值是数组的话，在进行拷贝的时候，生成的两个对象中的数组其实是指向同一个引用的，这样我们就无法将两个对象完完全全的分开了。那如何进行深拷贝呢？jQuery中提供了一个方法，既可以进行深拷贝，也可以进行浅拷贝。</p>\n<ul>\n<li><code>$.extend(deep,target,object1,objectN)</code><br>参数说明：<br><code>deep</code>：可选。布尔值。指是否深度合并对象，默认<code>false</code>。<br><code>target</code>：目标对象，其他对象的成员属性将被附加到该对象上。<br><code>object1</code>：可选。指第一个被合并的对象。<br><code>objectN</code>：可选。指第N个被合并的对象。</li>\n</ul>\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125; <span class=\"comment\">// 在函数里声明的a与b是形参</span></div><div class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//在调用函数时传入的参数是实参</span></div></pre></td></tr></table></figure>\n<p>当我们将实参传入到函数的时候，实参和形参做的其实是赋值的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//eg1 当变量为基本类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTen</span>(<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">10</span>;</div><div class=\"line\">addTen(score);</div><div class=\"line\"><span class=\"comment\">//相当于</span></div><div class=\"line\">num = score;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//eg2 当变量为引用类型时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">setName(person);</div></pre></td></tr></table></figure></p>\n<p>当传递的参数是引用类型时，也相当于<code>obj = person</code>，因为引用类型赋值时是对地址进行复制的，所以<code>obj</code>与<code>person</code>实际上指向的都是同一个引用，所以我们对<code>obj</code>的修改也能反应到<code>person</code>上。</p>\n<h4 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h4><p><code>typeof</code>：返回字符串类型。可以区分基本类型，但是无法区分引用类型（<code>null</code>，对象和数组返回的都是<code>object</code>）。<br><code>instanceof</code>：用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性，返回布尔值。可以判断引用类型具体是哪种，只能用于判断引用类型。用法<code>[] instanceof Array</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>变量的作用域可理解为变量起作用的范围，它包括两点：变量的生命周期；在哪里可以访问到变量</p>\n</blockquote>\n<h4 id=\"全局与局部\"><a href=\"#全局与局部\" class=\"headerlink\" title=\"全局与局部\"></a>全局与局部</h4><p>在JS中，变量的作用域分为两种：全局变量和局部变量<br>全局变量的声明方式有两种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">999</span>; <span class=\"comment\">//直接在外部声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  i = <span class=\"number\">888</span>; <span class=\"comment\">//在函数内部声明，但是不适用var命令</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>全局变量的生命周期是只有当所有的程序执行完毕之后，全局变量才会被销毁。而局部变量是在执行完这个函数，就会被销毁。<br>在JS中，局部变量指的就是在函数中声明的变量，因为在JS中并不存在块级作用域。块级作用域指的是用<code>{}</code>包含的域。在其他语言，例如C++，<code>if</code>和<code>for</code>中声明的变量在外部也是无法访问到的。但是JS中，在<code>if</code>和<code>for</code>中声明的变量在整个函数内部都可以访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0; i &lt; 10; i ++) &#123; &#125;</div><div class=\"line\">//等同于</div><div class=\"line\">var i = 0;</div><div class=\"line\">for(i &lt; 10; i ++) &#123; &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"变量的作用域链\"><a href=\"#变量的作用域链\" class=\"headerlink\" title=\"变量的作用域链\"></a>变量的作用域链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">funuction fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> sex = <span class=\"string\">'male'</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'xhei'</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有全局空间中的属性和方法，都是属于window的（<code>window.name = &#39;xm&#39;;</code>）。全局作用域的变量对象是window。局部作用域的变量对象则是看不见的（<code>fn.sex</code>与<code>fn.fn2</code>不存在）。<br>作用域有一个特点，就是在查找变量的时候会先在自己变量的范围中查找，如果找不到，就会沿着作用域网上查找。<br><strong>作用链：</strong> 也称“链式作用域”，指的是子对象会一级一级地向上寻找所以父对象的变量。所以，父对象的所以变量，子对象都是可见的，反之则不成立。<br><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/variable-1.png\" alt=\"\"></p>\n<ul>\n<li><strong>延长作用域链</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.sex = <span class=\"string\">'male'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">4</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span>(person) &#123;</div><div class=\"line\">  name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  sex = <span class=\"string\">'female'</span>;</div><div class=\"line\">  score = <span class=\"number\">44</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">//xh</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//female</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(score); <span class=\"comment\">//44</span></div></pre></td></tr></table></figure>\n<p>使用<code>with</code>的时候，当修改<code>name</code>与<code>sex</code>时，此时查找的作用域是<code>person</code>，但是<code>person</code>中并不存在<code>score</code>这个属性，于是with就随着作用域链查找到<code>window</code>下的<code>score</code>，并将其修改为44。但是延长作用域链会使得查询时间变长，所以并不推荐使用。</p>\n<ul>\n<li><strong>闭包</strong></li>\n</ul>\n<p>在实际应用中，我们有时候可能也需要在函数外部调用函数内部的变量，但是由于作用链这个机制，在函数外部是取不到这个变量的，所以需要绕点弯子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(n); <span class=\"comment\">//999</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> f2; <span class=\"comment\">//将f2作为返回值</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result = f1();</div><div class=\"line\">result(); <span class=\"comment\">//999</span></div></pre></td></tr></table></figure></p>\n<p>以上代码中的f2函数就是闭包，也就是闭包可以理解为<strong>“定义在一个函数内部的函数”</strong>。</p>\n<ul>\n<li><strong>闭包的两个用途</strong>：<ul>\n<li>读取函数内部的变量，是将函数内部和函数外部连接起来的一座桥梁。</li>\n<li>将某些变量的值始终保持在内存中。（JS的垃圾回收机制）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JS解析机制-预解析\"><a href=\"#JS解析机制-预解析\" class=\"headerlink\" title=\"JS解析机制-预解析\"></a>JS解析机制-预解析</h4><p>JS在解析代码的时候，会先进性预解析，进行完预解析后，才开始逐行解析。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xm'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(name);</div><div class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'xh'</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fn(); <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure></p>\n<p>就以上代码来看，这个JS中包含了两个作用域，那么预解析就会分别在两个作用域中进行。首先它会将所有的<code>var</code>找出来，并且将所有的变量都赋值为<code>undefined</code>。然后查找该域中的<code>function</code>，并直接进行声明。也就是说函数在域解析的时候就已经声明好了，但是变量值都还是<code>undefined</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//window域预解析</div><div class=\"line\">var name = undefiied;</div><div class=\"line\">var age = undefined;</div><div class=\"line\">function fn(argument) &#123;</div><div class=\"line\">  console.log(name);</div><div class=\"line\">  var name = &apos;xh&apos;;</div><div class=\"line\">  var age = 10;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//fn域预解析</div><div class=\"line\">var name = undefined;</div><div class=\"line\">var age = undefined;</div><div class=\"line\"></div><div class=\"line\">//逐行解析</div><div class=\"line\">name = &apos;xm&apos;;</div><div class=\"line\">age = 18;</div><div class=\"line\">fn(argument) &#123;</div><div class=\"line\">  console.log(name); //此时fn中的name被预解析赋值为undefined，所有打印出的结果为undefined</div><div class=\"line\">  name = &apos;xh&apos;;</div><div class=\"line\">  age = 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在预解析的机制中，如果变量名与函数名冲突，预解析的时候会只保留函数。如果函数名和函数名冲突的时候，则后面声明的函数会保留。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">a = <span class=\"number\">1</span>; <span class=\"comment\">//预解析不解析没有var的变量，所以浏览器会报错</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><h4 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h4><p><strong>垃圾回收机制：</strong>释放无用的数据，回收内存。可分为自动和手动。JS会自动的帮我们回收垃圾。其原理就是，找出没用的数据，打上标记，释放内存，并按照一定的周期执行。<br><strong>标识无用数据的策略：</strong></p>\n<ul>\n<li><strong>标记清除：</strong>垃圾收集器在运行的时候会给存储在内存中的所有变量一次性都加上标记，然后去掉环境中的变量以及被这些环境中的变量所引用的变量的标记。<strong>环境中的变量</strong>指的是这些变量还没有离开它的执行环境。对于局部变量来说，当这个函数执行完毕之后，这些局部变量就相当于离开了这个函数的执行环境。如果这个函数还在执行中，就表示这个变量还在环境中。排除一些还未离开环境的变量，剩下的变量便是以及离开了它的执行环境的变量，垃圾回收机制会将这些变量全部清除。目前几乎所有的浏览器使用的垃圾回收机制都是标记清除，只不过在时间间隔上有略微的区别。</li>\n<li><strong>引用计数：</strong>引用计数并不常用。它会跟踪计数每个数据所被引用的次数。当我们声明一个变量，并将一个引用类型的值赋值给这个变量时，这个数据就被这个变量引用过一次。如果这个值又被赋值给另外一个变量，则引用次数加一。如果这个变量被赋予了新的引用数据，这原来的数据的引用次数会减一。当引用次数为0时，这个值就会被清除。</li>\n<li><strong>循环引用问题：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">argument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">&#125;</div><div class=\"line\">fun();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//0</span></div><div class=\"line\"></div><div class=\"line\">functioni fn(argument) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> xm = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"keyword\">var</span> xh = &#123;&#125;; <span class=\"comment\">//1</span></div><div class=\"line\">  xm.wife = xh; <span class=\"comment\">//2</span></div><div class=\"line\">  xh.husband = xm; <span class=\"comment\">//2</span></div><div class=\"line\">&#125;</div><div class=\"line\">fn();</div><div class=\"line\">xm = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div><div class=\"line\">xh = <span class=\"literal\">null</span>; <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>由于<code>xm</code>与<code>xh</code>相互引用，导致最后其占用的内存无法被清除，如果循环次数很多的话，就会导致内存占用的越来越多。</p>\n<h4 id=\"管理内存\"><a href=\"#管理内存\" class=\"headerlink\" title=\"管理内存\"></a>管理内存</h4><p>为了让网页节约内存占用，我们有时候需要手动解除引用，即将这些值置为<code>null</code>。而需要我们手动解除的是全局变量，局部变量的内存因为垃圾回收机制会自动的清除。</p>"},{"title":"JS面向对象学习笔记","date":"2017-08-16T13:20:29.000Z","_content":"## 面向对象的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n<!--more-->\n\n为什么使用对象？\n\n\nJavaScript作为一门面向对象的语言，却并不是通过**类**来实现面向对象的，而是通过**原型（prototype）**。那么这两者实现面向对象究竟有什么区别呢？\n\n#### 基于类vs基于原型\n\n基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。\n* **类（class）：**定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。\n* **实例（instance）：**类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。\n\n\n```java\n//定义类\npublic class Person {\n  String name;\n  int age;\n  void walking() {\n  }\n  void sleeping() {\n  }\n  Person(x,y) {\n    name = x;\n    age = y;\n  }//类的构造函数\n}\n//实例化\nPerson xm = new Person('xm',18);\n```\n\n其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。\n而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar xm = new Person('xm',18);\n```\n#### new操作符\n\n在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。\n在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的**两个步骤**\n* 将实例的`._proto_`指向构造函数的`prototype`属性。\n* 调用构造函数来初始化实例对象。（`call`、`apply`）\n\n#### 原型对象\n\n对象不仅仅有自己独特的属性，例如`Person`，每个`Person`的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。\n\n在Java中，共用的方法会采用静态的方式用`static`修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。\n\n而在JS中，则引入了原型对象。原型对象就是构造函数的`prototype`属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个`constructor`属性来指向该原型实例的构造函数。\n\n## 原型链\n\n由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的`_proto_`属性，`constructor`属性和`prototype`属性，它们相互指来指去，就形成了一条原型链。\n\n以`Person`这个构造函数为例，我们创建了它的实例`xm`，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中`_proto_`其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png)\n\n#### 属性查找\n\n当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回`undefined`。\n\n## 创建对象\n\n* 基于Object对象创建\n\n```javascript\nvar person = new Object();\nperson.name = 'xm';\nperson.age = 18;\nperson.getName = function() {\n  return this.name;\n}\n```\n* 字面量的方式：清晰的查找对象包含的属性和方法\n\n```javascript\nvar person = {\n  name: 'xm',\n  age: 18,\n  getName: function() {\n    return this.name;\n  }\n}\n```\n* 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。\n\n```javascript\nfunctioni createPerson(name,age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.getName = function() {\n    return this.name;\n  }\n  return o;\n}\nvar person = createPerson('xm',18);\n```\n* 构造函数模式\n\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n  this.getName = function() {\n    return this.name;\n  }\n}\nvar person = new Person('xm',18);\n```\n* `Object.create(prototype, descriptors)`：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数`prototype`。\n参数说明：\n`prototype`：必需。要用作原型的对象，可以为`null`。\n`descriptors`：可选。包含一个或多个属性描述符的JavaScript对象。\n\n```javascript\nvar var obj = Object.create({x:1});\nobj.hasOwnProperty('x');//false\n```","source":"_posts/17-08-16-22.md","raw":"---\ntitle: JS面向对象学习笔记\ndate: 2017-08-16 21:20:29\ntags:\n---\n## 面向对象的概念\n\n对于面向对象，有以下几个概念：\n* 一切事物皆对象\n* 对象具有封装和继承特性\n* 对象与对象之间使用消息通信，各自存在信息隐藏\n<!--more-->\n\n为什么使用对象？\n\n\nJavaScript作为一门面向对象的语言，却并不是通过**类**来实现面向对象的，而是通过**原型（prototype）**。那么这两者实现面向对象究竟有什么区别呢？\n\n#### 基于类vs基于原型\n\n基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。\n* **类（class）：**定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。\n* **实例（instance）：**类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。\n\n\n```java\n//定义类\npublic class Person {\n  String name;\n  int age;\n  void walking() {\n  }\n  void sleeping() {\n  }\n  Person(x,y) {\n    name = x;\n    age = y;\n  }//类的构造函数\n}\n//实例化\nPerson xm = new Person('xm',18);\n```\n\n其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。\n而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar xm = new Person('xm',18);\n```\n#### new操作符\n\n在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。\n在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的**两个步骤**\n* 将实例的`._proto_`指向构造函数的`prototype`属性。\n* 调用构造函数来初始化实例对象。（`call`、`apply`）\n\n#### 原型对象\n\n对象不仅仅有自己独特的属性，例如`Person`，每个`Person`的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。\n\n在Java中，共用的方法会采用静态的方式用`static`修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。\n\n而在JS中，则引入了原型对象。原型对象就是构造函数的`prototype`属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个`constructor`属性来指向该原型实例的构造函数。\n\n## 原型链\n\n由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的`_proto_`属性，`constructor`属性和`prototype`属性，它们相互指来指去，就形成了一条原型链。\n\n以`Person`这个构造函数为例，我们创建了它的实例`xm`，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中`_proto_`其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png)\n\n#### 属性查找\n\n当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回`undefined`。\n\n## 创建对象\n\n* 基于Object对象创建\n\n```javascript\nvar person = new Object();\nperson.name = 'xm';\nperson.age = 18;\nperson.getName = function() {\n  return this.name;\n}\n```\n* 字面量的方式：清晰的查找对象包含的属性和方法\n\n```javascript\nvar person = {\n  name: 'xm',\n  age: 18,\n  getName: function() {\n    return this.name;\n  }\n}\n```\n* 工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。\n\n```javascript\nfunctioni createPerson(name,age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.getName = function() {\n    return this.name;\n  }\n  return o;\n}\nvar person = createPerson('xm',18);\n```\n* 构造函数模式\n\n```javascript\nfunction Person(name,age) {\n  this.name = name;\n  this.age = age;\n  this.getName = function() {\n    return this.name;\n  }\n}\nvar person = new Person('xm',18);\n```\n* `Object.create(prototype, descriptors)`：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数`prototype`。\n参数说明：\n`prototype`：必需。要用作原型的对象，可以为`null`。\n`descriptors`：可选。包含一个或多个属性描述符的JavaScript对象。\n\n```javascript\nvar var obj = Object.create({x:1});\nobj.hasOwnProperty('x');//false\n```","slug":"17-08-16-22","published":1,"updated":"2017-08-20T07:13:52.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecody000it0cgtyvrd2hj","content":"<h2 id=\"面向对象的概念\"><a href=\"#面向对象的概念\" class=\"headerlink\" title=\"面向对象的概念\"></a>面向对象的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏<a id=\"more\"></a>\n</li>\n</ul>\n<p>为什么使用对象？</p>\n<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>\n<h4 id=\"基于类vs基于原型\"><a href=\"#基于类vs基于原型\" class=\"headerlink\" title=\"基于类vs基于原型\"></a>基于类vs基于原型</h4><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>\n<ul>\n<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>\n<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  String name;</div><div class=\"line\">  <span class=\"keyword\">int</span> age;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">walking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleeping</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Person(x,y) &#123;</div><div class=\"line\">    name = x;</div><div class=\"line\">    age = y;</div><div class=\"line\">  &#125;<span class=\"comment\">//类的构造函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\">Person xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h4><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>\n<ul>\n<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>\n<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>\n</ul>\n<h4 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h4><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>\n<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>\n<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>\n<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png\" alt=\"\"></p>\n<h4 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h4><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li>基于Object对象创建</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.age = <span class=\"number\">18</span>;</div><div class=\"line\">person.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>字面量的方式：清晰的查找对象包含的属性和方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xm'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">functioni createPerson(name,age) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.age = age;</div><div class=\"line\">  o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = createPerson(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>构造函数模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</div><div class=\"line\">obj.hasOwnProperty(<span class=\"string\">'x'</span>);<span class=\"comment\">//false</span></div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"面向对象的概念\"><a href=\"#面向对象的概念\" class=\"headerlink\" title=\"面向对象的概念\"></a>面向对象的概念</h2><p>对于面向对象，有以下几个概念：</p>\n<ul>\n<li>一切事物皆对象</li>\n<li>对象具有封装和继承特性</li>\n<li>对象与对象之间使用消息通信，各自存在信息隐藏","more":"</li>\n</ul>\n<p>为什么使用对象？</p>\n<p>JavaScript作为一门面向对象的语言，却并不是通过<strong>类</strong>来实现面向对象的，而是通过<strong>原型（prototype）</strong>。那么这两者实现面向对象究竟有什么区别呢？</p>\n<h4 id=\"基于类vs基于原型\"><a href=\"#基于类vs基于原型\" class=\"headerlink\" title=\"基于类vs基于原型\"></a>基于类vs基于原型</h4><p>基于类的面向对象语言，比如Java和C++，是构建在两个不同实体的概念之上的：即类和实例。</p>\n<ul>\n<li><strong>类（class）：</strong>定义了所有具有某一组特征对象的属性（可以将Java中的方法和变量以及C++中的成员都视作属性）。类是抽象的事物，而不是其所描述的全部对象中的任何特定的个体。</li>\n<li><strong>实例（instance）：</strong>类的实例化体系；或者说，是类的一个成员。实例具有和其父类完全一致的属性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  String name;</div><div class=\"line\">  <span class=\"keyword\">int</span> age;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">walking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleeping</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Person(x,y) &#123;</div><div class=\"line\">    name = x;</div><div class=\"line\">    age = y;</div><div class=\"line\">  &#125;<span class=\"comment\">//类的构造函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\">Person xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<p>其中，创建类的实例必须调用类的构造方法。类的构造方法是一类和类同名的方法，用于创建类的实例并初始化对象。<br>而对于JavaScript，我们不需要定义一个类，而只需要定义一个构造函数，然后通过这个构造函数就可以创建实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xm = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h4><p>在Java中，new操作符做的是在内存中开辟一个空间，然后生成的实例会通过指针指向这个空间。<br>在JS中，new操作符不仅仅在内存开辟了一个空间，还进行了另外的<strong>两个步骤</strong></p>\n<ul>\n<li>将实例的<code>._proto_</code>指向构造函数的<code>prototype</code>属性。</li>\n<li>调用构造函数来初始化实例对象。（<code>call</code>、<code>apply</code>）</li>\n</ul>\n<h4 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h4><p>对象不仅仅有自己独特的属性，例如<code>Person</code>，每个<code>Person</code>的实例对象不仅有属于自己的姓名与年龄，还有许多共用的方法。如果在每个对象的实例中都存一份方法就会造成空间的浪费。</p>\n<p>在Java中，共用的方法会采用静态的方式用<code>static</code>修饰将这些方法定义成静态成员，这些静态成员会存放在另外的内存空间中，直到该类被卸载的时候才会被回收。</p>\n<p>而在JS中，则引入了原型对象。原型对象就是构造函数的<code>prototype</code>属性，这个属性存放着实例对象需要共享的属性和方法，而那些不需要共享的属性和方法就放在构造函数里面。而在这个原型对象中则存在一个<code>constructor</code>属性来指向该原型实例的构造函数。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>由于JS中，实例是对象，函数是对象，原型也是对象，他们都包含各自的<code>_proto_</code>属性，<code>constructor</code>属性和<code>prototype</code>属性，它们相互指来指去，就形成了一条原型链。</p>\n<p>以<code>Person</code>这个构造函数为例，我们创建了它的实例<code>xm</code>，于是以下的原型链中我们就包含了三种不同的对象，一个是实例，一个是构造函数，还有构造函数的原型对象。其中<code>_proto_</code>其实是浏览器为我们提供的非标准的查看对象原型的访问器，并不是真实存在的属性，所以用虚线表示。</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/prototype.png\" alt=\"\"></p>\n<h4 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h4><p>当查找一个对象的属性时，JS会向上遍历原型链，直到找到给定名称的属性为止，如果查找到原型链的终点（null）时，仍然没有找到，则会返回<code>undefined</code>。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li>基于Object对象创建</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">person.name = <span class=\"string\">'xm'</span>;</div><div class=\"line\">person.age = <span class=\"number\">18</span>;</div><div class=\"line\">person.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>字面量的方式：清晰的查找对象包含的属性和方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xm'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</div><div class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>工厂模式：用于批量创建多构造类似的对象，缺点是无法识别对象的类型（都是Object）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">functioni createPerson(name,age) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.age = age;</div><div class=\"line\">  o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = createPerson(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>构造函数模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'xm'</span>,<span class=\"number\">18</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.create(prototype, descriptors)</code>：是E5中提出的一种新的对象创建方式。它会新建一个对象，并且让这个对象的原型指向参数<code>prototype</code>。<br>参数说明：<br><code>prototype</code>：必需。要用作原型的对象，可以为<code>null</code>。<br><code>descriptors</code>：可选。包含一个或多个属性描述符的JavaScript对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</div><div class=\"line\">obj.hasOwnProperty(<span class=\"string\">'x'</span>);<span class=\"comment\">//false</span></div></pre></td></tr></table></figure>"},{"title":"网络知识补充——浏览器请求过程","date":"2017-08-17T12:49:56.000Z","_content":"当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n<!--more-->\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。\n以Chrome浏览器为例，其解析过程：\n* 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存\n* 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）\n* 读取本地的HOST文件（操作系统的DNS缓存也没有找到）\n* 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求\n\n紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：\n* 查找本地缓存\n* 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求\n* 将迭代查询后的结果返回给操作系统内核同时进行缓存\n\n之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入`Controller`层，进行相关的逻辑处理，以及请求的分发，然后来调用`Model`层，`Model`层主要负责与数据的交互，在交互过程中会它会读取`redis`和数据库中存储的数据，最终将渲染好的页面通过`View`层返回给网络。这时，`httpResponse`就通过层层网络回到浏览器，浏览器根据请求回来的`html`、`css`、`js`进行渲染，最终将页面展现在我们面前。\n\n## DNS\n\nDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：`http://www.baidu.com/`，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。\n**Tip：**电脑中的HOST文件是通过静态匹配IP和域名\n\n#### 域名空间结构\n\n* 根域：`.`，根域名的服务器只有13台\n* 顶级域（一级域）：`edu`、`gov`、`com`、`org`、`mil`、`cn`等，由域名分配组织ISO决定\n  * 组织域\n  ```\n  gov         政府部门\n  com         商业部门\n  edu         教育部门\n  org         民间团体组织\n  net         网络服务机构\n  mil         军事部门\n  ```\n  * 国家或地区域\n  ```\n  cn          中国\n  jp          日本\n  uk          英国\n  au          澳大利亚\n  hk          中国香港\n  ```\n* 二级域：个人和企业向域名分配组织申请的，需要购买，如`baidu`、`sina`等\n* 主机名（三级域）：申请完二级域名后自己规定的，如`www`（代表网页服务）、`NEWS`\n\n一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。\n在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。\n\n#### DNS查询过程\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png)\n\n客户机向指定的域名服务器发送请求，说我想要访问`www.baidu.com.cn`这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（`cn`）的IP地址，紧接着本地域名服务器就向`cn`服务器发送询问，`cn`服务器返回`com.cn`服务器的IP，然后本地服务器接着询问，直到找到`www.baidu.com.cn`的IP地址，再返回给客户机。这个过程就是**DNS迭代查询**。\n\n## TCP/IP\n\n\n\n","source":"_posts/17-08-17-23.md","raw":"---\ntitle: 网络知识补充——浏览器请求过程\ndate: 2017-08-17 20:49:56\ntags:\n---\n当我们在浏览器中输入一个url，页面是如何呈现出来的呢？\n<!--more-->\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png)\n\n首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。\n以Chrome浏览器为例，其解析过程：\n* 搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存\n* 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）\n* 读取本地的HOST文件（操作系统的DNS缓存也没有找到）\n* 浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求\n\n紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：\n* 查找本地缓存\n* 如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求\n* 将迭代查询后的结果返回给操作系统内核同时进行缓存\n\n之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入`Controller`层，进行相关的逻辑处理，以及请求的分发，然后来调用`Model`层，`Model`层主要负责与数据的交互，在交互过程中会它会读取`redis`和数据库中存储的数据，最终将渲染好的页面通过`View`层返回给网络。这时，`httpResponse`就通过层层网络回到浏览器，浏览器根据请求回来的`html`、`css`、`js`进行渲染，最终将页面展现在我们面前。\n\n## DNS\n\nDNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：`http://www.baidu.com/`，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。\n**Tip：**电脑中的HOST文件是通过静态匹配IP和域名\n\n#### 域名空间结构\n\n* 根域：`.`，根域名的服务器只有13台\n* 顶级域（一级域）：`edu`、`gov`、`com`、`org`、`mil`、`cn`等，由域名分配组织ISO决定\n  * 组织域\n  ```\n  gov         政府部门\n  com         商业部门\n  edu         教育部门\n  org         民间团体组织\n  net         网络服务机构\n  mil         军事部门\n  ```\n  * 国家或地区域\n  ```\n  cn          中国\n  jp          日本\n  uk          英国\n  au          澳大利亚\n  hk          中国香港\n  ```\n* 二级域：个人和企业向域名分配组织申请的，需要购买，如`baidu`、`sina`等\n* 主机名（三级域）：申请完二级域名后自己规定的，如`www`（代表网页服务）、`NEWS`\n\n一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。\n在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。\n\n#### DNS查询过程\n\n![](https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png)\n\n客户机向指定的域名服务器发送请求，说我想要访问`www.baidu.com.cn`这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（`cn`）的IP地址，紧接着本地域名服务器就向`cn`服务器发送询问，`cn`服务器返回`com.cn`服务器的IP，然后本地服务器接着询问，直到找到`www.baidu.com.cn`的IP地址，再返回给客户机。这个过程就是**DNS迭代查询**。\n\n## TCP/IP\n\n\n\n","slug":"17-08-17-23","published":1,"updated":"2017-08-19T10:41:05.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecoe1000jt0cgk043r44d","content":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？<br><a id=\"more\"></a></p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt=\"\"></p>\n<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>\n<ul>\n<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>\n<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>\n<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>\n<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>\n</ul>\n<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>\n<ul>\n<li>查找本地缓存</li>\n<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>\n<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>\n</ul>\n<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>\n<h4 id=\"域名空间结构\"><a href=\"#域名空间结构\" class=\"headerlink\" title=\"域名空间结构\"></a>域名空间结构</h4><ul>\n<li>根域：<code>.</code>，根域名的服务器只有13台</li>\n<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>\n<ul>\n<li><p>组织域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">gov         政府部门</div><div class=\"line\">com         商业部门</div><div class=\"line\">edu         教育部门</div><div class=\"line\">org         民间团体组织</div><div class=\"line\">net         网络服务机构</div><div class=\"line\">mil         军事部门</div></pre></td></tr></table></figure>\n</li>\n<li><p>国家或地区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cn          中国</div><div class=\"line\">jp          日本</div><div class=\"line\">uk          英国</div><div class=\"line\">au          澳大利亚</div><div class=\"line\">hk          中国香港</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>\n</li>\n<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>\n</ul>\n<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>\n<h4 id=\"DNS查询过程\"><a href=\"#DNS查询过程\" class=\"headerlink\" title=\"DNS查询过程\"></a>DNS查询过程</h4><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png\" alt=\"\"></p>\n<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>\n<h2 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h2>","site":{"data":{}},"excerpt":"<p>当我们在浏览器中输入一个url，页面是如何呈现出来的呢？<br>","more":"</p>\n<p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http.png\" alt=\"\"></p>\n<p>首先，我们在浏览器中输入一个url，浏览器的核心代码会将这个url进行拆分解析。<br>以Chrome浏览器为例，其解析过程：</p>\n<ul>\n<li>搜索浏览器自身的DNS缓存，看这个域名的IP地址是否已经缓存</li>\n<li>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）</li>\n<li>读取本地的HOST文件（操作系统的DNS缓存也没有找到）</li>\n<li>浏览器发起一个DNS的一个系统调用，向宽带运营商的DNS服务器发送一个域名请求</li>\n</ul>\n<p>紧接着我们就来到了DNS服务器，DNS服务器接受到请求后，开始如下操作：</p>\n<ul>\n<li>查找本地缓存</li>\n<li>如果未找到对应条目，则服务器将发起一个迭代DNS解析的请求</li>\n<li>将迭代查询后的结果返回给操作系统内核同时进行缓存</li>\n</ul>\n<p>之后操作系统内核把结果返回给浏览器，浏览器拿到了域名对应的IP地址。这时，浏览器就可以向这个IP地址发送请求，请求通过我们的协议，经过了层层的网络，到达服务端。服务端有一个MVC架构，请求首先会进入<code>Controller</code>层，进行相关的逻辑处理，以及请求的分发，然后来调用<code>Model</code>层，<code>Model</code>层主要负责与数据的交互，在交互过程中会它会读取<code>redis</code>和数据库中存储的数据，最终将渲染好的页面通过<code>View</code>层返回给网络。这时，<code>httpResponse</code>就通过层层网络回到浏览器，浏览器根据请求回来的<code>html</code>、<code>css</code>、<code>js</code>进行渲染，最终将页面展现在我们面前。</p>\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS全名Domain Name System，我们在互联网中，我们通过IP地址来进行通信，由于IP地址是用数字表示的，看着很不直观难以记忆，所以使用域名来帮助记忆，如：<code>http://www.baidu.com/</code>，而DNS的作用就是将域名转换成IP，或将IP转换成域名，这个过程也叫做解析。<br><strong>Tip：</strong>电脑中的HOST文件是通过静态匹配IP和域名</p>\n<h4 id=\"域名空间结构\"><a href=\"#域名空间结构\" class=\"headerlink\" title=\"域名空间结构\"></a>域名空间结构</h4><ul>\n<li>根域：<code>.</code>，根域名的服务器只有13台</li>\n<li><p>顶级域（一级域）：<code>edu</code>、<code>gov</code>、<code>com</code>、<code>org</code>、<code>mil</code>、<code>cn</code>等，由域名分配组织ISO决定</p>\n<ul>\n<li><p>组织域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">gov         政府部门</div><div class=\"line\">com         商业部门</div><div class=\"line\">edu         教育部门</div><div class=\"line\">org         民间团体组织</div><div class=\"line\">net         网络服务机构</div><div class=\"line\">mil         军事部门</div></pre></td></tr></table></figure>\n</li>\n<li><p>国家或地区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cn          中国</div><div class=\"line\">jp          日本</div><div class=\"line\">uk          英国</div><div class=\"line\">au          澳大利亚</div><div class=\"line\">hk          中国香港</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>二级域：个人和企业向域名分配组织申请的，需要购买，如<code>baidu</code>、<code>sina</code>等</p>\n</li>\n<li>主机名（三级域）：申请完二级域名后自己规定的，如<code>www</code>（代表网页服务）、<code>NEWS</code></li>\n</ul>\n<p>一个完整的域名是由三级域 + 二级域 + 一级域组成的，并且是全球唯一的。<br>在互联网中，域名是由结构有规划的。因为域名进行了分级，在进行域名和IP地址解析时才能更容易的找到，即根域名只负责管理一级域名，而一级域名负责管理自己以下的二级域名，以此类推。</p>\n<h4 id=\"DNS查询过程\"><a href=\"#DNS查询过程\" class=\"headerlink\" title=\"DNS查询过程\"></a>DNS查询过程</h4><p><img src=\"https://github.com/Yx1aoq1/Yx1aoq1.github.io/raw/master/images/http-2.png\" alt=\"\"></p>\n<p>客户机向指定的域名服务器发送请求，说我想要访问<code>www.baidu.com.cn</code>这个网站，如果这台域名服务器并没有缓存这个域名的IP地址，那么它就会向根DNS服务器询问（每个本地域名服务器都会保存全球13台根服务器的IP地址），根DNS服务器将会返回它管理下的一级域名（<code>cn</code>）的IP地址，紧接着本地域名服务器就向<code>cn</code>服务器发送询问，<code>cn</code>服务器返回<code>com.cn</code>服务器的IP，然后本地服务器接着询问，直到找到<code>www.baidu.com.cn</code>的IP地址，再返回给客户机。这个过程就是<strong>DNS迭代查询</strong>。</p>\n<h2 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h2>"},{"title":"页面加载——浏览器渲染","date":"2017-08-19T10:46:53.000Z","_content":"一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n<!--more-->\n\n## 顺序执行、并发加载\n\n因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入`<link>`或`<script>`，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。\n\n对于`<img>`所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。\n\n```javascript\nwindow.addEventListener('load', function() {\n  // 页面的全部资源加载完才会执行，包括图片、视频\n})\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // DOM 渲染完即可执行，此时图片、视频可能还没加载完\n})\n```\n\n## 阻塞\n\n#### CSS阻塞\n* **css在`<head>`中阻塞页面的渲染：**即这个页面要呈现出效果需要等待这个`<link>`所对应的css资源加载完成以后才能进行渲染。如果css并不是在`<head>`中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在`<head>`标签中就引入。\n* **css阻塞js的执行：**即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作`DOM`元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。\n* **css不阻塞外部脚本的加载：**即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在`HTMLPreloadScanner`类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。\n\n#### JS阻塞\n* **直接引入的js阻塞页面的渲染：**直接引入指的是没有通过`defer`和`async`方法直接用`<script>`引入的js资源。如果在标签中指定了`defer`方法，这个资源将在页面解析到`<script>`的时候就开始下载，但不会执行，直到`DOM`加载完成（触发`onload`事件前）才会被调用。而`async`与`defer`的作用是相同的，它们的区别在于`sync`的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作`DOM`元素。\n* **js不阻塞资源的加载：**与css的加载同理，由于有扫描器的存在，资源会并行加载。\n* **js顺序执行，阻塞后续js逻辑的运行：**即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。\n\n## 引入方法\n\n#### 脚本的位置\n\n```html \n<html>\n<head>\n<title>Source Example</title>\n<script type=\"text/javascript\" src=\"script1.js\"></script>\n<script type=\"text/javascript\" src=\"script2.js\"></script>\n<script type=\"text/javascript\" src=\"script3.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n</body>\n</html>\n```\n当我们在`<head>`中引入js文件时，由于js的阻塞特性，当浏览器解析到`<script>`标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。\n```html \n<html>\n<head>\n<title>Source Example</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n\n    <!-- <script> 文件推荐放在这儿 -->\n    <script type=\"text/javascript\" src=\"script1.js\"></script>\n    <script type=\"text/javascript\" src=\"script2.js\"></script>\n    <script type=\"text/javascript\" src=\"script3.js\"></script>\n</body>\n</html>\n```\n所以建议把`<script>`放在`<body>`末尾，因为此时样式和`DOM`元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。\n\n#### 无阻塞脚本\n\n* `defer`属性：是HTML4为`<script>`拓展的属性，指明本元素所含的脚本不会修改`DOM`，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。\n\n```html \n<html>\n<head>\n<title>Script Defer Example</title>\n</head>\n<body>\n    <script type=\"text/javascript\" defer>\n        console.log(\"defer\");\n    </script>\n    <script type=\"text/javascript\">\n        console.log(\"script\");\n    </script>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            console.log(\"load\");\n        };\n    </script>\n</body>\n</html>\n```\n该段代码执行后的结果是`script`、`defer`、`load`，表明含有`defer`属性的脚本是在`onload`执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。\n* `async`属性：是HTML5为`<script>`拓展的属性，作用和`defer`一样，能够异步地加载和执行脚本。它比`defer`有更好的兼容性，但由于`async`在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。\n\n#### 动态脚本\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n该方式可以让`<script>`无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他`DOM`元素是并行的，所以可能出现这个文件中绑定操作的`DOM`元素还没加载，因为找不到而报错。\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.onload = function(){\n  console.log(\"Script loaded!\");\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n在Firefox、Opera、Chrom和Safari 3+中提供了`script.onload`事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即`readystatechange`事件。\n> `uninitialized`：默认状态\n> `loading`：下载开始\n> `loaded`：下载完成\n> `interactive`：下载完成但尚不可用\n> `complete`：所有数据已经准备好 \n\n```javascript\nvar script = document.createElement(\"script\");\nscript.type = \"text/javascript\";\n\n//Internet Explorer\nscript.onreadystatechange = function(){\n  if (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n    script.onreadystatechange = null;\n    console.log(\"Script loaded.\");\n  }\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。\n```javascript\nfunction loadScript(url, callback) {\n  var script = document.creatElement(\"script\");\n  script.type = \"text/javascript\";\n  if(script.readyState) {\n    script.onreadystatechange = function() {\n      if(script.readyState == \"loaded\" || script.readyState == \"complete\") {\n        script.onreadystatechange = null;\n        callback();\n      }\n    }\n  } else {\n    script.onload = function() {\n      callback();\n    }\n  }\n  script.src = url;\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n```\n如此就可以通过嵌套调用来保证他们的加载顺序：\n```javascript\nloadScript(\"script1.js\",function() {\n  loadScript(\"script2.js\",function() {\n\talert(\"all files are loaded!\");\n  })\n})\n```\n\n#### XMLHttpRequest(XHR)对象\n\n可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。\n\n","source":"_posts/17-08-19-24.md","raw":"---\ntitle: 页面加载——浏览器渲染\ndate: 2017-08-19 18:46:53\ntags:\n---\n一个网站在浏览器端是如何进行渲染的呢？\n* 根据HTML结构生成`DOM tree`\n* 根据CSS生成`CSSOM`\n* 将`DOM`和`CSSOM`整合形成`RenderTree`\n* 根据`RenderTree`开始渲染和展示\n* 遇到`<script>`时，会执行并阻塞渲染\n<!--more-->\n\n## 顺序执行、并发加载\n\n因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入`<link>`或`<script>`，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。\n\n对于`<img>`所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。\n\n```javascript\nwindow.addEventListener('load', function() {\n  // 页面的全部资源加载完才会执行，包括图片、视频\n})\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // DOM 渲染完即可执行，此时图片、视频可能还没加载完\n})\n```\n\n## 阻塞\n\n#### CSS阻塞\n* **css在`<head>`中阻塞页面的渲染：**即这个页面要呈现出效果需要等待这个`<link>`所对应的css资源加载完成以后才能进行渲染。如果css并不是在`<head>`中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在`<head>`标签中就引入。\n* **css阻塞js的执行：**即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作`DOM`元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。\n* **css不阻塞外部脚本的加载：**即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在`HTMLPreloadScanner`类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。\n\n#### JS阻塞\n* **直接引入的js阻塞页面的渲染：**直接引入指的是没有通过`defer`和`async`方法直接用`<script>`引入的js资源。如果在标签中指定了`defer`方法，这个资源将在页面解析到`<script>`的时候就开始下载，但不会执行，直到`DOM`加载完成（触发`onload`事件前）才会被调用。而`async`与`defer`的作用是相同的，它们的区别在于`sync`的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作`DOM`元素。\n* **js不阻塞资源的加载：**与css的加载同理，由于有扫描器的存在，资源会并行加载。\n* **js顺序执行，阻塞后续js逻辑的运行：**即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。\n\n## 引入方法\n\n#### 脚本的位置\n\n```html \n<html>\n<head>\n<title>Source Example</title>\n<script type=\"text/javascript\" src=\"script1.js\"></script>\n<script type=\"text/javascript\" src=\"script2.js\"></script>\n<script type=\"text/javascript\" src=\"script3.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n</body>\n</html>\n```\n当我们在`<head>`中引入js文件时，由于js的阻塞特性，当浏览器解析到`<script>`标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。\n```html \n<html>\n<head>\n<title>Source Example</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n<body>\n    <p>Hello world!</p>\n\n    <!-- <script> 文件推荐放在这儿 -->\n    <script type=\"text/javascript\" src=\"script1.js\"></script>\n    <script type=\"text/javascript\" src=\"script2.js\"></script>\n    <script type=\"text/javascript\" src=\"script3.js\"></script>\n</body>\n</html>\n```\n所以建议把`<script>`放在`<body>`末尾，因为此时样式和`DOM`元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。\n\n#### 无阻塞脚本\n\n* `defer`属性：是HTML4为`<script>`拓展的属性，指明本元素所含的脚本不会修改`DOM`，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。\n\n```html \n<html>\n<head>\n<title>Script Defer Example</title>\n</head>\n<body>\n    <script type=\"text/javascript\" defer>\n        console.log(\"defer\");\n    </script>\n    <script type=\"text/javascript\">\n        console.log(\"script\");\n    </script>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            console.log(\"load\");\n        };\n    </script>\n</body>\n</html>\n```\n该段代码执行后的结果是`script`、`defer`、`load`，表明含有`defer`属性的脚本是在`onload`执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。\n* `async`属性：是HTML5为`<script>`拓展的属性，作用和`defer`一样，能够异步地加载和执行脚本。它比`defer`有更好的兼容性，但由于`async`在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。\n\n#### 动态脚本\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n该方式可以让`<script>`无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他`DOM`元素是并行的，所以可能出现这个文件中绑定操作的`DOM`元素还没加载，因为找不到而报错。\n\n```javascript\nvar script = document.createElement (\"script\");\n\nscript.type = \"text/javascript\";\nscript.onload = function(){\n  console.log(\"Script loaded!\");\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n在Firefox、Opera、Chrom和Safari 3+中提供了`script.onload`事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即`readystatechange`事件。\n> `uninitialized`：默认状态\n> `loading`：下载开始\n> `loaded`：下载完成\n> `interactive`：下载完成但尚不可用\n> `complete`：所有数据已经准备好 \n\n```javascript\nvar script = document.createElement(\"script\");\nscript.type = \"text/javascript\";\n\n//Internet Explorer\nscript.onreadystatechange = function(){\n  if (script.readyState == \"loaded\" || script.readyState == \"complete\"){\n    script.onreadystatechange = null;\n    console.log(\"Script loaded.\");\n  }\n};\nscript.src = \"script1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n```\n虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。\n```javascript\nfunction loadScript(url, callback) {\n  var script = document.creatElement(\"script\");\n  script.type = \"text/javascript\";\n  if(script.readyState) {\n    script.onreadystatechange = function() {\n      if(script.readyState == \"loaded\" || script.readyState == \"complete\") {\n        script.onreadystatechange = null;\n        callback();\n      }\n    }\n  } else {\n    script.onload = function() {\n      callback();\n    }\n  }\n  script.src = url;\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n```\n如此就可以通过嵌套调用来保证他们的加载顺序：\n```javascript\nloadScript(\"script1.js\",function() {\n  loadScript(\"script2.js\",function() {\n\talert(\"all files are loaded!\");\n  })\n})\n```\n\n#### XMLHttpRequest(XHR)对象\n\n可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。\n\n","slug":"17-08-19-24","published":1,"updated":"2017-08-20T07:04:55.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kecoe2000kt0cgsmxv29e6","content":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"顺序执行、并发加载\"><a href=\"#顺序执行、并发加载\" class=\"headerlink\" title=\"顺序执行、并发加载\"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>\n<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 页面的全部资源加载完才会执行，包括图片、视频</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><h4 id=\"CSS阻塞\"><a href=\"#CSS阻塞\" class=\"headerlink\" title=\"CSS阻塞\"></a>CSS阻塞</h4><ul>\n<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>\n<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>\n<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>\n</ul>\n<h4 id=\"JS阻塞\"><a href=\"#JS阻塞\" class=\"headerlink\" title=\"JS阻塞\"></a>JS阻塞</h4><ul>\n<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>\n<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>\n<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>\n</ul>\n<h2 id=\"引入方法\"><a href=\"#引入方法\" class=\"headerlink\" title=\"引入方法\"></a>引入方法</h2><h4 id=\"脚本的位置\"><a href=\"#脚本的位置\" class=\"headerlink\" title=\"脚本的位置\"></a>脚本的位置</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"styles.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>\n<h4 id=\"无阻塞脚本\"><a href=\"#无阻塞脚本\" class=\"headerlink\" title=\"无阻塞脚本\"></a>无阻塞脚本</h4><ul>\n<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Script Defer Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"defer\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"load\"</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>\n<ul>\n<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>\n</ul>\n<h4 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>\n<blockquote>\n<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Internet Explorer</span></div><div class=\"line\">script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>)&#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded.\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">  script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span>(script.readyState) &#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>) &#123;</div><div class=\"line\">        script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">        callback();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      callback();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  script.src = url;</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loadScript(<span class=\"string\">\"script1.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  loadScript(<span class=\"string\">\"script2.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"string\">\"all files are loaded!\"</span>);</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"XMLHttpRequest-XHR-对象\"><a href=\"#XMLHttpRequest-XHR-对象\" class=\"headerlink\" title=\"XMLHttpRequest(XHR)对象\"></a>XMLHttpRequest(XHR)对象</h4><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>\n","site":{"data":{}},"excerpt":"<p>一个网站在浏览器端是如何进行渲染的呢？</p>\n<ul>\n<li>根据HTML结构生成<code>DOM tree</code></li>\n<li>根据CSS生成<code>CSSOM</code></li>\n<li>将<code>DOM</code>和<code>CSSOM</code>整合形成<code>RenderTree</code></li>\n<li>根据<code>RenderTree</code>开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染","more":"</li>\n</ul>\n<h2 id=\"顺序执行、并发加载\"><a href=\"#顺序执行、并发加载\" class=\"headerlink\" title=\"顺序执行、并发加载\"></a>顺序执行、并发加载</h2><p>因为解析过程是一个从上到下的过程，所以渲染过程是顺序执行的。而所谓的并发加载指的是当浏览器引入<code>&lt;link&gt;</code>或<code>&lt;script&gt;</code>，多个标签的资源可以并发加载。但是并发度是受浏览器自身能力限制的。</p>\n<p>对于<code>&lt;img&gt;</code>所载入的图片，是异步请求的，并不会阻塞页面的渲染，图片的加载速度受其本身大小的影响（图片太大可能在整个页面加载完之后它还没加载出来）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 页面的全部资源加载完才会执行，包括图片、视频</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM 渲染完即可执行，此时图片、视频可能还没加载完</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><h4 id=\"CSS阻塞\"><a href=\"#CSS阻塞\" class=\"headerlink\" title=\"CSS阻塞\"></a>CSS阻塞</h4><ul>\n<li><strong>css在<code>&lt;head&gt;</code>中阻塞页面的渲染：</strong>即这个页面要呈现出效果需要等待这个<code>&lt;link&gt;</code>所对应的css资源加载完成以后才能进行渲染。如果css并不是在<code>&lt;head&gt;</code>中引入的话，会出现元素先展示在页面上过一会样式才呈现的情况，所以推荐css在<code>&lt;head&gt;</code>标签中就引入。</li>\n<li><strong>css阻塞js的执行：</strong>即在css资源加载完成之前，后续的js的是无法执行的。由于js文件经常会操作<code>DOM</code>元素，而操作过程中可能涉及css样式的修改，它的修改是依赖之前引入的css所具有的样式的，所以css会阻塞js的执行。</li>\n<li><strong>css不阻塞外部脚本的加载：</strong>即css资源不会阻塞后续的js资源的加载，但是只能加载不会执行。由于webkit存在<code>HTMLPreloadScanner</code>类，是一个预先扫描器，它可以预先扫描后面的词语，在扫描到一些需要加载的资源后，会通过预资源加载器请求后续的资源加载。</li>\n</ul>\n<h4 id=\"JS阻塞\"><a href=\"#JS阻塞\" class=\"headerlink\" title=\"JS阻塞\"></a>JS阻塞</h4><ul>\n<li><strong>直接引入的js阻塞页面的渲染：</strong>直接引入指的是没有通过<code>defer</code>和<code>async</code>方法直接用<code>&lt;script&gt;</code>引入的js资源。如果在标签中指定了<code>defer</code>方法，这个资源将在页面解析到<code>&lt;script&gt;</code>的时候就开始下载，但不会执行，直到<code>DOM</code>加载完成（触发<code>onload</code>事件前）才会被调用。而<code>async</code>与<code>defer</code>的作用是相同的，它们的区别在于<code>sync</code>的执行是在下载完成之后就开始执行了，所以进行异步加载的脚本最好不要操作<code>DOM</code>元素。</li>\n<li><strong>js不阻塞资源的加载：</strong>与css的加载同理，由于有扫描器的存在，资源会并行加载。</li>\n<li><strong>js顺序执行，阻塞后续js逻辑的运行：</strong>即js的执行顺序是和引入的顺序一致。这是由于js的执行是单线程的，所以它会顺序执行并阻塞后续js的执行。</li>\n</ul>\n<h2 id=\"引入方法\"><a href=\"#引入方法\" class=\"headerlink\" title=\"引入方法\"></a>引入方法</h2><h4 id=\"脚本的位置\"><a href=\"#脚本的位置\" class=\"headerlink\" title=\"脚本的位置\"></a>脚本的位置</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当我们在<code>&lt;head&gt;</code>中引入js文件时，由于js的阻塞特性，当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码。虽然后续的资源仍然可以继续加载，却无法渲染，这就造成了打开页面后的空白时间过长，影响用户体验。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Source Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"styles.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">&lt;!-- &lt;script&gt; 文件推荐放在这儿 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"script3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>所以建议把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>末尾，因为此时样式和<code>DOM</code>元素都已经加载并渲染完毕，所以页面的下载就不会显得太慢。</p>\n<h4 id=\"无阻塞脚本\"><a href=\"#无阻塞脚本\" class=\"headerlink\" title=\"无阻塞脚本\"></a>无阻塞脚本</h4><ul>\n<li><code>defer</code>属性：是HTML4为<code>&lt;script&gt;</code>拓展的属性，指明本元素所含的脚本不会修改<code>DOM</code>，因此代码能安全地延迟执行。只支持IE4和Firefox 3.5以上版本的浏览器。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Script Defer Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"defer\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"load\"</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>该段代码执行后的结果是<code>script</code>、<code>defer</code>、<code>load</code>，表明含有<code>defer</code>属性的脚本是在<code>onload</code>执行前被调用的，不论它写的位置在哪里。该方法虽好却存在兼容性问题。</p>\n<ul>\n<li><code>async</code>属性：是HTML5为<code>&lt;script&gt;</code>拓展的属性，作用和<code>defer</code>一样，能够异步地加载和执行脚本。它比<code>defer</code>有更好的兼容性，但由于<code>async</code>在加载完毕后就会立即执行，所以脚本的执行顺序就可能不是按照html文本的引入顺序，如果两个js前后有依赖关系，就会出现错误。</li>\n</ul>\n<h4 id=\"动态脚本\"><a href=\"#动态脚本\" class=\"headerlink\" title=\"动态脚本\"></a>动态脚本</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>该方式可以让<code>&lt;script&gt;</code>无论在什么地方引入，文件的下载和运行都不会阻塞页面的处理过程。但是由于引入的文件的下载和运行和其他<code>DOM</code>元素是并行的，所以可能出现这个文件中绑定操作的<code>DOM</code>元素还没加载，因为找不到而报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement (<span class=\"string\">\"script\"</span>);</div><div class=\"line\"></div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>在Firefox、Opera、Chrom和Safari 3+中提供了<code>script.onload</code>事件，可以监听onload事件来加载js脚本。而对于IE，则是用另一种方式，即<code>readystatechange</code>事件。</p>\n<blockquote>\n<p><code>uninitialized</code>：默认状态<br><code>loading</code>：下载开始<br><code>loaded</code>：下载完成<br><code>interactive</code>：下载完成但尚不可用<br><code>complete</code>：所有数据已经准备好 </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Internet Explorer</span></div><div class=\"line\">script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>)&#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Script loaded.\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">script.src = <span class=\"string\">\"script1.js\"</span>;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div></pre></td></tr></table></figure>\n<p>虽然以上的动态加载方法可以解决阻塞问题，却还是存在依赖问题，即无法控制两个互相依赖的js文件的先后加载顺序，所以我们可以对这个方法进行封装。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">  script.type = <span class=\"string\">\"text/javascript\"</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span>(script.readyState) &#123;</div><div class=\"line\">    script.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(script.readyState == <span class=\"string\">\"loaded\"</span> || script.readyState == <span class=\"string\">\"complete\"</span>) &#123;</div><div class=\"line\">        script.onreadystatechange = <span class=\"literal\">null</span>;</div><div class=\"line\">        callback();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    script.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      callback();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  script.src = url;</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如此就可以通过嵌套调用来保证他们的加载顺序：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loadScript(<span class=\"string\">\"script1.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  loadScript(<span class=\"string\">\"script2.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\talert(<span class=\"string\">\"all files are loaded!\"</span>);</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"XMLHttpRequest-XHR-对象\"><a href=\"#XMLHttpRequest-XHR-对象\" class=\"headerlink\" title=\"XMLHttpRequest(XHR)对象\"></a>XMLHttpRequest(XHR)对象</h4><p>可以利用ajax异步请求的方式，向服务器发送一个获取js文件的请求，在请求成功之后执行动态加载的方法。该方法的优点是可以下载但不立即执行js代码，并且兼容性好。但此方法也有限制：即js文件必须与页面放置在同一个域内（跨域问题），不能从CDN下载，所以大型网站通常不采用XHR脚本注入技术。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}