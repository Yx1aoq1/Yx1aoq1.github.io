---
title: 【算法】动态规划
categories:
  - 算法
tags:
  - 动态规划
date: 2021-12-11 21:12:33
---

## 动态规划

动态规划（Dynamic programming，简称DP）：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划背后的基本思想大致上为：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

### 动态规划与贪心算法

在贪心算法中，我们也需要将求解问题分为若干个小问题，他们的不同点是：

* 动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题时才能做出选择。而贪心算法仅在当前状态下做出最好选择，即局部最优解，然后再去解做出这个选择后产生的相应子问题。
* 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行。

简而言之：某种程度上，动规是贪心的泛化，贪心是动规的特例。

## 相关应用

### 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**解题思路**

我们可以从最后一步入手，上最后一阶楼梯时，要么是爬1步，要么是爬两步，所以爬n阶的方法就等于爬n-1阶的方法加上爬n-2阶的方法。
$$
a[n] = a[n-1] + a[n-2]
$$
我们可以知道，爬第一阶，与第二阶的结果分别是1和2，所以将这两个结果最为最开始的基数，一层一层向上计算，直到获得n阶的结果

```javascript
var climbStairs = function (n) {
    let arr = []
    arr[1] = 1
    arr[2] = 2
    if (n <= 2) {
        return arr[n]
    }
    for (let i = 3; i <= n; i ++) {
        arr[i] = arr[i-1] + arr[i-2]
    }
    return arr[n]
}
```

### 
